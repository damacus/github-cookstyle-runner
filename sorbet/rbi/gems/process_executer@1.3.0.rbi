# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `process_executer` gem.
# Please instead update this file by running `bin/tapioca gem process_executer`.


# The `ProcessExecuter` module provides methods to execute subprocess commands
# with enhanced features such as output capture, timeout handling, and custom
# environment variables.
#
# Methods:
# * {run}: Executes a command and captures its output and status in a result object.
# * {spawn}: Executes a command and returns its exit status.
#
# Features:
# * Supports executing commands via a shell or directly.
# * Captures stdout and stderr to buffers, files, or custom objects.
# * Optionally enforces timeouts and terminates long-running commands.
# * Provides detailed status information, including success, failure, or timeout states.
#
# @api public
#
# source://process_executer//lib/process_executer/monitored_pipe.rb#6
module ProcessExecuter
  class << self
    # Execute the given command as a subprocess, blocking until it finishes
    #
    # Returns a result object which includes the process's status and output.
    #
    # Supports the same features as
    # [Process.spawn](https://docs.ruby-lang.org/en/3.3/Process.html#method-c-spawn).
    # In addition, it:
    #
    # 1. Blocks until the command exits
    # 2. Captures stdout and stderr to a buffer or file
    # 3. Optionally kills the command if it exceeds a timeout
    #
    # This method takes two forms:
    #
    # 1. The command is executed via a shell when the command is given as a single
    #    string:
    #
    #     `ProcessExecuter.run([env, ] command_line, options = {}) ->` {ProcessExecuter::Command::Result}
    #
    # 2. The command is executed directly (bypassing the shell) when the command and it
    #    arguments are given as an array of strings:
    #
    #     `ProcessExecuter.run([env, ] exe_path, *args, options = {}) ->` {ProcessExecuter::Command::Result}
    #
    # Optional argument `env` is a hash that affects ENV for the new process; see
    # [Execution
    # Environment](https://docs.ruby-lang.org/en/3.3/Process.html#module-Process-label-Execution+Environment).
    #
    # Argument `options` is a hash of options for the new process. See the options listed below.
    #
    # @api public
    # @example Run a command given as an array of strings (does not use shell)
    #   # The command and its args must be provided as separate strings in the array.
    #   # Shell expansions and redirections are not supported.
    #   command = ['git', 'clone', 'https://github.com/main-branch/process_executer']
    #   result = ProcessExecuter.run(*command)
    #   result.success? #=> true
    #   result.stdout.string #=> ""
    #   result.stderr.string #=> "Cloning into 'process_executer'...\n"
    # @example Run a command with a timeout
    #   command = ['sleep', '1']
    #   result = ProcessExecuter.run(*command, timeout: 0.01)
    #   #=> raises ProcessExecuter::Command::TimeoutError which contains the command result
    # @example Run a command which fails
    #   command = ['exit 1']
    #   result = ProcessExecuter.run(*command)
    #   #=> raises ProcessExecuter::Command::FailedError which contains the command result
    # @example Run a command which exits due to an unhandled signal
    #   command = ['kill -9 $$']
    #   result = ProcessExecuter.run(*command)
    #   #=> raises ProcessExecuter::Command::SignaledError which contains the command result
    # @example Return a result instead of raising an error when `raise_errors` is `false`
    #   # By setting `raise_errors` to `false`, exceptions will not be raised even
    #   # if the command fails.
    #   command = ['echo "Some error" 1>&2 && exit 1']
    #   result = ProcessExecuter.run(*command, raise_errors: false)
    #   # An error is not raised
    #   result.success? #=> false
    #   result.exitstatus #=> 1
    #   result.stdout.string #=> ""
    #   result.stderr.string #=> "Some error\n"
    # @example Set environment variables
    #   env = { 'FOO' => 'foo', 'BAR' => 'bar' }
    #   command = 'echo "$FOO$BAR"'
    #   result = ProcessExecuter.run(env, *command)
    #   result.stdout.string #=> "foobar\n"
    # @example Set environment variables when using a command array
    #   env = { 'GIT_DIR' => '/path/to/.git' }
    #   command = ['git', 'status']
    #   result = ProcessExecuter.run(env, *command)
    #   result.stdout.string #=> "On branch main\nYour branch is ..."
    # @example Unset environment variables
    #   env = { 'GIT_DIR' => nil } # setting to nil unsets the variable in the environment
    #   command = ['git', 'status']
    #   result = ProcessExecuter.run(env, *command)
    #   result.stdout.string #=> "On branch main\nYour branch is ..."
    # @example Reset existing environment variables and add new ones
    #   env = { 'PATH' => '/bin' }
    #   result = ProcessExecuter.run(env, 'echo "Home: $HOME" && echo "Path: $PATH"', unsetenv_others: true)
    #   result.stdout.string #=> "Home: \n/Path: /bin\n"
    # @example Run command in a different directory
    #   command = ['pwd']
    #   result = ProcessExecuter.run(*command, chdir: '/tmp')
    #   result.stdout.string #=> "/tmp\n"
    # @example Capture stdout and stderr into a single buffer
    #   command = ['echo "stdout" && echo "stderr" 1>&2']
    #   result = ProcessExecuter.run(*command, merge: true)
    #   result.stdout.string #=> "stdout\nstderr\n"
    #   result.stdout.object_id == result.stderr.object_id #=> true
    # @example Capture to an explicit buffer
    #   out = StringIO.new
    #   err = StringIO.new
    #   command = ['echo "stdout" && echo "stderr" 1>&2']
    #   result = ProcessExecuter.run(*command, out: out, err: err)
    #   out.string #=> "stdout\n"
    #   err.string #=> "stderr\n"
    #   result.stdout.object_id == out.object_id #=> true
    #   result.stderr.object_id == err.object_id #=> true
    # @example Capture to a file
    #   # Same technique can be used for stderr
    #   out = File.open('stdout.txt', 'w')
    #   command = ['echo "stdout" && echo "stderr" 1>&2']
    #   result = ProcessExecuter.run(*command, out: out, err: err)
    #   out.close
    #   File.read('stdout.txt') #=> "stdout\n"
    #   # stderr is still captured to a StringIO buffer internally
    #   result.stderr.string #=> "stderr\n"
    # @example Run a command given as a single string (uses shell)
    #   # The command must be properly shell escaped when passed as a single string.
    #   command = 'echo "stdout: `pwd`"" && echo "stderr: $HOME" 1>&2'
    #   result = ProcessExecuter.run(command)
    #   result.success? #=> true
    #   result.stdout.string #=> "stdout: /Users/james/projects/main-branch/process_executer\n"
    #   result.stderr.string #=> "stderr: /Users/james\n"
    # @example Capture to multiple writers (e.g. files, buffers, STDOUT, etc.)
    #   # Same technique can be used for stderr
    #   out_buffer = StringIO.new
    #   out_file = File.open('stdout.txt', 'w')
    #   command = ['echo "stdout" && echo "stderr" 1>&2']
    #   result = ProcessExecuter.run(*command, out: [out_buffer, out_file])
    #   # You must manage closing resources you create yourself
    #   out_file.close
    #   out_buffer.string #=> "stdout\n"
    #   File.read('stdout.txt') #=> "stdout\n"
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @option options_hash
    # @param command [Array<String>] The command to run
    #
    #   If the first element of command is a Hash, it is added to the ENV of
    #   the new process. See [Execution Environment](https://ruby-doc.org/3.3.6/Process.html#module-Process-label-Execution+Environment)
    #   for more details. The env hash is then removed from the command array.
    #
    #   If the first and only (remaining) command element is a string, it is passed to
    #   a subshell if it begins with a shell reserved word, contains special built-ins,
    #   or includes shell metacharacters.
    #
    #   Care must be taken to properly escape shell metacharacters in the command string.
    #
    #   Otherwise, the command is run bypassing the shell. When bypassing the shell, shell expansions
    #   and redirections are not supported.
    # @param options_hash [Hash] Additional options
    # @param logger [Logger] The logger to use
    # @raise [ProcessExecuter::Command::ProcessIOError] if an exception was raised while collecting subprocess output
    # @raise [ProcessExecuter::Command::SignaledError] if the command exited because of an unhandled signal
    # @raise [ProcessExecuter::Command::FailedError] if the command returned a non-zero exit status
    # @raise [ProcessExecuter::Command::TimeoutError] if the command timed out
    # @return [ProcessExecuter::Command::Result] A result object containing the process status and captured output
    #
    # source://process_executer//lib/process_executer.rb#256
    def run(*command, logger: T.unsafe(nil), **options_hash); end

    # Execute the given command as a subprocess and return the exit status
    #
    # This is a convenience method that calls
    # [Process.spawn](https://docs.ruby-lang.org/en/3.3/Process.html#method-c-spawn)
    # and blocks until the command terminates.
    #
    # The command will be sent the SIGKILL signal if it does not terminate within
    # the specified timeout.
    #
    # @api public
    # @example
    #   status = ProcessExecuter.spawn('echo hello')
    #   status.exited? # => true
    #   status.success? # => true
    #   status.timeout? # => false
    # @example with a timeout
    #   status = ProcessExecuter.spawn('sleep 10', timeout: 0.01)
    #   status.exited? # => false
    #   status.success? # => nil
    #   status.signaled? # => true
    #   status.termsig # => 9
    #   status.timeout? # => true
    # @example capturing stdout to a string
    #   stdout = StringIO.new
    #   status = ProcessExecuter.spawn('echo hello', out: stdout)
    #   stdout.string # => "hello"
    # @param command [Array<String>] The command to execute
    # @param options_hash [Hash] The options to use when executing the command
    # @return [Process::Status] the exit status of the process
    # @see https://ruby-doc.org/core-3.1.2/Kernel.html#method-i-spawn Kernel.spawn
    #   documentation for valid command and options
    # @see ProcessExecuter::Options#initialize See ProcessExecuter::Options#initialize
    #   for options that may be specified
    #
    # source://process_executer//lib/process_executer.rb#67
    def spawn(*command, **options_hash); end

    private

    # Wait for process to terminate
    #
    # If a timeout is specified in options, terminate the process after options.timeout seconds.
    #
    # @api private
    # @api public
    # @param pid [Integer] the process ID
    # @param options [ProcessExecuter::Options] the options used
    # @return [ProcessExecuter::Status] the process status including Process::Status attributes and a timeout flag
    #
    # source://process_executer//lib/process_executer.rb#271
    def wait_for_process(pid, options); end
  end
end

# This module contains classes for implementing ProcessExecuter.run_command
#
# source://process_executer//lib/process_executer/command.rb#5
module ProcessExecuter::Command; end

# Raised when a command fails or exits because of an uncaught signal
#
# The command executed, status, stdout, and stderr are available from this
# object.
#
# The Gem will raise a more specific error for each type of failure:
#
# * {FailedError}: when the command exits with a non-zero status
# * {SignaledError}: when the command exits because of an uncaught signal
# * {TimeoutError}: when the command times out
#
# @api public
#
# source://process_executer//lib/process_executer/command/errors.rb#67
class ProcessExecuter::Command::CommandError < ::ProcessExecuter::Command::Error
  # Create a CommandError object
  #
  # @api public
  # @example
  #   `exit 1` # set $? appropriately for this example
  #   result = ProcessExecuter::Command::Result.new(%w[git status], $?, 'stdout', 'stderr')
  #   error = ProcessExecuter::Command::CommandError.new(result)
  #   error.to_s #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @param result [Result] The result of the command including the command,
  #   status, stdout, and stderr
  # @return [CommandError] a new instance of CommandError
  #
  # source://process_executer//lib/process_executer/command/errors.rb#79
  def initialize(result); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @return [String]
  #
  # source://process_executer//lib/process_executer/command/errors.rb#91
  def error_message; end

  # The result of the command including the command, its status and its output
  #
  # @api public
  # @example
  #   error.result #=> #<ProcessExecuter::Command::Result:0x00007f9b1b8b3d20>
  # @return [Result]
  #
  # source://process_executer//lib/process_executer/command/errors.rb#104
  def result; end
end

# Base class for all ProcessExecuter::Command errors
#
# It is recommended to rescue `ProcessExecuter::Command::Error` to catch any
# runtime error raised by this gem unless you need more specific error handling.
#
# Custom errors are arranged in the following class hierarchy:
#
# ```text
# ::StandardError
#   └─> Error
#       ├─> CommandError
#       │   ├─> FailedError
#       │   └─> SignaledError
#       │       └─> TimeoutError
#       └─> ProcessIOError
# ```
#
# | Error Class | Description |
# | --- | --- |
# | `Error` | This catch-all error serves as the base class for other custom errors. |
# | `CommandError` | A subclass of this error is raised when there is a problem executing a command. |
# | `FailedError` | Raised when the command exits with a non-zero status code. |
# | `SignaledError` | Raised when the command is terminated as a result of receiving a signal. This could happen if the process is forcibly terminated or if there is a serious system error. |
# | `TimeoutError` | This is a specific type of `SignaledError` that is raised when the command times out and is killed via the SIGKILL signal. Raised when the operation takes longer than the specified timeout duration (if provided). |
# | `ProcessIOError` | Raised when an error was encountered reading or writing to the command's subprocess. |
#
# @api public
# @example Rescuing any error
#   begin
#   ProcessExecuter.run_command('git', 'status')
#   rescue ProcessExecuter::Command::Error => e
#   puts "An error occurred: #{e.message}"
#   end
# @example Rescuing a timeout error
#   begin
#   timeout_duration = 0.1 # seconds
#   ProcessExecuter.run_command('sleep', '1', timeout: timeout_duration)
#   rescue ProcessExecuter::TimeoutError => e # Catch the more specific error first!
#   puts "Command took too long and timed out: #{e}"
#   rescue ProcessExecuter::Error => e
#   puts "Some other error occured: #{e}"
#   end
#
# source://process_executer//lib/process_executer/command/errors.rb#52
class ProcessExecuter::Command::Error < ::StandardError; end

# Raised when the command returns a non-zero exitstatus
#
# @api public
#
# source://process_executer//lib/process_executer/command/errors.rb#111
class ProcessExecuter::Command::FailedError < ::ProcessExecuter::Command::CommandError; end

# Raised when the output of a command can not be read
#
# @api public
#
# source://process_executer//lib/process_executer/command/errors.rb#166
class ProcessExecuter::Command::ProcessIOError < ::ProcessExecuter::Command::Error; end

# A wrapper around {ProcessExecuter::Status} which adds captured command output
#
# This class is used to represent the result of a subprocess execution, combining
# the process status with the captured output for easier access and manipulation.
#
# Features:
# * Provides access to the process's status, stdout, and stderr.
# * Allows conversion of stdout and stderr buffers to strings.
#
# @api public
# @example Create a Result object
#   status = ProcessExecuter.spawn(*command, timeout:, out:, err:)
#   result = ProcessExecuter::Command::Result.new(command, status, out_buffer.string, err_buffer.string)
#
# source://process_executer//lib/process_executer/command/result.rb#22
class ProcessExecuter::Command::Result < ::SimpleDelegator
  # Create a new Result object
  #
  # @api public
  # @example
  #   status = ProcessExecuter.spawn(*command, timeout:, out:, err:)
  #   Result.new(command, status, out_buffer.string, err_buffer.string)
  # @param command [Array<String>] The command that was executed
  # @param status [ProcessExecuter::Status] The status of the process
  # @param stdout [String] The stdout output from the process
  # @param stderr [String] The stderr output from the process
  # @return [Result] a new instance of Result
  #
  # source://process_executer//lib/process_executer/command/result.rb#31
  def initialize(command, status, stdout, stderr); end

  # The command that was run
  #
  # @api public
  # @example
  #   result.command #=> %w[git status]
  # @return [Array<String>]
  #
  # source://process_executer//lib/process_executer/command/result.rb#42
  def command; end

  # The captured stderr output from the process
  #
  # @api public
  # @example
  #   result.stderr #=> "ERROR: file not found"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/command/result.rb#54
  def stderr; end

  # Return the stderr output as a string
  #
  # @api public
  # @example When stderr is a StringIO containing "Hello World"
  #   result.stderr_to_s #=> "Hello World"
  # @example When stderr is a File object
  #   result.stderr_to_s #=> #<File:/tmp/output.txt>
  # @return [String, Object] Returns a String if stderr is a StringIO; otherwise, returns the stderr object
  #
  # source://process_executer//lib/process_executer/command/result.rb#72
  def stderr_to_s; end

  # The captured stdout output from the process
  #
  # @api public
  # @example
  #   result.stdout #=> "On branch master\nnothing to commit, working tree clean\n"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/command/result.rb#48
  def stdout; end

  # Return the stdout output as a string
  #
  # @api public
  # @example When stdout is a StringIO containing "Hello World"
  #   result.stdout_to_s #=> "Hello World"
  # @example When stdout is a File object
  #   result.stdout_to_s #=> #<File:/tmp/output.txt>
  # @return [String, Object] Returns a String if stdout is a StringIO; otherwise, returns the stdout object
  #
  # source://process_executer//lib/process_executer/command/result.rb#62
  def stdout_to_s; end
end

# The `Runner` class executes subprocess commands and captures their status and output.
#
# It does the following:
# - Run commands (`call`) with options for capturing output, handling timeouts, and merging stdout/stderr.
# - Process command results, including logging and error handling.
# - Raise detailed exceptions for common command failures, such as timeouts or subprocess errors.
#
# This class is used internally by {ProcessExecuter.run}.
#
# @api public
#
# source://process_executer//lib/process_executer/command/runner.rb#19
class ProcessExecuter::Command::Runner
  # Create a new RunCommand instance
  #
  # @api public
  # @example
  #   runner = Runner.new()
  #   status = runner.call('echo', 'hello')
  # @param logger [Logger] The logger to use. Defaults to a no-op logger if nil.
  # @return [Runner] a new instance of Runner
  #
  # source://process_executer//lib/process_executer/command/runner.rb#28
  def initialize(logger); end

  # Run a command and return the status including stdout and stderr output
  #
  # @api public
  # @example
  #   command = %w[git status]
  #   status = run(command)
  #   status.success? # => true
  #   status.exitstatus # => 0
  #   status.out # => "On branch master\nnothing to commit, working tree clean\n"
  #   status.err # => ""
  # @param out [#write] The object to which stdout is written
  # @param merge [Boolean] Write both stdout and stderr into the buffer for stdout
  # @param raise_errors [Boolean] Raise an exception if the command fails
  # @param options_hash [Hash] Additional options to pass to Process.spawn
  #
  #   See {ProcessExecuter.run} for a full list of options.
  # @param err [#write] The object to which stderr is written
  # @param command [Array<String>] The command to run
  # @return [ProcessExecuter::Command::Result] The status of the subprocess and captured stdout and stderr output
  #
  # source://process_executer//lib/process_executer/command/runner.rb#61
  def call(*command, out: T.unsafe(nil), err: T.unsafe(nil), merge: T.unsafe(nil), raise_errors: T.unsafe(nil), **options_hash); end

  # The logger to use
  #
  # @api public
  # @example
  #   runner.logger #=> #<Logger:0x00007f9b1b8b3d20>
  # @return [Logger]
  #
  # source://process_executer//lib/process_executer/command/runner.rb#36
  def logger; end

  private

  # Log the command and result of the subprocess
  #
  # @api private
  # @param result [ProcessExecuter::Command::Result] the result of the command including
  #   the command, status, stdout, and stderr
  # @return [void]
  #
  # source://process_executer//lib/process_executer/command/runner.rb#144
  def log_result(result); end

  # Process the result of the command and return a ProcessExecuter::Command::Result
  #
  # Log the command and result, and raise an error if the command failed.
  #
  # @api private
  # @param command [Array<String>] The git command that was executed
  # @param status [Process::Status] The status of the completed subprocess
  # @param out [#write] The object that stdout was written to
  # @param err [#write] The object that stderr was written to
  # @param timeout [Numeric, nil] The maximum seconds to wait for the command to complete
  # @param raise_errors [Boolean] Raise an exception if the command fails
  # @raise [ProcessExecuter::Command::FailedError] If the command failed
  # @raise [ProcessExecuter::Command::SignaledError] If the command was signaled
  # @raise [ProcessExecuter::Command::TimeoutError] If the command times out
  # @raise [ProcessExecuter::Command::ProcessIOError] If an exception was raised while collecting subprocess output
  # @return [ProcessExecuter::Command::Result] The status of the subprocess and captured stdout and stderr output
  #
  # source://process_executer//lib/process_executer/command/runner.rb#125
  def process_result(command, status, out, err, timeout, raise_errors); end

  # Raise an error when there was exception while collecting the subprocess output
  #
  # @api private
  # @param command [Array<String>] The command that was executed
  # @param pipe_name [Symbol] The name of the pipe that raised the exception
  # @param pipe [ProcessExecuter::MonitoredPipe] The pipe that raised the exception
  # @raise [ProcessExecuter::Command::ProcessIOError]
  # @return [void] This method always raises an error
  #
  # source://process_executer//lib/process_executer/command/runner.rb#161
  def raise_pipe_error(command, pipe_name, pipe); end

  # Wrap the output buffers in pipes and then execute the command
  #
  # @api private
  # @param command [Array<String>] The command to execute
  # @param out [#write] The object to which stdout is written
  # @param err [#write] The object to which stderr is written
  # @param options_hash [Hash] Additional options to pass to Process.spawn
  #
  #   See {ProcessExecuter.run} for a full list of options.
  # @raise [ProcessExecuter::Command::ProcessIOError] If an exception was raised while collecting subprocess output
  # @raise [ProcessExecuter::Command::TimeoutError] If the command times out
  # @return [ProcessExecuter::Status] The status of the completed subprocess
  #
  # source://process_executer//lib/process_executer/command/runner.rb#90
  def spawn(command, out:, err:, **options_hash); end
end

# Raised when the command exits because of an uncaught signal
#
# @api public
#
# source://process_executer//lib/process_executer/command/errors.rb#117
class ProcessExecuter::Command::SignaledError < ::ProcessExecuter::Command::CommandError; end

# Raised when the command takes longer than the configured timeout
#
# @api public
# @example
#   result.status.timeout? #=> true
#
# source://process_executer//lib/process_executer/command/errors.rb#126
class ProcessExecuter::Command::TimeoutError < ::ProcessExecuter::Command::SignaledError
  # Create a TimeoutError object
  #
  # @api public
  # @example
  #   command = %w[sleep 10]
  #   timeout_duration = 1
  #   status = ProcessExecuter.spawn(*command, timeout: timeout_duration)
  #   result = Result.new(command, status, 'stdout', 'err output')
  #   error = TimeoutError.new(result, timeout_duration)
  #   error.error_message
  #   #=> '["sleep", "10"], status: pid 70144 SIGKILL (signal 9), stderr: "err output", timed out after 1s'
  # @param result [Result] The result of the command including the git command,
  #   status, stdout, and stderr
  # @param timeout_duration [Numeric] The duration the subprocess was allowed
  #   to run before being terminated
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://process_executer//lib/process_executer/command/errors.rb#144
  def initialize(result, timeout_duration); end

  # The amount of time the subprocess was allowed to run before being killed
  #
  # @api public
  # @example
  #   `kill -9 $$` # set $? appropriately for this example
  #   result = Result.new(%w[git status], $?, '', "killed")
  #   error = TimeoutError.new(result, 10)
  #   error.timeout_duration #=> 10
  # @return [Numeric]
  #
  # source://process_executer//lib/process_executer/command/errors.rb#159
  def timeout_duration; end
end

# Stream data sent through a pipe to one or more writers
#
# When a new MonitoredPipe is created, a pipe is created (via IO.pipe) and
# a thread is created to read data written to the pipe.
#
# Data that is read from that pipe is written one or more writers passed to
# `#initialize`.
#
# If any of the writers raise an exception, the monitoring thread will exit, the
# pipe will be closed, and the exception will be saved in `#exception`.
#
# `#close` must be called to ensure that (1) the pipe is closed, (2) all data is
# read from the pipe and written to the writers, and (3) the monitoring thread is
# killed.
#
# @api public
# @example Collect pipe data into a string
#   pipe_data = StringIO.new
#   begin
#   pipe = MonitoredPipe.new(pipe_data)
#   pipe.write("Hello World")
#   ensure
#   pipe.close
#   end
#   pipe_data.string #=> "Hello World"
# @example Collect pipe data into a string AND a file
#   pipe_data_string = StringIO.new
#   pipe_data_file = File.open("pipe_data.txt", "w")
#   begin
#   pipe = MonitoredPipe.new(pipe_data_string, pipe_data_file)
#   pipe.write("Hello World")
#   ensure
#   pipe.close
#   end
#   pipe_data_string.string #=> "Hello World"
#   File.read("pipe_data.txt") #=> "Hello World"
#
# source://process_executer//lib/process_executer/monitored_pipe.rb#46
class ProcessExecuter::MonitoredPipe
  # Create a new monitored pipe
  #
  # Creates a IO.pipe and starts a monitoring thread to read data written to the pipe.
  #
  # @api public
  # @example
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  # @param writers [Array<#write>] as data is read from the pipe, it is written to these writers
  # @param chunk_size [Integer] the size of the chunks to read from the pipe
  # @return [MonitoredPipe] a new instance of MonitoredPipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#58
  def initialize(*writers, chunk_size: T.unsafe(nil)); end

  # The size of the chunks to read from the pipe
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.chunk_size #=> 1000
  # @return [Integer] the size of the chunks to read from the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#169
  def chunk_size; end

  # Set the state to `:closing` and wait for the state to be set to `:closed`
  #
  # The monitoring thread will see that the state has changed and will close the pipe.
  #
  # @api public
  # @example
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.state #=> :open
  #   pipe.write('Hello World')
  #   pipe.close
  #   pipe.state #=> :closed
  #   data_collector.string #=> "Hello World"
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#85
  def close; end

  # The exception raised by a writer
  #
  # If an exception is raised by a writer, it is stored here. Otherwise, it is `nil`.
  #
  # @api public
  # @example
  #   pipe.exception #=> nil
  # @return [Exception, nil] the exception raised by a writer or `nil` if no exception was raised
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#258
  def exception; end

  # The file descriptor for the write end of the pipe
  #
  # @api private
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.fileno == pipe.to_io.fileno #=> true
  # @return [Integer] the file descriptor for the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#129
  def fileno; end

  # The read end of the pipe
  #
  # @api public
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.pipe_reader #=> #<IO:fd 11>
  # @return [IO]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#214
  def pipe_reader; end

  # The write end of the pipe
  #
  # @api public
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.pipe_writer #=> #<IO:fd 12>
  # @return [IO] the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#225
  def pipe_writer; end

  # The state of the pipe
  #
  # Must be either `:open`, `:closing`, or `:closed`
  #
  # * `:open` - the pipe is open and data can be written to it
  # * `:closing` - the pipe is being closed and data can no longer be written to it
  # * `:closed` - the pipe is closed and data can no longer be written to it
  #
  # @api public
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.state #=> :open
  #   pipe.close
  #   pipe.state #=> :closed
  # @return [Symbol] the state of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#245
  def state; end

  # The thread that monitors the pipe
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.thread #=> #<Thread:0x00007f8b1a0b0e00>
  # @return [Thread]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#203
  def thread; end

  # Return the write end of the pipe so that data can be written to it
  #
  # Data written to this end of the pipe will be read by the monitor thread and
  # written to the writers passed to `#initialize`.
  #
  # This is so we can provide a MonitoredPipe to Process.spawn as a FD
  #
  # @api private
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.to_io.write('Hello World')
  #   pipe.close
  #   data_collector.string #=> "Hello World"
  # @return [IO] the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#111
  def to_io; end

  # Writes data to the pipe so that it can be read by the monitor thread
  #
  # Primarily used for testing.
  #
  # @api private
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.write('Hello World')
  #   pipe.close
  #   data_collector.string #=> "Hello World"
  # @param data [String] the data to write to the pipe
  # @raise [IOError]
  # @return [Integer] the number of bytes written to the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#151
  def write(data); end

  # An array of writers to write data that is read from the pipe
  #
  # @api public
  # @example with one writer
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.writers #=> [data_collector]
  # @example with an array of writers
  #   require 'stringio'
  #   data_collector1 = StringIO.new
  #   data_collector2 = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector1, data_collector2)
  #   pipe.writers #=> [data_collector1, data_collector2]]
  # @return [Array<#write>]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#190
  def writers; end

  private

  # Read any remaining data from the pipe and close it
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#338
  def close_pipe; end

  # Check if the writer is a file descriptor
  #
  # @api private
  # @param writer [#write] the writer to check
  # @return [Boolean] true if the writer is a file descriptor
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#294
  def file_descriptor?(writer); end

  # Read data from the pipe until `#state` is changed to `:closing`
  #
  # The state is changed to `:closed` by calling `#close`.
  #
  # Before this method returns, state is set to `:closed`
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#270
  def monitor; end

  # Read data from the pipe until `#state` is changed to `:closing`
  #
  # Data read from the pipe is written to the writers given to the constructor.
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#282
  def monitor_pipe; end

  # Write the data read from the pipe to all destinations
  #
  # If an exception is raised by a writer, set the state to `:closing`
  # so that the pipe can be closed.
  #
  # @api private
  # @param data [String] the data read from the pipe
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#304
  def write_data(data); end

  # Write data to the given file_descriptor correctly handling stdout and stderr
  #
  # @api private
  # @param file_descriptor [Integer, Symbol] the file descriptor to write to (either an integer or :out or :err)
  # @param data [String] the data to write
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#318
  def write_data_to_fd(file_descriptor, data); end
end

# Validate ProcessExecuter::Executer#spawn options and return Process.spawn options
#
# Valid options are those accepted by Process.spawn plus the following additions:
#
# * `:timeout`:
#
# @api public
#
# source://process_executer//lib/process_executer/options.rb#14
class ProcessExecuter::Options
  # Create a new Options object
  #
  # @api public
  # @example
  #   options = ProcessExecuter::Options.new(out: $stdout, err: $stderr, timeout: 10)
  # @option options
  # @param options [Hash] Process.spawn options plus additional options listed below.
  #
  #   See [Process.spawn](https://ruby-doc.org/core/Process.html#method-c-spawn)
  #   for a list of valid options that can be passed to `Process.spawn`.
  # @return [Options] a new instance of Options
  #
  # source://process_executer//lib/process_executer/options.rb#86
  def initialize(**options); end

  # source://process_executer//lib/process_executer/options.rb#66
  def chdir; end

  # source://process_executer//lib/process_executer/options.rb#66
  def close_others; end

  # source://process_executer//lib/process_executer/options.rb#66
  def err; end

  # source://process_executer//lib/process_executer/options.rb#66
  def in; end

  # source://process_executer//lib/process_executer/options.rb#66
  def new_pgroup; end

  # source://process_executer//lib/process_executer/options.rb#66
  def out; end

  # source://process_executer//lib/process_executer/options.rb#66
  def pgroup; end

  # source://process_executer//lib/process_executer/options.rb#66
  def rlimit_resourcename; end

  # Returns the options to be passed to Process.spawn
  #
  # @api public
  # @example
  #   options = ProcessExecuter::Options.new(out: $stdout, err: $stderr, timeout: 10)
  #   options.spawn_options # => { out: $stdout, err: $stderr }
  # @return [Hash]
  #
  # source://process_executer//lib/process_executer/options.rb#100
  def spawn_options; end

  # source://process_executer//lib/process_executer/options.rb#66
  def timeout; end

  # source://process_executer//lib/process_executer/options.rb#66
  def umask; end

  # source://process_executer//lib/process_executer/options.rb#66
  def unsetenv_others; end

  private

  # Determine if the options hash contains any unknown options
  #
  # @api private
  # @param options [Hash] the hash of options
  # @raise [ArgumentError] if the options hash contains any unknown options
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options.rb#128
  def assert_no_unknown_options(options); end

  # Raise an error if timeout is not a real non-negative number
  #
  # @api private
  # @raise [ArgumentError] if timeout is not a real non-negative number
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options.rb#137
  def assert_timeout_is_valid; end

  # Determine if the given option should be passed to `Process.spawn`
  #
  # @api private
  # @param option [Symbol, Integer, IO] the option to be tested
  # @param value [Object] the value of the option
  # @return [Boolean] true if the given option should be passed to `Process.spawn`
  #
  # source://process_executer//lib/process_executer/options.rb#164
  def include_spawn_option?(option, value); end

  # The message to be used when raising an error for an invalid timeout
  #
  # @api private
  # @return [String]
  #
  # source://process_executer//lib/process_executer/options.rb#147
  def invalid_timeout_message; end

  # Options with values
  #
  # All options have values. If an option is not given in the initializer, it
  # will have the value `NOT_SET`.
  #
  # @api private
  # @return [Hash<Symbol, Object>]
  #
  # source://process_executer//lib/process_executer/options.rb#121
  def options; end

  # Determine if the given option is a valid option
  #
  # @api private
  # @param option [Symbol] the option to be tested
  # @return [Boolean] true if the given option is a valid option
  #
  # source://process_executer//lib/process_executer/options.rb#155
  def valid_option?(option); end
end

# All options allowed by this class
#
# @api public
#
# source://process_executer//lib/process_executer/options.rb#60
ProcessExecuter::Options::ALL_OPTIONS = T.let(T.unsafe(nil), Array)

# The default values for all options
#
# @api public
# @return [Hash]
#
# source://process_executer//lib/process_executer/options.rb#42
ProcessExecuter::Options::DEFAULTS = T.let(T.unsafe(nil), Hash)

# These options are allowed by `ProcessExecuter.spawn` but should NOT be passed
# to `Process.spawn`
#
# @api public
#
# source://process_executer//lib/process_executer/options.rb#32
ProcessExecuter::Options::NON_SPAWN_OPTIONS = T.let(T.unsafe(nil), Array)

# Any `SPAWN_OPTIONS` set to `NOT_SET` will not be passed to `Process.spawn`
#
# @api public
#
# source://process_executer//lib/process_executer/options.rb#38
ProcessExecuter::Options::NOT_SET = T.let(T.unsafe(nil), Symbol)

# These options should be passed to `Process.spawn`
#
# Additionally, any options whose key is an Integer or an IO object will
# be passed to `Process.spawn`.
#
# @api public
#
# source://process_executer//lib/process_executer/options.rb#24
ProcessExecuter::Options::SPAWN_OPTIONS = T.let(T.unsafe(nil), Array)

# A simple delegator for Process::Status that adds a `timeout?` attribute
#
# @api public
#
# source://process_executer//lib/process_executer/status.rb#11
class ProcessExecuter::Status < ::SimpleDelegator
  extend ::Forwardable

  # Create a new Status object from a Process::Status and timeout flag
  #
  # @api public
  # @example
  #   status = Process.wait2(pid).last
  #   timeout = false
  #   ProcessExecuter::Status.new(status, timeout)
  # @param status [Process::Status] the status to delegate to
  # @param timeout [Boolean] true if the process timed out
  # @param timeout_duration [Numeric, nil] The secs the command ran before being killed OR o or nil for no timeout
  # @return [Status] a new instance of Status
  #
  # source://process_executer//lib/process_executer/status.rb#27
  def initialize(status, timeout, timeout_duration); end

  # Overrides the default success? method to return nil if the process timed out
  #
  # This is because when a timeout occurs, Windows will still return true
  #
  # @api public
  # @example
  #   status = ProcessExecuter.spawn('sleep 10', timeout: 0.01)
  #   status.success? # => nil
  # @return [Boolean, nil]
  #
  # source://process_executer//lib/process_executer/status.rb#56
  def success?; end

  # True if the process timed out and was sent the SIGKILL signal
  #
  # @api public
  # @example
  #   status = ProcessExecuter.spawn('sleep 10', timeout: 0.01)
  #   status.timeout? # => true
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/status.rb#46
  def timeout?; end

  # The secs the command ran before being killed OR o or nil for no timeout
  #
  # @api public
  # @example
  #   status.timeout_duration #=> 10
  # @return [Numeric, nil]
  #
  # source://process_executer//lib/process_executer/status.rb#37
  def timeout_duration; end

  # Return a string representation of the status
  #
  # @api public
  # @example
  #   status.to_s #=> "pid 70144 SIGKILL (signal 9) timed out after 10s"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/status.rb#66
  def to_s; end
end

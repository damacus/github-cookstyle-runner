# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `git` gem.
# Please instead update this file by running `bin/tapioca gem git`.


# The Git module provides the basic functions to open a git
# reference to work with. You can open a working directory,
# open a bare repository, initialize a new repo or clone an
# existing remote repository.
#
# @author Scott Chacon (mailto:schacon@gmail.com)
#
# source://git//lib/git.rb#6
module Git
  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # source://git//lib/git.rb#49
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  # source://git//lib/git.rb#71
  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git.rb#103
    def bare(git_dir, options = T.unsafe(nil)); end

    # Return the version of the git binary
    #
    # @example
    #   Git.binary_version # => [2, 46, 0]
    # @return [Array<Integer>] the version of the git binary
    #
    # source://git//lib/git.rb#394
    def binary_version(binary_path = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone a repository and set multiple config options
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: ['user.name=John Doe', 'user.email=john@doe.com']
    #   )
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone a repository and set a single config option
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: 'submodule.recurse=true'
    #   )
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git.rb#193
    def clone(repository_url, directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://git//lib/git.rb#67
    def config; end

    # @yield [Base.config]
    #
    # source://git//lib/git.rb#63
    def configure; end

    # Returns the name of the default branch of the given repository
    #
    # @example with a URI string
    #   Git.default_branch('https://github.com/ruby-git/ruby-git') # => 'master'
    #   Git.default_branch('https://github.com/rspec/rspec-core') # => 'main'
    # @example with a URI object
    #   repository_uri = URI('https://github.com/ruby-git/ruby-git')
    #   Git.default_branch(repository_uri) # => 'master'
    # @example with a local repository
    #   Git.default_branch('.') # => 'master'
    # @example with a local repository Pathname
    #   repository_path = Pathname('.')
    #   Git.default_branch(repository_path) # => 'master'
    # @example with the logging option
    #   logger = Logger.new(STDOUT, level: Logger::INFO)
    #   Git.default_branch('.', log: logger) # => 'master'
    #   I, [2022-04-13T16:01:33.221596 #18415]  INFO -- : git '-c' 'core.quotePath=true' '-c' 'color.ui=false' ls-remote '--symref' '--' '.' 'HEAD'  2>&1
    # @option options
    # @param repository [URI, Pathname, String] The (possibly remote) repository to get the default branch name for
    #
    #   See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [String] the name of the default branch
    #
    # source://git//lib/git.rb#235
    def default_branch(repository, options = T.unsafe(nil)); end

    # Export the current HEAD (or a branch, if <tt>options[:branch]</tt>
    # is specified) into the +name+ directory, then remove all traces of git from the
    # directory.
    #
    # See +clone+ for options.  Does not obey the <tt>:remote</tt> option,
    # since the .git info will be deleted anyway; always uses the default
    # remote, 'origin.'
    #
    # source://git//lib/git.rb#246
    def export(repository, name, options = T.unsafe(nil)); end

    # Same as g.config, but forces it to be at the global level
    #
    # g.config('user.name', 'Scott Chacon') # sets value
    # g.config('user.email', 'email@email.com')  # sets value
    # g.config('user.name')  # returns 'Scott Chacon'
    # g.config # returns whole config hash
    #
    # source://git//lib/git.rb#259
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git.rb#323
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # returns a Hash containing information about the references
    # of the target repository
    #
    # options
    #   :refs
    #
    # @param location [String|NilClass] the target repository location or nil for '.'
    # @return [{String=>Hash}] the available references of the target repo.
    #
    # source://git//lib/git.rb#335
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git.rb#383
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

# source://git//lib/git/author.rb#4
class Git::Author
  # @return [Author] a new instance of Author
  #
  # source://git//lib/git/author.rb#7
  def initialize(author_string); end

  # Returns the value of attribute date.
  #
  # source://git//lib/git/author.rb#5
  def date; end

  # Sets the attribute date
  #
  # @param value the value to set the attribute date to.
  #
  # source://git//lib/git/author.rb#5
  def date=(_arg0); end

  # Returns the value of attribute email.
  #
  # source://git//lib/git/author.rb#5
  def email; end

  # Sets the attribute email
  #
  # @param value the value to set the attribute email to.
  #
  # source://git//lib/git/author.rb#5
  def email=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/author.rb#5
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/author.rb#5
  def name=(_arg0); end
end

# The main public interface for interacting with Git commands
#
# Instead of creating a Git::Base directly, obtain a Git::Base instance by
# calling one of the follow {Git} class methods: {Git.open}, {Git.init},
# {Git.clone}, or {Git.bare}.
#
# @api public
#
# source://git//lib/git/base.rb#15
class Git::Base
  # Create an object that executes Git commands in the context of a working
  # copy or a bare repository.
  #
  # @api public
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options for this command (see list of valid
  #   options below)
  # @return [Git::Base] an object that can execute git commands in the context
  #   of the opened working copy or bare repository
  #
  # source://git//lib/git/base.rb#138
  def initialize(options = T.unsafe(nil)); end

  # Update the index from the current worktree to prepare the for the next commit
  #
  # @api public
  # @example
  #   lib.add('path/to/file')
  #   lib.add(['path/to/file1','path/to/file2'])
  #   lib.add(all: true)
  # @option options
  # @option options
  # @param paths [String, Array<String>] a file or files to be added to the repository (relative to the worktree root)
  # @param options [Hash]
  #
  # source://git//lib/git/base.rb#164
  def add(paths = T.unsafe(nil), **options); end

  # adds a new remote to this repository
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.add_remote('scotts_git', 'git://repo.or.cz/rubygit.git')
  #  @git.fetch('scotts_git')
  #  @git.merge('scotts_git/master')
  #
  # Options:
  #   :fetch => true
  #   :track => <branch_name>
  #
  # @api public
  #
  # source://git//lib/git/base.rb#178
  def add_remote(name, url, opts = T.unsafe(nil)); end

  # Create a new git tag
  #
  # @api public
  # @example
  #   repo.add_tag('tag_name', object_reference)
  #   repo.add_tag('tag_name', object_reference, {:options => 'here'})
  #   repo.add_tag('tag_name', {:options => 'here'})
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [String] The name of the tag to add
  # @param options [Hash] Opstions to pass to `git tag`.
  #   See [git-tag](https://git-scm.com/docs/git-tag) for more details.
  #
  # source://git//lib/git/base.rb#547
  def add_tag(name, *options); end

  # @api public
  #
  # source://git//lib/git/base.rb#571
  def apply(file); end

  # @api public
  #
  # source://git//lib/git/base.rb#577
  def apply_mail(file); end

  # creates an archive file of the given tree-ish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#558
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Branch] an object for branch_name
  #
  # source://git//lib/git/base.rb#696
  def branch(branch_name = T.unsafe(nil)); end

  # @api public
  # @return [Git::Branches] a collection of all the branches in the repository.
  #   Each branch is represented as a {Git::Branch}.
  #
  # source://git//lib/git/base.rb#702
  def branches; end

  # @api public
  #
  # source://git//lib/git/base.rb#679
  def cat_file(objectish); end

  # changes current working directory for a block
  # to the git working directory
  #
  # example
  #  @git.chdir do
  #    # write files
  #    @git.add
  #    @git.commit('message')
  #  end
  #
  # @api public
  #
  # source://git//lib/git/base.rb#216
  def chdir; end

  # checks out a branch as the new git working directory
  #
  # @api public
  #
  # source://git//lib/git/base.rb#425
  def checkout(*args, **options); end

  # checks out an old version of a file
  #
  # @api public
  #
  # source://git//lib/git/base.rb#430
  def checkout_file(version, file); end

  # @api public
  #
  # source://git//lib/git/base.rb#615
  def checkout_index(opts = T.unsafe(nil)); end

  # cleans the working directory
  #
  # options:
  #  :force
  #  :d
  #  :ff
  #
  # @api public
  #
  # source://git//lib/git/base.rb#371
  def clean(opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository
  #
  # options:
  #   :all
  #   :allow_empty
  #   :amend
  #   :author
  #
  # @api public
  #
  # source://git//lib/git/base.rb#412
  def commit(message, opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository,
  # but automatically adds all modified files without having to explicitly
  # calling @git.add() on them.
  #
  # @api public
  #
  # source://git//lib/git/base.rb#419
  def commit_all(message, opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object::Commit] a commit object
  #
  # source://git//lib/git/base.rb#718
  def commit_tree(tree = T.unsafe(nil), opts = T.unsafe(nil)); end

  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.email', 'email@email.com', file: 'path/to/custom/config)  # sets value in file
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # @api public
  #
  # source://git//lib/git/base.rb#227
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end

  # The name of the branch HEAD refers to or 'HEAD' if detached
  #
  # Returns one of the following:
  #   * The branch name that HEAD refers to (even if it is an unborn branch)
  #   * 'HEAD' if in a detached HEAD state
  #
  # @api public
  # @return [String] the name of the branch HEAD refers to or 'HEAD' if detached
  #
  # source://git//lib/git/base.rb#691
  def current_branch; end

  # deletes a tag
  #
  # @api public
  #
  # source://git//lib/git/base.rb#553
  def delete_tag(name); end

  # returns the most recent tag that is reachable from a commit
  #
  # options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :match
  #
  # @api public
  #
  # source://git//lib/git/base.rb#390
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Diff] a Git::Diff object
  #
  # source://git//lib/git/base.rb#723
  def diff(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # returns a reference to the working directory
  #  @git.dir.path
  #  @git.dir.writeable?
  #
  # @api public
  #
  # source://git//lib/git/base.rb#243
  def dir; end

  # iterates over the files which are unmerged
  #
  # @api public
  #
  # source://git//lib/git/base.rb#474
  def each_conflict(&block); end

  # fetches changes from a remote branch - this does not modify the working directory,
  # it just gets the changes from the remote if there are any
  #
  # @api public
  #
  # source://git//lib/git/base.rb#436
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#728
  def gblob(objectish); end

  # @api public
  #
  # source://git//lib/git/base.rb#567
  def gc; end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#733
  def gcommit(objectish); end

  # Run a grep for 'string' on the HEAD of the git repository
  #
  # @api public
  # @example Using grep results:
  #   git.grep("TODO").each do |sha, arr|
  #   puts "in blob #{sha}:"
  #   arr.each do |line_no, match_string|
  #   puts "\t line #{line_no}: '#{match_string}'"
  #   end
  #   end
  # @example Limit grep's scope by calling grep() from a specific object:
  #   git.object("v2.3").grep('TODO')
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param string [String] the string to search for
  # @param path_limiter [String, Array] a path or array of paths to limit the search to or nil for no limit
  # @param opts [Hash] options to pass to the underlying `git grep` command
  # @return [Hash<String, Array>] a hash of arrays
  #   ```Ruby
  #   {
  #   'tree-ish1' => [[line_no1, match_string1], ...],
  #   'tree-ish2' => [[line_no1, match_string1], ...],
  #   ...
  #   }
  #   ```
  #
  # source://git//lib/git/base.rb#335
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#738
  def gtree(objectish); end

  # List the files in the worktree that are ignored by git
  #
  # @api public
  # @return [Array<String>] the list of ignored files relative to teh root of the worktree
  #
  # source://git//lib/git/base.rb#342
  def ignored_files; end

  # returns reference to the git index file
  #
  # @api public
  #
  # source://git//lib/git/base.rb#248
  def index; end

  # returns +true+ if the branch exists
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#292
  def is_branch?(branch); end

  # returns +true+ if the branch exists locally
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#280
  def is_local_branch?(branch); end

  # returns +true+ if the branch exists remotely
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#286
  def is_remote_branch?(branch); end

  # this is a convenience method for accessing the class that wraps all the
  # actual 'git' forked system calls.  At some point I hope to replace the Git::Lib
  # class with one that uses native methods or libgit C bindings
  #
  # @api public
  #
  # source://git//lib/git/base.rb#300
  def lib; end

  # @api public
  # @return [Git::Log] a log with the specified number of commits
  #
  # source://git//lib/git/base.rb#743
  def log(count = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#637
  def ls_files(location = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#675
  def ls_tree(objectish, opts = T.unsafe(nil)); end

  # merges one or more branches into the current working branch
  #
  # you can specify more than one branch to merge by passing an array of branches
  #
  # @api public
  #
  # source://git//lib/git/base.rb#469
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Find as good common ancestors as possible for a merge
  # example: g.merge_base('master', 'some_branch', 'some_sha', octopus: true)
  #
  # @api public
  # @return [Array<Git::Object::Commit>] a collection of common ancestors
  #
  # source://git//lib/git/base.rb#780
  def merge_base(*args); end

  # returns a Git::Object of the appropriate type
  # you can also call @git.gtree('tree'), but that's
  # just for readability.  If you call @git.gtree('HEAD') it will
  # still return a Git::Object::Commit object.
  #
  # object calls a method that will run a rev-parse
  # on the objectish and determine the type of the object and return
  # an appropriate object for that type
  #
  # @api public
  # @return [Git::Object] an instance of the appropriate type of Git::Object
  #
  # source://git//lib/git/base.rb#757
  def object(objectish); end

  # Pulls the given branch from the given remote into the current branch
  #
  # @api public
  # @example pulls from origin/master
  #   @git.pull
  # @example pulls from upstream/master
  #   @git.pull('upstream')
  # @example pulls from upstream/develop
  #   @git.pull('upstream', 'develop')
  # @option opts
  # @param remote [String] the remote repository to pull from
  # @param branch [String] the branch to pull from
  # @param opts [Hash] options to pass to the pull command
  # @raise [Git::FailedError] if the pull fails
  # @raise [ArgumentError] if a branch is given without a remote
  # @return [Void]
  #
  # source://git//lib/git/base.rb#497
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Push changes to a remote repository
  #
  # @api public
  # @overload push
  #
  # source://git//lib/git/base.rb#462
  def push(*args, **options); end

  # @api public
  #
  # source://git//lib/git/base.rb#619
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Remote] a remote of the specified name
  #
  # source://git//lib/git/base.rb#762
  def remote(remote_name = T.unsafe(nil)); end

  # returns an array of Git:Remote objects
  #
  # @api public
  #
  # source://git//lib/git/base.rb#502
  def remotes; end

  # removes file(s) from the git repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#347
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # removes a remote from this repository
  #
  # @git.remove_remote('scott_git')
  #
  # @api public
  #
  # source://git//lib/git/base.rb#520
  def remove_remote(name); end

  # repacks the repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#563
  def repack; end

  # returns reference to the git repository directory
  #  @git.dir.path
  #
  # @api public
  #
  # source://git//lib/git/base.rb#254
  def repo; end

  # returns the repository size in bytes
  #
  # @api public
  #
  # source://git//lib/git/base.rb#259
  def repo_size; end

  # resets the working directory to the provided commitish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#354
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # resets the working directory to the commitish with '--hard'
  #
  # @api public
  #
  # source://git//lib/git/base.rb#359
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  #
  # @api public
  # @example
  #   git.rev_parse("HEAD^^")
  #   git.rev_parse('v2.4^{tree}')
  #   git.rev_parse('v2.4:/doc/index.html')
  #
  # source://git//lib/git/base.rb#668
  def rev_parse(objectish); end

  # reverts the working directory to the provided commitish.
  # Accepts a range, such as comittish..HEAD
  #
  # options:
  #   :no_edit
  #
  # @api public
  #
  # source://git//lib/git/base.rb#400
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  # For backwards compatibility
  #
  # @api public
  # @example
  #   git.rev_parse("HEAD^^")
  #   git.rev_parse('v2.4^{tree}')
  #   git.rev_parse('v2.4:/doc/index.html')
  #
  # source://git//lib/git/base.rb#668
  def revparse(objectish); end

  # removes file(s) from the git repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#347
  def rm(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#269
  def set_index(index_file, check = T.unsafe(nil)); end

  # sets the url for a remote
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.set_remote_url('scotts_git', 'git://repo.or.cz/rubygit.git')
  #
  # @api public
  #
  # source://git//lib/git/base.rb#511
  def set_remote_url(name, url); end

  # @api public
  #
  # source://git//lib/git/base.rb#274
  def set_working(work_dir, check = T.unsafe(nil)); end

  # Shows objects
  #
  # @api public
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/base.rb#586
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # @api public
  # @return [Git::Status] a status object
  #
  # source://git//lib/git/base.rb#767
  def status; end

  # @api public
  # @return [Git::Object::Tag] a tag object
  #
  # source://git//lib/git/base.rb#772
  def tag(tag_name); end

  # returns an array of all Git::Tag objects for this repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#525
  def tags; end

  # @api public
  #
  # source://git//lib/git/base.rb#632
  def update_ref(branch, commit); end

  # LOWER LEVEL INDEX OPERATIONS ##
  #
  # @api public
  #
  # source://git//lib/git/base.rb#592
  def with_index(new_index); end

  # @api public
  #
  # source://git//lib/git/base.rb#600
  def with_temp_index(&blk); end

  # @api public
  #
  # source://git//lib/git/base.rb#652
  def with_temp_working(&blk); end

  # :yields: the Git::WorkingDirectory
  #
  # @api public
  #
  # source://git//lib/git/base.rb#641
  def with_working(work_dir); end

  # returns a Git::Worktree object for dir, commitish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#707
  def worktree(dir, commitish = T.unsafe(nil)); end

  # returns a Git::worktrees object of all the Git::Worktrees
  # objects for this repo
  #
  # @api public
  #
  # source://git//lib/git/base.rb#713
  def worktrees; end

  # @api public
  #
  # source://git//lib/git/base.rb#627
  def write_and_commit_tree(opts = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#623
  def write_tree; end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git/base.rb#17
    def bare(git_dir, options = T.unsafe(nil)); end

    # @api public
    #
    # source://git//lib/git/base.rb#41
    def binary_version(binary_path); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone a repository and set multiple config options
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: ['user.name=John Doe', 'user.email=john@doe.com']
    #   )
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone a repository and set a single config option
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: 'submodule.recurse=true'
    #   )
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git/base.rb#23
    def clone(repository_url, directory, options = T.unsafe(nil)); end

    # Returns (and initialize if needed) a Git::Config instance
    #
    # @api public
    # @return [Git::Config] the current config instance.
    #
    # source://git//lib/git/base.rb#37
    def config; end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git/base.rb#62
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git/base.rb#106
    def open(working_dir, options = T.unsafe(nil)); end

    # Returns the name of the default branch of the given repository
    #
    # @example with a URI string
    #   Git.default_branch('https://github.com/ruby-git/ruby-git') # => 'master'
    #   Git.default_branch('https://github.com/rspec/rspec-core') # => 'main'
    # @example with a URI object
    #   repository_uri = URI('https://github.com/ruby-git/ruby-git')
    #   Git.default_branch(repository_uri) # => 'master'
    # @example with a local repository
    #   Git.default_branch('.') # => 'master'
    # @example with a local repository Pathname
    #   repository_path = Pathname('.')
    #   Git.default_branch(repository_path) # => 'master'
    # @example with the logging option
    #   logger = Logger.new(STDOUT, level: Logger::INFO)
    #   Git.default_branch('.', log: logger) # => 'master'
    #   I, [2022-04-13T16:01:33.221596 #18415]  INFO -- : git '-c' 'core.quotePath=true' '-c' 'color.ui=false' ls-remote '--symref' '--' '.' 'HEAD'  2>&1
    # @option options
    # @param repository [URI, Pathname, String] The (possibly remote) repository to get the default branch name for
    #
    #   See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [String] the name of the default branch
    #
    # source://git//lib/git/base.rb#30
    def repository_default_branch(repository, options = T.unsafe(nil)); end

    # @api public
    # @raise [ArgumentError]
    #
    # source://git//lib/git/base.rb#88
    def root_of_worktree(working_dir); end

    private

    # Normalize options[:index]
    #
    # If options[:index] is a relative directory, convert it to an absolute
    # directory relative to the repository directory
    #
    # @api public
    #
    # source://git//lib/git/base.rb#869
    def normalize_index(options); end

    # Normalize options before they are sent to Git::Base.new
    #
    # Updates the options parameter by setting appropriate values for the following keys:
    #   * options[:working_directory]
    #   * options[:repository]
    #   * options[:index]
    #
    # All three values will be set to absolute paths. An exception is that
    # :working_directory will be set to nil if bare is true.
    #
    # @api public
    #
    # source://git//lib/git/base.rb#797
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end

    # Normalize options[:repository]
    #
    # If working with a bare repository, set to the first non-nil value out of:
    #   1. `options[:repository]`
    #   2. the `default` parameter
    #   3. the current working directory
    #
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:repository]`
    #   2. `.git`
    #
    # Next, if options[:repository] refers to a *file* and not a *directory*, set
    # options[:repository] to the contents of that file.  This is the case when
    # working with a submodule or a secondary working tree (created with git worktree
    # add). In these cases the repository is actually contained/nested within the
    # parent's repository directory.
    #
    # Finally, if options[:repository] is a relative path, convert it to an absolute
    # path relative to:
    #   1. the current directory if working with a bare repository or
    #   2. the working directory if NOT working with a bare repository
    #
    # @api public
    #
    # source://git//lib/git/base.rb#849
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end

    # Normalize options[:working_directory]
    #
    # If working with a bare repository, set to `nil`.
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:working_directory]`,
    #   2. the `default` parameter, or
    #   3. the current working directory
    #
    # Finally, if options[:working_directory] is a relative path, convert it to an absoluite
    # path relative to the current directory.
    #
    # @api public
    #
    # source://git//lib/git/base.rb#816
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end
  end
end

# source://git//lib/git/branch.rb#6
class Git::Branch < ::Git::Path
  # @return [Branch] a new instance of Branch
  #
  # source://git//lib/git/branch.rb#9
  def initialize(base, name); end

  # source://git//lib/git/branch.rb#31
  def archive(file, opts = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#26
  def checkout; end

  # @return [Boolean]
  #
  # source://git//lib/git/branch.rb#63
  def contains?(commit); end

  # source://git//lib/git/branch.rb#51
  def create; end

  # source://git//lib/git/branch.rb#59
  def current; end

  # source://git//lib/git/branch.rb#55
  def delete; end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/branch.rb#7
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/branch.rb#7
  def full=(_arg0); end

  # source://git//lib/git/branch.rb#17
  def gcommit; end

  # g.branch('new_branch').in_branch do
  #   # create new file
  #   # do other stuff
  #   return true # auto commits and switches back
  # end
  #
  # source://git//lib/git/branch.rb#40
  def in_branch(message = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#67
  def merge(branch = T.unsafe(nil), message = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/branch.rb#7
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/branch.rb#7
  def name=(_arg0); end

  # Returns the value of attribute remote.
  #
  # source://git//lib/git/branch.rb#7
  def remote; end

  # Sets the attribute remote
  #
  # @param value the value to set the attribute remote to.
  #
  # source://git//lib/git/branch.rb#7
  def remote=(_arg0); end

  # source://git//lib/git/branch.rb#22
  def stashes; end

  # source://git//lib/git/branch.rb#88
  def to_a; end

  # source://git//lib/git/branch.rb#92
  def to_s; end

  # source://git//lib/git/branch.rb#80
  def update_ref(commit); end

  private

  # source://git//lib/git/branch.rb#98
  def check_if_create; end

  # source://git//lib/git/branch.rb#102
  def determine_current; end

  # Given a full branch name return an Array containing the remote and branch names.
  #
  # Removes 'remotes' from the beggining of the name (if present).
  # Takes the second part (splittign by '/') as the remote name.
  # Takes the rest as the repo name (can also hold one or more '/').
  #
  # Example:
  #   # local branches
  #   parse_name('master') #=> [nil, 'master']
  #   parse_name('origin/master') #=> [nil, 'origin/master']
  #   parse_name('origin/master/v2') #=> [nil, 'origin/master']
  #
  #   # remote branches
  #   parse_name('remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('remotes/origin/master/v2') #=> ['origin', 'master/v2']
  #   parse_name('refs/remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('refs/remotes/origin/master/v2') #=> ['origin', 'master/v2']
  #
  # param [String] name branch full name.
  # return [<Git::Remote,NilClass,String>] an Array containing the remote and branch names.
  #
  # source://git//lib/git/branch.rb#137
  def parse_name(name); end
end

# source://git//lib/git/branch.rb#106
Git::Branch::BRANCH_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

# object that holds all the available branches
#
# source://git//lib/git/branches.rb#6
class Git::Branches
  include ::Enumerable

  # @return [Branches] a new instance of Branches
  #
  # source://git//lib/git/branches.rb#10
  def initialize(base); end

  # Returns the target branch
  #
  # Example:
  #   Given (git branch -a):
  #    master
  #    remotes/working/master
  #
  #   g.branches['master'].full #=> 'master'
  #   g.branches['working/master'].full => 'remotes/working/master'
  #   g.branches['remotes/working/master'].full => 'remotes/working/master'
  #
  # @param branch_name [#to_s] the target branch name.
  # @return [Git::Branch] the target branch.
  #
  # source://git//lib/git/branches.rb#51
  def [](branch_name); end

  # source://git//lib/git/branches.rb#34
  def each(&block); end

  # source://git//lib/git/branches.rb#20
  def local; end

  # source://git//lib/git/branches.rb#24
  def remote; end

  # array like methods
  #
  # source://git//lib/git/branches.rb#30
  def size; end

  # source://git//lib/git/branches.rb#63
  def to_s; end
end

# Runs a git command and returns the result
#
# @api public
#
# source://git//lib/git/command_line.rb#13
class Git::CommandLine
  # Create a Git::CommandLine object
  #
  # @api public
  # @example
  #   env = { 'GIT_DIR' => '/path/to/git/dir' }
  #   binary_path = '/usr/bin/git'
  #   global_opts = %w[--git-dir /path/to/git/dir]
  #   logger = Logger.new(STDOUT)
  #   cli = CommandLine.new(env, binary_path, global_opts, logger)
  #   cli.run('version') #=> #<Git::CommandLineResult:0x00007f9b0c0b0e00
  # @param env [Hash<String, String>] environment variables to set
  # @param global_opts [Array<String>] global options to pass to git
  # @param logger [Logger] the logger to use
  # @return [CommandLine] a new instance of CommandLine
  #
  # source://git//lib/git/command_line.rb#28
  def initialize(env, binary_path, global_opts, logger); end

  # The path to the command line binary to run
  #
  # @api public
  # @example
  #   binary_path = '/usr/bin/git'
  #   command_line = Git::CommandLine.new({}, binary_path, ['version'], Logger.new(STDOUT))
  #   command_line.binary_path #=> '/usr/bin/git'
  # @return [String]
  #
  # source://git//lib/git/command_line.rb#62
  def binary_path; end

  # Variables to set (or unset) in the git command's environment
  #
  # @api public
  # @example
  #   env = { 'GIT_DIR' => '/path/to/git/dir' }
  #   command_line = Git::CommandLine.new(env, '/usr/bin/git', [], Logger.new(STDOUT))
  #   command_line.env #=> { 'GIT_DIR' => '/path/to/git/dir' }
  # @return [Hash<String, String>]
  # @see https://ruby-doc.org/3.2.1/Process.html#method-c-spawn Process.spawn
  #   for details on how to set environment variables using the `env` parameter
  #
  # source://git//lib/git/command_line.rb#49
  def env; end

  # The global options to pass to git
  #
  # These are options that are passed to git before the command name and
  # arguments. For example, in `git --git-dir /path/to/git/dir version`, the
  # global options are %w[--git-dir /path/to/git/dir].
  #
  # @api public
  # @example
  #   env = {}
  #   global_opts = %w[--git-dir /path/to/git/dir]
  #   logger = Logger.new(nil)
  #   cli = CommandLine.new(env, '/usr/bin/git', global_opts, logger)
  #   cli.global_opts #=> %w[--git-dir /path/to/git/dir]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line.rb#81
  def global_opts; end

  # The logger to use for logging git commands and results
  #
  # @api public
  # @example
  #   env = {}
  #   global_opts = %w[]
  #   logger = Logger.new(STDOUT)
  #   cli = CommandLine.new(env, '/usr/bin/git', global_opts, logger)
  #   cli.logger == logger #=> true
  # @return [Logger]
  #
  # source://git//lib/git/command_line.rb#96
  def logger; end

  # Execute a git command, wait for it to finish, and return the result
  #
  # NORMALIZATION
  #
  # The command output is returned as a Unicde string containing the binary output
  # from the command. If the binary output is not valid UTF-8, the output will
  # cause problems because the encoding will be invalid.
  #
  # Normalization is a process that trys to convert the binary output to a valid
  # UTF-8 string. It uses the `rchardet` gem to detect the encoding of the binary
  # output and then converts it to UTF-8.
  #
  # Normalization is not enabled by default. Pass `normalize: true` to Git::CommandLine#run
  # to enable it. Normalization will only be performed on stdout and only if the `out:`` option
  # is nil or is a StringIO object. If the out: option is set to a file or other IO object,
  # the normalize option will be ignored.
  #
  # @api public
  # @example The args array should be splatted into the parameter list
  #   args = %w[log -n 1 --oneline]
  #   cli.run(*args) #=> "f5baa11 beginning of Ruby/Git project\n"
  # @example Run a command and return the chomped output
  #   cli.run('version', chomp: true) #=> "git version 2.39.1"
  # @example Run a command and without normalizing the output
  #   cli.run('version', normalize: false) #=> "git version 2.39.1\n"
  # @example Capture stdout in a temporary file
  #   require 'tempfile'
  #   tempfile = Tempfile.create('git') do |file|
  #   cli.run('version', out: file)
  #   file.rewind
  #   file.read #=> "git version 2.39.1\n"
  #   end
  # @example Capture stderr in a StringIO object
  #   require 'stringio'
  #   stderr = StringIO.new
  #   begin
  #   cli.run('log', 'nonexistent-branch', err: stderr)
  #   rescue Git::FailedError => e
  #   stderr.string #=> "unknown revision or path not in the working tree.\n"
  #   end
  # @example Run a command and return the output
  #   cli.run('version') #=> "git version 2.39.1\n"
  # @param timeout [Numeric, nil] the maximum seconds to wait for the command to complete
  #
  #   If timeout is zero, the timeout will not be enforced.
  #
  #   If the command times out, it is killed via a `SIGKILL` signal and `Git::TimeoutError` is raised.
  #
  #   If the command does not respond to SIGKILL, it will hang this method.
  # @param normalize [Boolean] whether to normalize the output to a valid encoding
  # @param args [Array<String>] the command line arguements to pass to git
  #
  #   This array should be splatted into the parameter list.
  # @param out [#write, nil] the object to write stdout to or nil to ignore stdout
  #
  #   If this is a 'StringIO' object, then `stdout_writer.string` will be returned.
  #
  #   In general, only specify a `stdout_writer` object when you want to redirect
  #   stdout to a file or some other object that responds to `#write`. The default
  #   behavior will return the output of the command.
  # @param err [#write] the object to write stderr to or nil to ignore stderr
  #
  #   If this is a 'StringIO' object and `merged_output` is `true`, then
  #   `stderr_writer.string` will be merged into the output returned by this method.
  # @param chomp [Boolean] whether to chomp the output
  # @param merge [Boolean] whether to merge stdout and stderr in the string returned
  # @param chdir [String] the directory to run the command in
  # @raise [ArgumentError] if `args` is not an array of strings
  # @raise [Git::SignaledError] if the command was terminated because of an uncaught signal
  # @raise [Git::FailedError] if the command returned a non-zero exitstatus
  # @raise [Git::ProcessIOError] if an exception was raised while collecting subprocess output
  # @raise [Git::TimeoutError] if the command times out
  # @return [Git::CommandLineResult] the output of the command
  #
  #   This result of running the command.
  #
  # source://git//lib/git/command_line.rb#192
  def run(*args, normalize:, chomp:, merge:, out: T.unsafe(nil), err: T.unsafe(nil), chdir: T.unsafe(nil), timeout: T.unsafe(nil)); end

  private

  # Build the git command line from the available sources to send to `Process.spawn`
  #
  # @api private
  # @raise [ArgumentError]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line.rb#208
  def build_git_cmd(args); end

  # Determine the output to return in the `CommandLineResult`
  #
  # If the writer can return the output by calling `#string` (such as a StringIO),
  # then return the result of normalizing the encoding and chomping the output
  # as requested.
  #
  # If the writer does not support `#string`, then return nil. The output is
  # assumed to be collected by the writer itself such as when the  writer
  # is a file instead of a StringIO.
  #
  # @api private
  # @param raw_output [#string] the output to post-process
  # @return [String, nil]
  #
  # source://git//lib/git/command_line.rb#276
  def post_process(raw_output, normalize, chomp); end

  # Post-process command output and return an array of the results
  #
  # @api private
  # @param raw_outputs [Array] the output to post-process
  # @param normalize [Boolean] whether to normalize the output of each writer
  # @param chomp [Boolean] whether to chomp the output of each writer
  # @return [Array<String, nil>] the processed output of each command output object that supports `#string`
  #
  # source://git//lib/git/command_line.rb#255
  def post_process_all(raw_outputs, normalize, chomp); end

  # Process the result of the command and return a Git::CommandLineResult
  #
  # Post process output, log the command and result, and raise an error if the
  # command failed.
  #
  # @api private
  # @param result [ProcessExecuter::Command::Result] the result it is a Process::Status and include command, stdout, and stderr
  # @param normalize [Boolean] whether to normalize the output of each writer
  # @param chomp [Boolean] whether to chomp the output of each writer
  # @param timeout [Numeric, nil] the maximum seconds to wait for the command to complete
  # @raise [Git::FailedError] if the command failed
  # @raise [Git::SignaledError] if the command was signaled
  # @raise [Git::TimeoutError] if the command times out
  # @raise [Git::ProcessIOError] if an exception was raised while collecting subprocess output
  # @return [Git::CommandLineResult] the result of the command to return to the caller
  #
  # source://git//lib/git/command_line.rb#233
  def process_result(result, normalize, chomp, timeout); end
end

# Raised when a git command fails or exits because of an uncaught signal
#
# The git command executed, status, stdout, and stderr are available from this
# object.
#
# The Gem will raise a more specific error for each type of failure:
#
# * {Git::FailedError}: when the git command exits with a non-zero status
# * {Git::SignaledError}: when the git command exits because of an uncaught signal
# * {Git::TimeoutError}: when the git command times out
#
# @api public
#
# source://git//lib/git/errors.rb#85
class Git::CommandLineError < ::Git::Error
  # Create a CommandLineError object
  #
  # @api public
  # @example
  #   `exit 1` # set $? appropriately for this example
  #   result = Git::CommandLineResult.new(%w[git status], $?, 'stdout', 'stderr')
  #   error = Git::CommandLineError.new(result)
  #   error.to_s #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @param result [Git::CommandLineResult] the result of the git command including
  #   the git command, status, stdout, and stderr
  # @return [CommandLineError] a new instance of CommandLineError
  #
  # source://git//lib/git/errors.rb#97
  def initialize(result); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @return [String]
  #
  # source://git//lib/git/errors.rb#109
  def error_message; end

  # The result of the git command including the git command and its status and output
  #
  # @api public
  # @example
  #   error.result #=> #<Git::CommandLineResult:0x00000001046bd488 ...>
  # @return [Git::CommandLineResult]
  #
  # source://git//lib/git/errors.rb#122
  def result; end
end

# The result of running a git command
#
# This object stores the Git command executed and its status, stdout, and stderr.
#
# @api public
#
# source://git//lib/git/command_line_result.rb#10
class Git::CommandLineResult
  # Create a CommandLineResult object
  #
  # @api public
  # @example
  #   `true`
  #   git_cmd = %w[git version]
  #   status = $?
  #   stdout = "git version 2.39.1\n"
  #   stderr = ""
  #   result = Git::CommandLineResult.new(git_cmd, status, stdout, stderr)
  # @param git_cmd [Array<String>] the git command that was executed
  # @param status [Process::Status] the status of the process
  # @param stdout [String] the output of the process
  # @param stderr [String] the error output of the process
  # @return [CommandLineResult] a new instance of CommandLineResult
  #
  # source://git//lib/git/command_line_result.rb#26
  def initialize(git_cmd, status, stdout, stderr); end

  # The git command that was executed
  #
  # @api public
  # @example
  #   git_cmd = %w[git version]
  #   result = Git::CommandLineResult.new(git_cmd, $?, "", "")
  #   result.git_cmd #=> ["git", "version"]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line_result.rb#44
  def git_cmd; end

  # The status of the process
  #
  # @api public
  # @example
  #   `true`
  #   status = $?
  #   result = Git::CommandLineResult.new(status, "", "")
  #   result.status #=> #<Process::Status: pid 87859 exit 0>
  # @return [Process::Status]
  #
  # source://git//lib/git/command_line_result.rb#58
  def status; end

  # The error output of the process
  #
  # @api public
  # @example
  #   stderr = "Tag not found\n"
  #   result = Git::CommandLineResult.new($?, "", stderr)
  #   result.stderr #=> "Tag not found\n"
  # @return [String]
  #
  # source://git//lib/git/command_line_result.rb#84
  def stderr; end

  # The output of the process
  #
  # @api public
  # @example
  #   stdout = "git version 2.39.1\n"
  #   result = Git::CommandLineResult.new($?, stdout, "")
  #   result.stdout #=> "git version 2.39.1\n"
  # @return [String]
  #
  # source://git//lib/git/command_line_result.rb#71
  def stdout; end
end

# source://git//lib/git/config.rb#5
class Git::Config
  # @return [Config] a new instance of Config
  #
  # source://git//lib/git/config.rb#9
  def initialize; end

  # source://git//lib/git/config.rb#15
  def binary_path; end

  # Sets the attribute binary_path
  #
  # @param value the value to set the attribute binary_path to.
  #
  # source://git//lib/git/config.rb#7
  def binary_path=(_arg0); end

  # source://git//lib/git/config.rb#19
  def git_ssh; end

  # Sets the attribute git_ssh
  #
  # @param value the value to set the attribute git_ssh to.
  #
  # source://git//lib/git/config.rb#7
  def git_ssh=(_arg0); end

  # source://git//lib/git/config.rb#23
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  #
  # source://git//lib/git/config.rb#7
  def timeout=(_arg0); end
end

# source://git//lib/git.rb#7
Git::Deprecation = T.let(T.unsafe(nil), ActiveSupport::Deprecation)

# object that holds the last X commits on given branch
#
# source://git//lib/git/diff.rb#6
class Git::Diff
  include ::Enumerable

  # @return [Diff] a new instance of Diff
  #
  # source://git//lib/git/diff.rb#9
  def initialize(base, from = T.unsafe(nil), to = T.unsafe(nil)); end

  # enumerable methods
  #
  # source://git//lib/git/diff.rb#64
  def [](key); end

  # source://git//lib/git/diff.rb#40
  def deletions; end

  # :yields: each Git::DiffFile in turn
  #
  # source://git//lib/git/diff.rb#69
  def each(&block); end

  # Returns the value of attribute from.
  #
  # source://git//lib/git/diff.rb#19
  def from; end

  # source://git//lib/git/diff.rb#45
  def insertions; end

  # source://git//lib/git/diff.rb#35
  def lines; end

  # source://git//lib/git/diff.rb#21
  def name_status; end

  # if file is provided and is writable, it will write the patch into the file
  #
  # source://git//lib/git/diff.rb#56
  def patch(file = T.unsafe(nil)); end

  # source://git//lib/git/diff.rb#25
  def path(path); end

  # source://git//lib/git/diff.rb#30
  def size; end

  # source://git//lib/git/diff.rb#50
  def stats; end

  # Returns the value of attribute to.
  #
  # source://git//lib/git/diff.rb#19
  def to; end

  # if file is provided and is writable, it will write the patch into the file
  #
  # source://git//lib/git/diff.rb#56
  def to_s(file = T.unsafe(nil)); end

  private

  # source://git//lib/git/diff.rb#105
  def cache_full; end

  # source://git//lib/git/diff.rb#119
  def cache_name_status; end

  # source://git//lib/git/diff.rb#115
  def cache_stats; end

  # source://git//lib/git/diff.rb#109
  def process_full; end

  # break up @diff_full
  #
  # source://git//lib/git/diff.rb#124
  def process_full_diff; end
end

# source://git//lib/git/diff.rb#74
class Git::Diff::DiffFile
  # @return [DiffFile] a new instance of DiffFile
  #
  # source://git//lib/git/diff.rb#79
  def initialize(base, hash); end

  # @return [Boolean]
  #
  # source://git//lib/git/diff.rb#90
  def binary?; end

  # source://git//lib/git/diff.rb#94
  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute dst.
  #
  # source://git//lib/git/diff.rb#75
  def dst; end

  # Sets the attribute dst
  #
  # @param value the value to set the attribute dst to.
  #
  # source://git//lib/git/diff.rb#75
  def dst=(_arg0); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/diff.rb#75
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/diff.rb#75
  def mode=(_arg0); end

  # Returns the value of attribute patch.
  #
  # source://git//lib/git/diff.rb#75
  def patch; end

  # Sets the attribute patch
  #
  # @param value the value to set the attribute patch to.
  #
  # source://git//lib/git/diff.rb#75
  def patch=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/diff.rb#75
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/diff.rb#75
  def path=(_arg0); end

  # Returns the value of attribute src.
  #
  # source://git//lib/git/diff.rb#75
  def src; end

  # Sets the attribute src
  #
  # @param value the value to set the attribute src to.
  #
  # source://git//lib/git/diff.rb#75
  def src=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/diff.rb#75
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/diff.rb#75
  def type=(_arg0); end
end

# source://git//lib/git/diff.rb#77
Git::Diff::DiffFile::NIL_BLOB_REGEXP = T.let(T.unsafe(nil), Regexp)

# Method that can be used to detect and normalize string encoding
#
# source://git//lib/git/encoding_utils.rb#7
module Git::EncodingUtils
  class << self
    # source://git//lib/git/encoding_utils.rb#12
    def best_guess_encoding; end

    # source://git//lib/git/encoding_utils.rb#8
    def default_encoding; end

    # source://git//lib/git/encoding_utils.rb#17
    def detected_encoding(str); end

    # source://git//lib/git/encoding_utils.rb#21
    def encoding_options; end

    # source://git//lib/git/encoding_utils.rb#25
    def normalize_encoding(str); end
  end
end

# Base class for all custom git module errors
#
# The git gem will only raise an `ArgumentError` or an error that is a subclass of
# `Git::Error`. It does not explicitly raise any other types of errors.
#
# It is recommended to rescue `Git::Error` to catch any runtime error raised by
# this gem unless you need more specific error handling.
#
# Git's custom errors are arranged in the following class heirarchy:
#
# ```text
# StandardError
# > Git::Error
#     > Git::CommandLineError
#        > Git::FailedError
#        > Git::SignaledError
#            > Git::TimeoutError
#     > Git::ProcessIOError
#     > Git::UnexpectedResultError
# ```
#
# | Error Class | Description |
# | --- | --- |
# | `Error` | This catch-all error serves as the base class for other custom errors raised by the git gem. |
# | `CommandLineError` | A subclass of this error is raised when there is a problem executing the git command line. |
# | `FailedError` | This error is raised when the git command line exits with a non-zero status code that is not expected by the git gem. |
# | `SignaledError` | This error is raised when the git command line is terminated as a result of receiving a signal. This could happen if the process is forcibly terminated or if there is a serious system error. |
# | `TimeoutError` | This is a specific type of `SignaledError` that is raised when the git command line operation times out and is killed via the SIGKILL signal. This happens if the operation takes longer than the timeout duration configured in `Git.config.timeout` or via the `:timeout` parameter given in git methods that support timeouts. |
# | `ProcessIOError` | An error was encountered reading or writing to a subprocess. |
# | `UnexpectedResultError` | The command line ran without error but did not return the expected results. |
#
# @api public
# @example Rescuing a timeout error
#   begin
#   timeout_duration = 0.001 # seconds
#   repo = Git.clone('https://github.com/ruby-git/ruby-git', 'ruby-git-temp', timeout: timeout_duration)
#   rescue Git::TimeoutError => e # Catch the more specific error first!
#   puts "Git clone took too long and timed out #{e}"
#   rescue Git::Error => e
#   puts "Received the following error: #{e}"
#   end
# @example Rescuing a generic error
#   begin
#   # some git operation
#   rescue Git::Error => e
#   puts "An error occurred: #{e.message}"
#   end
# @see Git::SignaledError
# @see Git::TimeoutError
# @see Git::ProcessIOError
# @see Git::UnexpectedResultError
# @see Git::CommandLineError
# @see Git::FailedError
#
# source://git//lib/git/errors.rb#61
class Git::Error < ::StandardError; end

# Represents an escaped Git path string
#
# Git commands that output paths (e.g. ls-files, diff), will escape unusual
# characters in the path with backslashes in the same way C escapes control
# characters (e.g. \t for TAB, \n for LF, \\ for backslash) or bytes with values
# larger than 0x80 (e.g. octal \302\265 for "micro" in UTF-8).
#
# @example
#   Git::GitPath.new('\302\265').unescape # => ""
#
# source://git//lib/git/escaped_path.rb#14
class Git::EscapedPath
  # @return [EscapedPath] a new instance of EscapedPath
  #
  # source://git//lib/git/escaped_path.rb#31
  def initialize(path); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/escaped_path.rb#29
  def path; end

  # Convert an escaped path to an unescaped path
  #
  # source://git//lib/git/escaped_path.rb#36
  def unescape; end

  private

  # source://git//lib/git/escaped_path.rb#66
  def escaped_path_to_bytes(path); end

  # source://git//lib/git/escaped_path.rb#48
  def extract_escape(path, index); end

  # source://git//lib/git/escaped_path.rb#44
  def extract_octal(path, index); end

  # source://git//lib/git/escaped_path.rb#52
  def extract_single_char(path, index); end

  # source://git//lib/git/escaped_path.rb#56
  def next_byte(path, index); end
end

# source://git//lib/git/escaped_path.rb#15
Git::EscapedPath::UNESCAPES = T.let(T.unsafe(nil), Hash)

# This error is raised when a git command returns a non-zero exitstatus
#
# The git command executed, status, stdout, and stderr are available from this
# object.
#
# @api public
#
# source://git//lib/git/errors.rb#132
class Git::FailedError < ::Git::CommandLineError; end

# The URI for git's alternative scp-like syntax
#
# This class is necessary to ensure that #to_s returns the same string
# that was passed to the initializer.
#
# @api public
#
# source://git//lib/git/url.rb#85
class Git::GitAltURI < ::Addressable::URI
  # Create a new GitAltURI object
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.to_s #=> 'james@github.com/james/ruby-git'
  # @param user [String, nil] the user from the URL or nil
  # @param host [String] the host from the URL
  # @param path [String] the path from the URL
  # @return [GitAltURI] a new instance of GitAltURI
  #
  # source://git//lib/git/url.rb#96
  def initialize(user:, host:, path:); end

  # Convert the URI to a String
  #
  # Addressible::URI forces path to be absolute by prepending a '/' to the
  # path. This method removes the '/' when converting back to a string
  # since that is what is expected by git. The following is a valid git URL:
  #
  #  `james@github.com:ruby-git/ruby-git.git`
  #
  # and the following (with the initial '/'' in the path) is NOT a valid git URL:
  #
  #  `james@github.com:/ruby-git/ruby-git.git`
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.path #=> '/james/ruby-git'
  #   uri.to_s #=> 'james@github.com:james/ruby-git'
  # @return [String] the URI as a String
  #
  # source://git//lib/git/url.rb#119
  def to_s; end
end

# An alias for Git::Error
#
# Git::GitExecuteError error class is an alias for Git::Error for backwards
# compatibility. It is recommended to use Git::Error directly.
#
# @deprecated Use Git::Error instead
#
# source://git//lib/git/errors.rb#70
Git::GitExecuteError = Git::Error

# source://git//lib/git/index.rb#4
class Git::Index < ::Git::Path; end

# source://git//lib/git/lib.rb#14
class Git::Lib
  # Create a new Git::Lib object
  #
  # @overload initialize
  # @overload initialize
  # @return [Lib] a new instance of Lib
  #
  # source://git//lib/git/lib.rb#61
  def initialize(base = T.unsafe(nil), logger = T.unsafe(nil)); end

  # Update the index from the current worktree to prepare the for the next commit
  #
  # @example
  #   lib.add('path/to/file')
  #   lib.add(['path/to/file1','path/to/file2'])
  #   lib.add(:all => true)
  # @option options
  # @option options
  # @param paths [String, Array<String>] files to be added to the repository (relative to the worktree root)
  # @param options [Hash]
  #
  # source://git//lib/git/lib.rb#1028
  def add(paths = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1136
  def apply(patch_file); end

  # source://git//lib/git/lib.rb#1142
  def apply_mail(patch_file); end

  # creates an archive file
  #
  # options
  #  :format  (zip, tar)
  #  :prefix
  #  :remote
  #  :path
  #
  # source://git//lib/git/lib.rb#1456
  def archive(sha, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Validate that the given arguments cannot be mistaken for a command-line option
  #
  # @param arg_name [String] the name of the arguments to mention in the error message
  # @param args [Array<String, nil>] the arguments to validate
  # @raise [ArgumentError] if any of the parameters are a string starting with a hyphen
  # @return [void]
  #
  # source://git//lib/git/lib.rb#809
  def assert_args_are_not_options(arg_name, *args); end

  # source://git//lib/git/lib.rb#767
  def branch_contains(commit, branch_name = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#762
  def branch_current; end

  # source://git//lib/git/lib.rb#1189
  def branch_delete(branch); end

  # source://git//lib/git/lib.rb#1185
  def branch_new(branch); end

  # source://git//lib/git/lib.rb#645
  def branches_all; end

  # Return a hash of commit data
  #
  # The returned commit data has the following keys:
  #    * tree [String]
  #    * parent [Array<String>]
  #    * author [String] the author name, email, and commit timestamp
  #    * committer [String] the committer name, email, and merge timestamp
  #    * message [String] the commit message
  #    * gpgsig [String] the public signing key of the commit (if signed)
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] commit data
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#448
  def cat_file_commit(object); end

  # Output the contents or other properties of one or more objects.
  #
  # @example Get the contents of a file without a block
  #   lib.cat_file_contents('README.md') # => "This is a README file\n"
  # @example Get the contents of a file with a block
  #   lib.cat_file_contents('README.md') { |f| f.read } # => "This is a README file\n"
  # @param object [String] the object whose contents to return
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object contents
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#374
  def cat_file_contents(object, &block); end

  # Get the size for the given object
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#422
  def cat_file_size(object); end

  # Return a hash of annotated tag data
  #
  # Does not work with lightweight tags. List all annotated tags in your repository with the following command:
  #
  # ```sh
  # git for-each-ref --format='%(refname:strip=2)' refs/tags | while read tag; do git cat-file tag $tag >/dev/null 2>&1 && echo $tag; done
  # ```
  #
  # The returned commit data has the following keys:
  #   * object [String] the sha of the tag object
  #   * type [String]
  #   * tag [String] tag name
  #   * tagger [String] the name and email of the user who created the tag and the timestamp of when the tag was created
  #   * message [String] the tag message
  #
  # @param object [String] the tag to retrieve
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] tag data
  #
  #   Example tag data returned:
  #   ```ruby
  #   {
  #   "name" => "annotated_tag",
  #   "object" => "46abbf07e3c564c723c7c039a43ab3a39e5d02dd",
  #   "type" => "commit",
  #   "tag" => "annotated_tag",
  #   "tagger" => "Scott Chacon <schacon@gmail.com> 1724799270 -0700",
  #   "message" => "Creating an annotated tag\n"
  #   }
  #   ```
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#526
  def cat_file_tag(object); end

  # Get the type for the given object
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#404
  def cat_file_type(object); end

  # source://git//lib/git/lib.rb#617
  def change_head_branch(branch_name); end

  # Runs checkout command to checkout or create branch
  #
  # accepts options:
  #  :new_branch
  #  :force
  #  :start_point
  #
  # @param branch [String]
  # @param opts [Hash]
  #
  # source://git//lib/git/lib.rb#1202
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1217
  def checkout_file(version, file); end

  # source://git//lib/git/lib.rb#1439
  def checkout_index(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1115
  def clean(opts = T.unsafe(nil)); end

  # Clones a repository into a newly created directory
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param repository_url [String] the URL of the repository to clone
  # @param directory [String, nil] the directory to clone into
  #
  #   If nil, the repository is cloned into a directory with the same name as
  #   the repository.
  # @param opts [Hash] the options for this command
  # @return [Hash] the options to pass to {Git::Base.new}
  # @todo make this work with SSH password or auth_key
  #
  # source://git//lib/git/lib.rb#122
  def clone(repository_url, directory, opts = T.unsafe(nil)); end

  # Takes the commit message with the options and executes the commit command
  #
  # accepts options:
  #  :amend
  #  :all
  #  :allow_empty
  #  :author
  #  :date
  #  :no_verify
  #  :allow_empty_message
  #  :gpg_sign (accepts true or a gpg key ID as a String)
  #  :no_gpg_sign (conflicts with :gpg_sign)
  #
  # @param message [String] the commit message to be used
  # @param opts [Hash] the commit options to be used
  #
  # source://git//lib/git/lib.rb#1081
  def commit(message, opts = T.unsafe(nil)); end

  # Return a hash of commit data
  #
  # The returned commit data has the following keys:
  #    * tree [String]
  #    * parent [Array<String>]
  #    * author [String] the author name, email, and commit timestamp
  #    * committer [String] the committer name, email, and merge timestamp
  #    * message [String] the commit message
  #    * gpgsig [String] the public signing key of the commit (if signed)
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] commit data
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#448
  def commit_data(object); end

  # source://git//lib/git/lib.rb#1425
  def commit_tree(tree, opts = T.unsafe(nil)); end

  # Returns current_command_version <=> other_version
  #
  # @example
  #   lib.current_command_version #=> [2, 42, 0]
  #
  #   lib.compare_version_to(2, 41, 0) #=> 1
  #   lib.compare_version_to(2, 42, 0) #=> 0
  #   lib.compare_version_to(2, 43, 0) #=> -1
  # @param other_version [Array<Object>] the other version to compare to
  # @return [Integer] -1 if this version is less than other_version, 0 if equal, or 1 if greater than
  #
  # source://git//lib/git/lib.rb#1512
  def compare_version_to(*other_version); end

  # source://git//lib/git/lib.rb#958
  def config_get(name); end

  # source://git//lib/git/lib.rb#966
  def config_list; end

  # source://git//lib/git/lib.rb#948
  def config_remote(name); end

  # WRITE COMMANDS ##
  #
  # source://git//lib/git/lib.rb#1002
  def config_set(name, value, options = T.unsafe(nil)); end

  # :yields: file, your, their
  #
  # source://git//lib/git/lib.rb#1256
  def conflicts; end

  # The current branch state which is the state of `HEAD`
  #
  # @return [HeadState] the state and name of the current branch
  #
  # source://git//lib/git/lib.rb#745
  def current_branch_state; end

  # returns the current version of git, as an Array of Fixnums.
  #
  # source://git//lib/git/lib.rb#1493
  def current_command_version; end

  # Finds most recent tag that is reachable from a commit
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param commit_ish [String, nil] target commit sha or object name
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String] the tag name
  # @see https://git-scm.com/docs/git-describe git-describe
  #
  # source://git//lib/git/lib.rb#198
  def describe(commit_ish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the working directory
  #
  # source://git//lib/git/lib.rb#866
  def diff_files; end

  # source://git//lib/git/lib.rb#816
  def diff_full(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the repository
  #
  # source://git//lib/git/lib.rb#871
  def diff_index(treeish); end

  # source://git//lib/git/lib.rb#849
  def diff_name_status(reference1 = T.unsafe(nil), reference2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#827
  def diff_stats(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#478
  def each_cat_file_header(data); end

  # Returns true if the repository is empty (meaning it has no commits)
  #
  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1057
  def empty?; end

  # source://git//lib/git/lib.rb#1328
  def fetch(remote, opts); end

  # Return the commits that are within the given revision range
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the revision range (specified with :between or :object) is a string starting with a hyphen
  # @return [Array<Hash>] the log output parsed into an array of hashs for each commit
  #
  #   Each hash contains the following keys:
  #   * 'sha' [String] the commit sha
  #   * 'author' [String] the author of the commit
  #   * 'message' [String] the commit message
  #   * 'parent' [Array<String>] the commit shas of the parent commits
  #   * 'tree' [String] the tree sha
  #   * 'author' [String] the author of the commit and timestamp of when the changes were created
  #   * 'committer' [String] the committer of the commit and timestamp of when the commit was applied
  # @see https://git-scm.com/docs/git-log git-log
  #
  # source://git//lib/git/lib.rb#300
  def full_log_commits(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#609
  def full_tree(sha); end

  # source://git//lib/git/lib.rb#1409
  def gc; end

  # The path to the Git repository directory.  The default is
  # `"#{git_work_dir}/.git"`.
  #
  # @return [Pathname] the Git repository directory.
  # @see [Git repository](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefrepositoryarepository)
  #
  # source://git//lib/git/lib.rb#30
  def git_dir; end

  # The Git index file used to stage changes (using `git add`) before they
  # are committed.
  #
  # @return [Pathname] the Git index file
  # @see [Git index file](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefindexaindex)
  #
  # source://git//lib/git/lib.rb#39
  def git_index_file; end

  # The path to the Git working copy.  The default is '"./.git"'.
  #
  # @return [Pathname] the path to the Git working copy.
  # @see [Git working tree](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefworkingtreeaworkingtree)
  #
  # source://git//lib/git/lib.rb#21
  def git_work_dir; end

  # source://git//lib/git/lib.rb#962
  def global_config_get(name); end

  # source://git//lib/git/lib.rb#970
  def global_config_list; end

  # source://git//lib/git/lib.rb#1010
  def global_config_set(name, value); end

  # returns hash
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  #
  # source://git//lib/git/lib.rb#774
  def grep(string, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#940
  def ignored_files; end

  # creates or reinitializes the repository
  #
  # options:
  #   :bare
  #   :working_directory
  #   :initial_branch
  #
  # source://git//lib/git/lib.rb#86
  def init(opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#707
  def list_files(ref_dir); end

  # Return the commits that are within the given revision range
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the resulting revision range is a string starting with a hyphen
  # @return [Array<String>] the log output
  # @see https://git-scm.com/docs/git-log git-log
  #
  # source://git//lib/git/lib.rb#250
  def log_commits(opts = T.unsafe(nil)); end

  # List all files that are in the index
  #
  # @param location [String] the location to list the files from
  # @return [Hash<String, Hash>] a hash of files in the index
  #   * key: file [String] the file path
  #   * value: file_info [Hash] the file information containing the following keys:
  #   * :path [String] the file path
  #   * :mode_index [String] the file mode
  #   * :sha_index [String] the file sha
  #   * :stage [String] the file stage
  #
  # source://git//lib/git/lib.rb#887
  def ls_files(location = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#923
  def ls_remote(location = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#588
  def ls_tree(sha, opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1520
  def meets_required_version?; end

  # source://git//lib/git/lib.rb#1224
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1233
  def merge_base(*args); end

  # source://git//lib/git/lib.rb#605
  def mv(file1, file2); end

  # Find the first symbolic name for given commit_ish
  #
  # @param commit_ish [String] the commit_ish to find the symbolic name of
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String, nil] the first symbolic name or nil if the commit_ish isn't found
  #
  # source://git//lib/git/lib.rb#350
  def name_rev(commit_ish); end

  # Find the first symbolic name for given commit_ish
  #
  # @param commit_ish [String] the commit_ish to find the symbolic name of
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String, nil] the first symbolic name or nil if the commit_ish isn't found
  #
  # source://git//lib/git/lib.rb#350
  def namerev(commit_ish); end

  # Output the contents or other properties of one or more objects.
  #
  # @example Get the contents of a file without a block
  #   lib.cat_file_contents('README.md') # => "This is a README file\n"
  # @example Get the contents of a file with a block
  #   lib.cat_file_contents('README.md') { |f| f.read } # => "This is a README file\n"
  # @param object [String] the object whose contents to return
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object contents
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#374
  def object_contents(object, &block); end

  # Get the size for the given object
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#422
  def object_size(object); end

  # Get the type for the given object
  #
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#404
  def object_type(object); end

  # source://git//lib/git/lib.rb#983
  def parse_config(file); end

  # source://git//lib/git/lib.rb#974
  def parse_config_list(lines); end

  # source://git//lib/git/lib.rb#457
  def process_commit_data(data, sha); end

  # source://git//lib/git/lib.rb#547
  def process_commit_log_data(data); end

  # source://git//lib/git/lib.rb#535
  def process_tag_data(data, name); end

  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1382
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1345
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # reads a tree into the current index file
  #
  # source://git//lib/git/lib.rb#1414
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1272
  def remote_add(name, url, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1291
  def remote_remove(name); end

  # source://git//lib/git/lib.rb#1283
  def remote_set_url(name, url); end

  # source://git//lib/git/lib.rb#1295
  def remotes; end

  # source://git//lib/git/lib.rb#1405
  def repack; end

  # Returns the name of the default branch of the given repository
  #
  # @param repository [URI, Pathname, String] The (possibly remote) repository to clone from
  # @raise [Git::UnexpectedResultError]
  # @return [String] the name of the default branch
  #
  # source://git//lib/git/lib.rb#160
  def repository_default_branch(repository); end

  # source://git//lib/git/lib.rb#1516
  def required_command_version; end

  # source://git//lib/git/lib.rb#1108
  def reset(commit, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#146
  def return_base_opts_from_clone(clone_dir, opts); end

  # Verify and resolve a Git revision to its full SHA
  #
  # @example
  #   lib.rev_parse('HEAD') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  #   lib.rev_parse('9b9b31e') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  # @param revision [String] the revision to resolve
  # @raise [Git::FailedError] if the revision cannot be resolved
  # @raise [ArgumentError] if the revision is a string starting with a hyphen
  # @return [String] the full commit hash
  # @see https://git-scm.com/docs/git-rev-parse git-rev-parse
  # @see https://git-scm.com/docs/git-rev-parse#_specifying_revisions Valid ways to specify revisions
  # @see https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrefnamegtemegemmasterememheadsmasterememrefsheadsmasterem Ref disambiguation rules
  #
  # source://git//lib/git/lib.rb#333
  def rev_parse(revision); end

  # source://git//lib/git/lib.rb#1125
  def revert(commitish, opts = T.unsafe(nil)); end

  # Verify and resolve a Git revision to its full SHA
  # For backwards compatibility with the old method name
  #
  # @example
  #   lib.rev_parse('HEAD') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  #   lib.rev_parse('9b9b31e') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  # @param revision [String] the revision to resolve
  # @raise [Git::FailedError] if the revision cannot be resolved
  # @raise [ArgumentError] if the revision is a string starting with a hyphen
  # @return [String] the full commit hash
  # @see https://git-scm.com/docs/git-rev-parse git-rev-parse
  # @see https://git-scm.com/docs/git-rev-parse#_specifying_revisions Valid ways to specify revisions
  # @see https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrefnamegtemegemmasterememheadsmasterememrefsheadsmasterem Ref disambiguation rules
  #
  # source://git//lib/git/lib.rb#333
  def revparse(revision); end

  # source://git//lib/git/lib.rb#1043
  def rm(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Shows objects
  #
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/lib.rb#992
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1169
  def stash_apply(id = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1177
  def stash_clear; end

  # source://git//lib/git/lib.rb#1181
  def stash_list; end

  # source://git//lib/git/lib.rb#1164
  def stash_save(message); end

  # source://git//lib/git/lib.rb#1148
  def stashes_all; end

  # source://git//lib/git/lib.rb#1303
  def tag(name, *opts); end

  # Return a hash of annotated tag data
  #
  # Does not work with lightweight tags. List all annotated tags in your repository with the following command:
  #
  # ```sh
  # git for-each-ref --format='%(refname:strip=2)' refs/tags | while read tag; do git cat-file tag $tag >/dev/null 2>&1 && echo $tag; done
  # ```
  #
  # The returned commit data has the following keys:
  #   * object [String] the sha of the tag object
  #   * type [String]
  #   * tag [String] tag name
  #   * tagger [String] the name and email of the user who created the tag and the timestamp of when the tag was created
  #   * message [String] the tag message
  #
  # @param object [String] the tag to retrieve
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] tag data
  #
  #   Example tag data returned:
  #   ```ruby
  #   {
  #   "name" => "annotated_tag",
  #   "object" => "46abbf07e3c564c723c7c039a43ab3a39e5d02dd",
  #   "type" => "commit",
  #   "tag" => "annotated_tag",
  #   "tagger" => "Scott Chacon <schacon@gmail.com> 1724799270 -0700",
  #   "message" => "Creating an annotated tag\n"
  #   }
  #   ```
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#526
  def tag_data(object); end

  # source://git//lib/git/lib.rb#1392
  def tag_sha(tag_name); end

  # source://git//lib/git/lib.rb#1299
  def tags; end

  # source://git//lib/git/lib.rb#613
  def tree_depth(sha); end

  # Unescape a path if it is quoted
  #
  # Git commands that output paths (e.g. ls-files, diff), will escape unusual
  # characters.
  #
  # @api private
  # @example
  #   lib.unescape_if_quoted('"quoted_file_\\342\\230\\240"') # => 'quoted_file_'
  #   lib.unescape_if_quoted('unquoted_file')   # => 'unquoted_file'
  # @param path [String] the path to unescape if quoted
  # @return [String] the unescaped path if quoted otherwise the original path
  #
  # source://git//lib/git/lib.rb#915
  def unescape_quoted_path(path); end

  # source://git//lib/git/lib.rb#662
  def unexpected_branch_line_error(lines, line, index); end

  # source://git//lib/git/lib.rb#1248
  def unmerged; end

  # source://git//lib/git/lib.rb#944
  def untracked_files; end

  # source://git//lib/git/lib.rb#1435
  def update_ref(ref, commit); end

  # source://git//lib/git/lib.rb#694
  def worktree_add(dir, commitish = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#703
  def worktree_prune; end

  # source://git//lib/git/lib.rb#699
  def worktree_remove(dir); end

  # source://git//lib/git/lib.rb#674
  def worktrees_all; end

  # source://git//lib/git/lib.rb#1421
  def write_tree; end

  private

  # Runs a git command and returns the output
  #
  # is true)
  #
  # @api private
  # @param args [Array] the git command to run and its arguments
  #
  #   This should exclude the 'git' command itself and global options.
  #
  #   For example, to run `git log --pretty=oneline`, you would pass `['log',
  #   '--pretty=oneline']`
  # @param out [String, nil] the path to a file or an IO to write the command's
  #   stdout to
  # @param err [String, nil] the path to a file or an IO to write the command's
  #   stdout to
  # @param normalize [Boolean] true to normalize the output encoding
  # @param chomp [Boolean] true to remove trailing newlines from the output
  # @param merge [Boolean] true to merge stdout and stderr
  # @param timeout [Numeric, nil] the maximum seconds to wait for the command to complete
  #
  #   If timeout is nil, the global timeout from {Git::Config} is used.
  #
  #   If timeout is zero, the timeout will not be enforced.
  #
  #   If the command times out, it is killed via a `SIGKILL` signal and `Git::TimeoutError` is raised.
  #
  #   If the command does not respond to SIGKILL, it will hang this method.
  # @param chdir [String, nil] the directory to run the command in
  # @raise [Git::FailedError] if the command failed
  # @raise [Git::SignaledError] if the command was signaled
  # @raise [Git::TimeoutError] if the command times out
  # @raise [Git::ProcessIOError] if an exception was raised while collecting subprocess output
  #
  #   The exception's `result` attribute is a {Git::CommandLineResult} which will
  #   contain the result of the command including the exit status, stdout, and
  #   stderr.
  # @return [String] the command's stdout (or merged stdout and stderr if `merge`
  # @see Git::CommandLine#run
  #
  # source://git//lib/git/lib.rb#1625
  def command(*args, out: T.unsafe(nil), err: T.unsafe(nil), normalize: T.unsafe(nil), chomp: T.unsafe(nil), merge: T.unsafe(nil), chdir: T.unsafe(nil), timeout: T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1571
  def command_line; end

  # source://git//lib/git/lib.rb#1535
  def command_lines(cmd, *opts, chdir: T.unsafe(nil)); end

  # Takes the diff command line output (as Array) and parse it into a Hash
  #
  # @param diff_command [String] the diff commadn to be used
  # @param opts [Array] the diff options to be used
  # @return [Hash] the diff as Hash
  #
  # source://git//lib/git/lib.rb#1636
  def diff_as_hash(diff_command, opts = T.unsafe(nil)); end

  # source://git//lib/git/lib.rb#1545
  def env_overrides; end

  # source://git//lib/git/lib.rb#1554
  def global_opts; end

  # Returns an array holding the common options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of common options that the log command will use
  #
  # source://git//lib/git/lib.rb#1660
  def log_common_options(opts); end

  # Retrurns an array holding path options for the log commands
  #
  # @param opts [Hash] the given options
  # @return [Array] the set of path options that the log command will use
  #
  # source://git//lib/git/lib.rb#1684
  def log_path_options(opts); end

  class << self
    # source://git//lib/git/lib.rb#1524
    def warn_if_old_command(lib); end
  end
end

# source://git//lib/git/lib.rb#621
Git::Lib::BRANCH_LINE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://git//lib/git/lib.rb#476
Git::Lib::CAT_FILE_HEADER_LINE = T.let(T.unsafe(nil), Regexp)

# The state and name of branch pointed to by `HEAD`
#
# HEAD can be in the following states:
#
# **:active**: `HEAD` points to a branch reference which in turn points to a
# commit representing the tip of that branch. This is the typical state when
# working on a branch.
#
# **:unborn**: `HEAD` points to a branch reference that does not yet exist
# because no commits have been made on that branch. This state occurs in two
# scenarios:
#
# * When a repository is newly initialized, and no commits have been made on the
#   initial branch.
# * When a new branch is created using `git checkout --orphan <branch>`, starting
#   a new branch with no history.
#
# **:detached**: `HEAD` points directly to a specific commit (identified by its
# SHA) rather than a branch reference. This state occurs when you check out a
# commit, a tag, or any state that is not directly associated with a branch. The
# branch name in this case is `HEAD`.
#
# source://git//lib/git/lib.rb#739
class Git::Lib::HeadState < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute state
  #
  # @return [Object] the current value of state
  def state; end

  # Sets the attribute state
  #
  # @param value [Object] the value to set the attribute state to.
  # @return [Object] the newly set value
  def state=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Return the last n commits that match the specified criteria
#
# @api public
# @example The last (default number) of commits
#   git = Git.open('.')
#   Git::Log.new(git) #=> Enumerable of the last 30 commits
# @example The last n commits
#   Git::Log.new(git).max_commits(50) #=> Enumerable of last 50 commits
# @example All commits returned by `git log`
#   Git::Log.new(git).max_count(:all) #=> Enumerable of all commits
# @example All commits that match complex criteria
#   Git::Log.new(git)
#   .max_count(:all)
#   .object('README.md')
#   .since('10 years ago')
#   .between('v1.0.7', 'HEAD')
#
# source://git//lib/git/log.rb#26
class Git::Log
  include ::Enumerable

  # Create a new Git::Log object
  #
  # @api public
  # @example
  #   git = Git.open('.')
  #   Git::Log.new(git)
  # @param base [Git::Base] the git repository object
  # @param max_count [Integer, Symbol, nil] the number of commits to return, or
  #   `:all` or `nil` to return all
  #
  #   Passing max_count to {#initialize} is equivalent to calling {#max_count} on the object.
  # @return [Log] a new instance of Log
  #
  # source://git//lib/git/log.rb#41
  def initialize(base, max_count = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/log.rb#163
  def [](index); end

  # Adds the --all flag to the git log command
  #
  # This asks for the logs of all refs (basically all commits reachable by HEAD,
  # branches, and tags). This does not control the maximum number of commits
  # returned. To control how many commits are returned, call {#max_count}.
  #
  # @api public
  # @example Return the last 50 commits reachable by all refs
  #   git = Git.open('.')
  #   Git::Log.new(git).max_count(50).all
  # @return [self]
  #
  # source://git//lib/git/log.rb#76
  def all; end

  # @api public
  #
  # source://git//lib/git/log.rb#88
  def author(regex); end

  # @api public
  #
  # source://git//lib/git/log.rb#124
  def between(sha1, sha2 = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/log.rb#130
  def cherry; end

  # @api public
  #
  # source://git//lib/git/log.rb#148
  def each(&block); end

  # @api public
  #
  # source://git//lib/git/log.rb#153
  def first; end

  # @api public
  #
  # source://git//lib/git/log.rb#94
  def grep(regex); end

  # @api public
  #
  # source://git//lib/git/log.rb#158
  def last; end

  # The maximum number of commits to return
  #
  # @api public
  # @example All commits returned by `git log`
  #   git = Git.open('.')
  #   Git::Log.new(git).max_count(:all)
  # @param num_or_all [Integer, Symbol, nil] the number of commits to return, or
  #   `:all` or `nil` to return all
  # @return [self]
  #
  # source://git//lib/git/log.rb#58
  def max_count(num_or_all); end

  # @api public
  #
  # source://git//lib/git/log.rb#82
  def object(objectish); end

  # @api public
  #
  # source://git//lib/git/log.rb#100
  def path(path); end

  # @api public
  #
  # source://git//lib/git/log.rb#112
  def since(date); end

  # forces git log to run
  #
  # @api public
  #
  # source://git//lib/git/log.rb#143
  def size; end

  # @api public
  #
  # source://git//lib/git/log.rb#106
  def skip(num); end

  # @api public
  #
  # source://git//lib/git/log.rb#136
  def to_s; end

  # @api public
  #
  # source://git//lib/git/log.rb#118
  def until(date); end

  private

  # @api public
  #
  # source://git//lib/git/log.rb#175
  def check_log; end

  # @api public
  #
  # source://git//lib/git/log.rb#171
  def dirty_log; end

  # actually run the 'git log' command
  #
  # @api public
  #
  # source://git//lib/git/log.rb#183
  def run_log; end
end

# represents a git object
#
# source://git//lib/git/object.rb#11
class Git::Object
  class << self
    # if we're calling this, we don't know what type it is yet
    # so this is our little factory method
    #
    # source://git//lib/git/object.rb#296
    def new(base, objectish, type = T.unsafe(nil), is_tag = T.unsafe(nil)); end
  end
end

# source://git//lib/git/object.rb#13
class Git::Object::AbstractObject
  # @return [AbstractObject] a new instance of AbstractObject
  #
  # source://git//lib/git/object.rb#18
  def initialize(base, objectish); end

  # creates an archive of this object (tree)
  #
  # source://git//lib/git/object.rb#71
  def archive(file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#77
  def blob?; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#79
  def commit?; end

  # Get the object's contents.
  # If no block is given, the contents are cached in memory and returned as a string.
  # If a block is given, it yields an IO object (via IO::popen) which could be used to
  # read a large file in chunks.
  #
  # Use this for large files so that they are not held in memory.
  #
  # source://git//lib/git/object.rb#41
  def contents(&block); end

  # source://git//lib/git/object.rb#49
  def contents_array; end

  # source://git//lib/git/object.rb#62
  def diff(objectish); end

  # source://git//lib/git/object.rb#57
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#66
  def log(count = T.unsafe(nil)); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/object.rb#14
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/object.rb#14
  def mode=(_arg0); end

  # Returns the value of attribute objectish.
  #
  # source://git//lib/git/object.rb#14
  def objectish; end

  # Sets the attribute objectish
  #
  # @param value the value to set the attribute objectish to.
  #
  # source://git//lib/git/object.rb#14
  def objectish=(_arg0); end

  # source://git//lib/git/object.rb#27
  def sha; end

  # source://git//lib/git/object.rb#31
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://git//lib/git/object.rb#16
  def size=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#81
  def tag?; end

  # source://git//lib/git/object.rb#53
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#75
  def tree?; end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/object.rb#14
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/object.rb#14
  def type=(_arg0); end
end

# source://git//lib/git/object.rb#86
class Git::Object::Blob < ::Git::Object::AbstractObject
  # @return [Blob] a new instance of Blob
  #
  # source://git//lib/git/object.rb#88
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#93
  def blob?; end
end

# source://git//lib/git/object.rb#160
class Git::Object::Commit < ::Git::Object::AbstractObject
  # @return [Commit] a new instance of Commit
  #
  # source://git//lib/git/object.rb#162
  def initialize(base, sha, init = T.unsafe(nil)); end

  # git author
  #
  # source://git//lib/git/object.rb#199
  def author; end

  # source://git//lib/git/object.rb#204
  def author_date; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#232
  def commit?; end

  # git author
  #
  # source://git//lib/git/object.rb#209
  def committer; end

  # source://git//lib/git/object.rb#214
  def committer_date; end

  # source://git//lib/git/object.rb#214
  def date; end

  # source://git//lib/git/object.rb#219
  def diff_parent; end

  # source://git//lib/git/object.rb#183
  def gtree; end

  # source://git//lib/git/object.rb#174
  def message; end

  # source://git//lib/git/object.rb#179
  def name; end

  # source://git//lib/git/object.rb#188
  def parent; end

  # array of all parent commits
  #
  # source://git//lib/git/object.rb#193
  def parents; end

  # source://git//lib/git/object.rb#223
  def set_commit(data); end

  private

  # see if this object has been initialized and do so if not
  #
  # source://git//lib/git/object.rb#239
  def check_commit; end
end

# source://git//lib/git/object.rb#248
class Git::Object::Tag < ::Git::Object::AbstractObject
  # @return [Tag] a new instance of Tag
  #
  # source://git//lib/git/object.rb#251
  def initialize(base, sha, name); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#258
  def annotated?; end

  # source://git//lib/git/object.rb#262
  def message; end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/object.rb#249
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/object.rb#249
  def name=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#267
  def tag?; end

  # source://git//lib/git/object.rb#271
  def tagger; end

  private

  # source://git//lib/git/object.rb#278
  def check_tag; end
end

# source://git//lib/git/object.rb#99
class Git::Object::Tree < ::Git::Object::AbstractObject
  # @return [Tree] a new instance of Tree
  #
  # source://git//lib/git/object.rb#101
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#112
  def blobs; end

  # source://git//lib/git/object.rb#108
  def children; end

  # source://git//lib/git/object.rb#127
  def depth; end

  # source://git//lib/git/object.rb#112
  def files; end

  # source://git//lib/git/object.rb#123
  def full_tree; end

  # source://git//lib/git/object.rb#117
  def subdirectories; end

  # source://git//lib/git/object.rb#117
  def subtrees; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#131
  def tree?; end

  # source://git//lib/git/object.rb#117
  def trees; end

  private

  # actually run the git command
  #
  # source://git//lib/git/object.rb#138
  def check_tree; end
end

# source://git//lib/git/path.rb#5
class Git::Path
  # @return [Path] a new instance of Path
  #
  # source://git//lib/git/path.rb#9
  def initialize(path, check_path = T.unsafe(nil)); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/path.rb#7
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/path.rb#7
  def path=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#19
  def readable?; end

  # source://git//lib/git/path.rb#27
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#23
  def writable?; end
end

# Raised when the output of a git command can not be read
#
# @api public
#
# source://git//lib/git/errors.rb#199
class Git::ProcessIOError < ::Git::Error; end

# source://git//lib/git/remote.rb#4
class Git::Remote < ::Git::Path
  # @return [Remote] a new instance of Remote
  #
  # source://git//lib/git/remote.rb#8
  def initialize(base, name); end

  # source://git//lib/git/remote.rb#26
  def branch(branch = T.unsafe(nil)); end

  # source://git//lib/git/remote.rb#16
  def fetch(opts = T.unsafe(nil)); end

  # Returns the value of attribute fetch_opts.
  #
  # source://git//lib/git/remote.rb#6
  def fetch_opts; end

  # Sets the attribute fetch_opts
  #
  # @param value the value to set the attribute fetch_opts to.
  #
  # source://git//lib/git/remote.rb#6
  def fetch_opts=(_arg0); end

  # merge this remote locally
  #
  # source://git//lib/git/remote.rb#21
  def merge(branch = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/remote.rb#6
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/remote.rb#6
  def name=(_arg0); end

  # source://git//lib/git/remote.rb#31
  def remove; end

  # source://git//lib/git/remote.rb#35
  def to_s; end

  # Returns the value of attribute url.
  #
  # source://git//lib/git/remote.rb#6
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://git//lib/git/remote.rb#6
  def url=(_arg0); end
end

# source://git//lib/git/repository.rb#5
class Git::Repository < ::Git::Path; end

# This error is raised when a git command exits because of an uncaught signal
#
# @api public
#
# source://git//lib/git/errors.rb#138
class Git::SignaledError < ::Git::CommandLineError; end

# source://git//lib/git/stash.rb#4
class Git::Stash
  # @return [Stash] a new instance of Stash
  #
  # source://git//lib/git/stash.rb#6
  def initialize(base, message, existing = T.unsafe(nil)); end

  # source://git//lib/git/stash.rb#20
  def message; end

  # source://git//lib/git/stash.rb#12
  def save; end

  # @return [Boolean]
  #
  # source://git//lib/git/stash.rb#16
  def saved?; end

  # source://git//lib/git/stash.rb#24
  def to_s; end
end

# object that holds all the available stashes
#
# source://git//lib/git/stashes.rb#6
class Git::Stashes
  include ::Enumerable

  # @return [Stashes] a new instance of Stashes
  #
  # source://git//lib/git/stashes.rb#9
  def initialize(base); end

  # source://git//lib/git/stashes.rb#52
  def [](index); end

  # Returns an multi-dimensional Array of elements that have been stash saved.
  # Array is based on position and name. See Example
  #
  # @example Returns Array of items that have been stashed
  #   .all - [0, "testing-stash-all"]]
  # @return [Array]
  #
  # source://git//lib/git/stashes.rb#26
  def all; end

  # source://git//lib/git/stashes.rb#35
  def apply(index = T.unsafe(nil)); end

  # source://git//lib/git/stashes.rb#39
  def clear; end

  # source://git//lib/git/stashes.rb#48
  def each(&block); end

  # source://git//lib/git/stashes.rb#30
  def save(message); end

  # source://git//lib/git/stashes.rb#44
  def size; end
end

# The status class gets the status of a git repository
#
# This identifies which files have been modified, added, or deleted from the
# worktree. Untracked files are also identified.
#
# The Status object is an Enumerable that contains StatusFile objects.
#
# @api public
#
# source://git//lib/git/status.rb#13
class Git::Status
  include ::Enumerable

  # @api public
  # @return [Status] a new instance of Status
  #
  # source://git//lib/git/status.rb#16
  def initialize(base); end

  # enumerable method
  #
  # @api public
  #
  # source://git//lib/git/status.rb#126
  def [](file); end

  # Returns an Enumerable containing files that have been added.
  # File path starts at git base directory
  #
  # @api public
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#46
  def added; end

  # Determines whether the given file has been added to the repository
  #
  # File path starts at git base directory
  #
  # @api public
  # @example Check if lib/git.rb is added.
  #   added?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#58
  def added?(file); end

  # Returns an Enumerable containing files that have changed from the
  # git base directory
  #
  # @api public
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#26
  def changed; end

  # Determines whether the given file has been changed.
  # File path starts at git base directory
  #
  # @api public
  # @example Check if lib/git.rb has changed.
  #   changed?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#38
  def changed?(file); end

  # Returns an Enumerable containing files that have been deleted.
  # File path starts at git base directory
  #
  # @api public
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#67
  def deleted; end

  # Determines whether the given file has been deleted from the repository
  # File path starts at git base directory
  #
  # @api public
  # @example Check if lib/git.rb is deleted.
  #   deleted?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#79
  def deleted?(file); end

  # @api public
  #
  # source://git//lib/git/status.rb#130
  def each(&block); end

  # @api public
  #
  # source://git//lib/git/status.rb#104
  def pretty; end

  # @api public
  #
  # source://git//lib/git/status.rb#113
  def pretty_file(file); end

  # Returns an Enumerable containing files that are not tracked in git.
  # File path starts at git base directory
  #
  # @api public
  # @return [Enumerable]
  #
  # source://git//lib/git/status.rb#88
  def untracked; end

  # Determines whether the given file has is tracked by git.
  # File path starts at git base directory
  #
  # @api public
  # @example Check if lib/git.rb is an untracked file.
  #   untracked?('lib/git.rb')
  # @param file [String] The name of the file.
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#100
  def untracked?(file); end

  private

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#300
  def case_aware_include?(cased_hash, downcased_hash, file); end

  # @api public
  #
  # source://git//lib/git/status.rb#221
  def construct_status; end

  # @api public
  #
  # source://git//lib/git/status.rb#280
  def downcase_keys(hash); end

  # @api public
  #
  # source://git//lib/git/status.rb#259
  def fetch_added; end

  # @api public
  #
  # source://git//lib/git/status.rb#250
  def fetch_modified; end

  # @api public
  #
  # source://git//lib/git/status.rb#242
  def fetch_untracked; end

  # It's worth noting that (like git itself) this gem will not behave well if
  # ignoreCase is set inconsistently with the file-system itself. For details:
  # https://git-scm.com/docs/git-config#Documentation/git-config.txt-coreignoreCase
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#273
  def ignore_case?; end

  # @api public
  #
  # source://git//lib/git/status.rb#288
  def lc_added; end

  # @api public
  #
  # source://git//lib/git/status.rb#284
  def lc_changed; end

  # @api public
  #
  # source://git//lib/git/status.rb#292
  def lc_deleted; end

  # @api public
  #
  # source://git//lib/git/status.rb#296
  def lc_untracked; end
end

# subclass that does heavy lifting
#
# @api public
#
# source://git//lib/git/status.rb#135
class Git::Status::StatusFile
  # @api public
  # @return [StatusFile] a new instance of StatusFile
  #
  # source://git//lib/git/status.rb#194
  def initialize(base, hash); end

  # @api public
  #
  # source://git//lib/git/status.rb#206
  def blob(type = T.unsafe(nil)); end

  # The mode of the file in the index
  #
  # @example 100644
  # @return [String]
  #
  # source://git//lib/git/status.rb#157
  def mode_index; end

  # @api public
  #
  # source://git//lib/git/status.rb#157
  def mode_index=(_arg0); end

  # The mode of the file in the repo
  #
  # @example 100644
  # @return [String]
  #
  # source://git//lib/git/status.rb#164
  def mode_repo; end

  # @api public
  #
  # source://git//lib/git/status.rb#164
  def mode_repo=(_arg0); end

  # The path of the file relative to the project root directory
  #
  # @return [String]
  #
  # source://git//lib/git/status.rb#139
  def path; end

  # @api public
  #
  # source://git//lib/git/status.rb#139
  def path=(_arg0); end

  # The sha of the file in the index
  #
  # @example 123456
  # @return [String]
  #
  # source://git//lib/git/status.rb#171
  def sha_index; end

  # @api public
  #
  # source://git//lib/git/status.rb#171
  def sha_index=(_arg0); end

  # The sha of the file in the repo
  #
  # @example 123456
  # @return [String]
  #
  # source://git//lib/git/status.rb#177
  def sha_repo; end

  # @api public
  #
  # source://git//lib/git/status.rb#177
  def sha_repo=(_arg0); end

  # The stage of the file
  #
  # * '0': the unmerged state
  # * '1': the common ancestor (or original) version
  # * '2': "our version" from the current branch head
  # * '3': "their version" from the other branch head
  #
  # @return [String]
  #
  # source://git//lib/git/status.rb#192
  def stage; end

  # @api public
  #
  # source://git//lib/git/status.rb#192
  def stage=(_arg0); end

  # The type of change
  #
  # * 'M': modified
  # * 'A': added
  # * 'D': deleted
  # * nil: ???
  #
  # @return [String]
  #
  # source://git//lib/git/status.rb#150
  def type; end

  # @api public
  #
  # source://git//lib/git/status.rb#150
  def type=(_arg0); end

  # Whether the file is untracked
  #
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#182
  def untracked; end

  # @api public
  #
  # source://git//lib/git/status.rb#182
  def untracked=(_arg0); end
end

# This error is raised when a git command takes longer than the configured timeout
#
# The git command executed, status, stdout, and stderr, and the timeout duration
# are available from this object.
#
# result.status.timeout? will be `true`
#
# @api public
#
# source://git//lib/git/errors.rb#149
class Git::TimeoutError < ::Git::SignaledError
  # Create a TimeoutError object
  #
  # @api public
  # @example
  #   command = %w[sleep 10]
  #   timeout_duration = 1
  #   status = ProcessExecuter.spawn(*command, timeout: timeout_duration)
  #   result = Git::CommandLineResult.new(command, status, 'stdout', 'err output')
  #   error = Git::TimeoutError.new(result, timeout_duration)
  #   error.error_message #=> '["sleep", "10"], status: pid 70144 SIGKILL (signal 9), stderr: "err output", timed out after 1s'
  # @param result [Git::CommandLineResult] the result of the git command including
  #   the git command, status, stdout, and stderr
  # @param timeout_duration [Numeric] the amount of time the subprocess was allowed
  #   to run before being killed
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://git//lib/git/errors.rb#166
  def initialize(result, timeout_duration); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message #=> '["sleep", "10"], status: pid 88811 SIGKILL (signal 9), stderr: "err output", timed out after 1s'
  # @return [String]
  #
  # source://git//lib/git/errors.rb#178
  def error_message; end

  # The amount of time the subprocess was allowed to run before being killed
  #
  # @api public
  # @example
  #   `kill -9 $$` # set $? appropriately for this example
  #   result = Git::CommandLineResult.new(%w[git status], $?, '', "killed")
  #   error = Git::TimeoutError.new(result, 10)
  #   error.timeout_duration #=> 10
  # @return [Numeric]
  #
  # source://git//lib/git/errors.rb#192
  def timeout_duration; end
end

# Methods for parsing a Git URL
#
# Any URL that can be passed to `git clone` can be parsed by this class.
#
# @api public
# @see https://git-scm.com/docs/git-clone#_git_urls GIT URLs
# @see https://github.com/sporkmonger/addressable Addresable::URI
#
# source://git//lib/git/url.rb#15
class Git::URL
  class << self
    # The directory `git clone` would use for the repository directory for the given URL
    #
    # @api public
    # @example
    #   Git::URL.clone_to('https://github.com/ruby-git/ruby-git.git') #=> 'ruby-git'
    # @param url [String] the Git URL containing the repository directory
    # @return [String] the name of the repository directory
    #
    # source://git//lib/git/url.rb#64
    def clone_to(url, bare: T.unsafe(nil), mirror: T.unsafe(nil)); end

    # Parse a Git URL and return an Addressable::URI object
    #
    # The URI returned can be converted back to a string with 'to_s'. This is
    # guaranteed to return the same URL string that was parsed.
    #
    # @api public
    # @example
    #   uri = Git::URL.parse('https://github.com/ruby-git/ruby-git.git')
    #   #=> #<Addressable::URI:0x44c URI:https://github.com/ruby-git/ruby-git.git>
    #   uri.scheme #=> "https"
    #   uri.host #=> "github.com"
    #   uri.path #=> "/ruby-git/ruby-git.git"
    #
    #   Git::URL.parse('/Users/James/projects/ruby-git')
    #   #=> #<Addressable::URI:0x438 URI:/Users/James/projects/ruby-git>
    # @param url [String] the Git URL to parse
    # @return [Addressable::URI] the parsed URI
    #
    # source://git//lib/git/url.rb#47
    def parse(url); end
  end
end

# Regexp used to match a Git URL with an alternative SSH syntax
# such as `user@host:path`
#
# @api public
#
# source://git//lib/git/url.rb#19
Git::URL::GIT_ALTERNATIVE_SSH_SYNTAX = T.let(T.unsafe(nil), Regexp)

# Raised when the git command result was not as expected
#
# @api public
#
# source://git//lib/git/errors.rb#205
class Git::UnexpectedResultError < ::Git::Error; end

# The current gem version
#
# @return [String] the current gem version.
#
# source://git//lib/git/version.rb#6
Git::VERSION = T.let(T.unsafe(nil), String)

# source://git//lib/git/working_directory.rb#4
class Git::WorkingDirectory < ::Git::Path; end

# source://git//lib/git/worktree.rb#7
class Git::Worktree < ::Git::Path
  # @return [Worktree] a new instance of Worktree
  #
  # source://git//lib/git/worktree.rb#11
  def initialize(base, dir, gcommit = T.unsafe(nil)); end

  # source://git//lib/git/worktree.rb#24
  def add; end

  # Returns the value of attribute dir.
  #
  # source://git//lib/git/worktree.rb#9
  def dir; end

  # Sets the attribute dir
  #
  # @param value the value to set the attribute dir to.
  #
  # source://git//lib/git/worktree.rb#9
  def dir=(_arg0); end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/worktree.rb#9
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/worktree.rb#9
  def full=(_arg0); end

  # Returns the value of attribute gcommit.
  #
  # source://git//lib/git/worktree.rb#19
  def gcommit; end

  # Sets the attribute gcommit
  #
  # @param value the value to set the attribute gcommit to.
  #
  # source://git//lib/git/worktree.rb#9
  def gcommit=(_arg0); end

  # source://git//lib/git/worktree.rb#28
  def remove; end

  # source://git//lib/git/worktree.rb#32
  def to_a; end

  # source://git//lib/git/worktree.rb#36
  def to_s; end
end

# object that holds all the available worktrees
#
# source://git//lib/git/worktrees.rb#5
class Git::Worktrees
  include ::Enumerable

  # @return [Worktrees] a new instance of Worktrees
  #
  # source://git//lib/git/worktrees.rb#9
  def initialize(base); end

  # source://git//lib/git/worktrees.rb#30
  def [](worktree_name); end

  # source://git//lib/git/worktrees.rb#26
  def each(&block); end

  # source://git//lib/git/worktrees.rb#45
  def prune; end

  # array like methods
  #
  # source://git//lib/git/worktrees.rb#22
  def size; end

  # source://git//lib/git/worktrees.rb#37
  def to_s; end
end

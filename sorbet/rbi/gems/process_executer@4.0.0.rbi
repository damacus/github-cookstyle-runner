# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `process_executer` gem.
# Please instead update this file by running `bin/tapioca gem process_executer`.


# The {ProcessExecuter} module provides extended versions of
# [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn) that
# block while the command is executing. These methods provide enhanced features such
# as timeout handling, more flexible redirection options, logging, error raising, and
# output capturing.
#
# The interface of these methods is the same as the standard library
# [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
# method, but with additional options and features.
#
# These methods are:
#
# * {spawn_with_timeout}: Extends
#   [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn) to
#   run a command and wait (with timeout) for it to finish
# * {run}: Extends {ProcessExecuter.spawn_with_timeout}, adding more flexible
#   redirection and other options
# * {run_with_capture}: Extends {ProcessExecuter.run}, automatically captures stdout and stderr
#
# See the {ProcessExecuter::Error} class for the error architecture for this module.
#
# @api public
#
# source://process_executer//lib/process_executer.rb#25
module ProcessExecuter
  class << self
    # Extends {spawn_with_timeout}, adding more flexible redirection and other options
    #
    # Accepts all [Process.spawn execution
    # options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options),
    # the additional options defined by {spawn_with_timeout}, and the additional
    # options `raise_errors` and `logger`:
    #
    # * `raise_errors: <Boolean>` makes execution errors an exception if true (default
    #   is `true`)
    # * `logger: <Logger>` logs the command and its result at `:info` level using the
    #   given logger (default is not to log)
    #
    # Internally, this method wraps stdout and stderr redirection options in a
    # {MonitoredPipe}, enabling more flexible output handling. It allows any object
    # that responds to `#write` to be used as a destination and supports multiple
    # destinations using the form `[:tee, destination, ...]`.
    #
    # When the command exits with a non-zero exit status or does not exit normally, one
    # of the following errors will be raised unless the option `raise_errors: false` is
    # explicitly given:
    #
    # * {ProcessExecuter::FailedError} if the command returns a non-zero exitstatus
    # * {ProcessExecuter::SignaledError} if the command exits because of an unhandled
    #   signal
    # * {ProcessExecuter::TimeoutError} if the command times out
    #
    # These errors all have a {CommandError#result result} attribute that contains the
    # {ProcessExecuter::Result} object for this command.
    #
    # If `raise_errors: false` is given and there was an error, the returned
    # {ProcessExecuter::Result} object indicates what the error is via its
    # [success?](https://docs.ruby-lang.org/en/3.4/Process/Status.html#method-i-success-3F),
    # [signaled?](https://docs.ruby-lang.org/en/3.4/Process/Status.html#method-i-signaled-3F),
    # or {Result#timed_out? timed_out?} attributes.
    #
    # A {ProcessExecuter::ProcessIOError} is raised if an exception occurs while
    # collecting subprocess output.
    #
    # Giving the option `raise_errors: false` will not suppress
    # {ProcessExecuter::ProcessIOError}, {ProcessExecuter::SpawnError}, or
    # {ProcessExecuter::ArgumentError} errors.
    #
    # @api public
    # @example capture stdout to a StringIO buffer
    #   out_buffer = StringIO.new
    #   result = ProcessExecuter.run('echo HELLO', out: out_buffer)
    #   out_buffer.string #=> "HELLO\n"
    # @example with :raise_errors set to true
    #   begin
    #   result = ProcessExecuter.run('exit 1', raise_errors: true)
    #   rescue ProcessExecuter::FailedError => e
    #   e.result.exitstatus #=> 1
    #   end
    # @example with :raise_errors set to false
    #   result = ProcessExecuter.run('exit 1', raise_errors: false)
    #   result.exitstatus #=> 1
    # @example with a logger
    #   logger_buffer = StringIO.new
    #   logger = Logger.new(logger_buffer, level: :info)
    #   result = ProcessExecuter.run('echo HELLO', logger: logger)
    #   logger_buffer.string #=> "INFO -- : PID 5555: [\"echo HELLO\"] exited with status pid 5555 exit 0\n"
    # @overload run
    # @overload run
    # @raise [ProcessExecuter::ArgumentError] If the command or an option is not valid
    #
    #   Raised if an invalid option key or value is given, or both an options object
    #   and options_hash are given.
    # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
    #   command was run
    #
    #   Raised if the
    #   [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
    #   method raises an error before the command is run.
    # @raise [ProcessExecuter::FailedError] If the command ran and failed
    # @raise [ProcessExecuter::SignaledError] If the command ran and terminated due to
    #   an unhandled signal
    # @raise [ProcessExecuter::TimeoutError] If the command timed out
    # @raise [ProcessExecuter::ProcessIOError] If there was an exception while
    #   collecting subprocess output
    # @return [ProcessExecuter::Result]
    #
    # source://process_executer//lib/process_executer.rb#252
    def run(*command, **options_hash); end

    # Extends {run}, automatically capturing stdout and stderr
    #
    # Accepts all [Process.spawn execution
    # options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options),
    # the additional options defined by {spawn_with_timeout} and {run}, and the
    # additional options `merge_output`, `encoding`, `stdout_encoding`, and
    # `stderr_encoding`:
    #
    # * `merge_output: <Boolean>` if true merges stdout and stderr into a single
    #   capture buffer (default is false)
    #   (default is `Encoding::UTF_8`)
    #   not nil, overrides the `encoding` option for stdout (default is nil)
    #   not nil, overrides the `encoding` option for stderr (default is nil)
    #
    # The captured output is accessed in the returned object's `#stdout` and `#stderr`
    # methods. Merged output (if the `merged_output: true` option is given) is accessed
    # in the `#stdout` method.
    #
    # stdout and stderr redirection destinations may be given by the user (e.g. `out:
    # <destination>` or `err: <destination>`). These redirections will receive the
    # output in addition to the internal capture.
    #
    # Unless told otherwise, the internally captured output is assumed to be in UTF-8
    # encoding. This assumption can be changed with the `encoding`,
    # `stdout_encoding`, or `stderr_encoding` options. These options accept any
    # encoding objects returned by `Encoding.list` or their String equivalent given by
    # `#to_s`.
    #
    # The bytes captured are not transcoded. They are interpreted as being in the
    # specified encoding. The user will have to check the validity of the
    # encoding by calling `#valid_encoding?` on the captured output (e.g.,
    # `result.stdout.valid_encoding?`).
    #
    # A `ProcessExecuter::ArgumentError` will be raised if both an options object and
    # an options_hash are given.
    #
    # @api public
    # @example capture stdout and stderr
    #   result =
    #   ProcessExecuter.run_with_capture('echo HELLO; echo ERROR >&2')
    #   result.stdout #=> "HELLO\n" result.stderr #=> "ERROR\n"
    # @example merge stdout and stderr
    #   result = ProcessExecuter.run_with_capture('echo HELLO; echo ERROR >&2', merge_output: true)
    #   # order of output is not guaranteed
    #   result.stdout #=> "HELLO\nERROR\n" result.stderr #=> ""
    # @example default encoding
    #   result = ProcessExecuter.run_with_capture('echo HELLO')
    #   result.stdout #=> "HELLO\n"
    #   result.stdout.encoding #=> #<Encoding:UTF-8>
    #   result.stdout.valid_encoding? #=> true
    # @example custom encoding
    #   result = ProcessExecuter.run_with_capture('echo HELLO', encoding: Encoding::ISO_8859_1)
    #   result.stdout #=> "HELLO\n"
    #   result.stdout.encoding #=> #<Encoding:ISO-8859-1>
    #   result.stdout.valid_encoding? #=> true
    # @example custom encoding with invalid bytes
    #   File.binwrite('output.txt', "\xFF\xFE") # little-endian BOM marker is not valid UTF-8
    #   result = ProcessExecuter.run_with_capture('cat output.txt')
    #   result.stdout #=> "\xFF\xFE"
    #   result.stdout.encoding #=> #<Encoding:UTF-8>
    #   result.stdout.valid_encoding? #=> false
    # @overload run_with_capture
    # @overload run_with_capture
    # @raise [ProcessExecuter::ArgumentError] If the command or an option is not valid
    #
    #   Raised if an invalid option key or value is given, or both an options object
    #   and options_hash are given.
    # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
    #   command was run
    #
    #   Raised if the
    #   [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
    #   method raises an error before the command is run.
    # @raise [ProcessExecuter::FailedError] If the command ran and failed
    # @raise [ProcessExecuter::SignaledError] If the command ran and terminated due to
    #   an unhandled signal
    # @raise [ProcessExecuter::TimeoutError] If the command timed out
    # @raise [ProcessExecuter::ProcessIOError] If there was an exception while
    #   collecting subprocess output
    # @return [ProcessExecuter::ResultWithCapture] Where `#stdout` and `#stderr` are strings whose encoding is determined by the
    #   `:encoding`, `:stdout_encoding`, or `:stderr_encoding` options.
    #
    # source://process_executer//lib/process_executer.rb#400
    def run_with_capture(*command, **options_hash); end

    # Extends `Process.spawn` to run command and wait (with timeout) for it to finish
    #
    # Accepts all [Process.spawn execution
    # options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options)
    # and the additional option `timeout_after`:
    #
    # * `timeout_after: <Numeric, nil>`: the amount of time (in seconds) to wait before
    #   signaling the process with SIGKILL. 0 or nil means no timeout.
    #
    # Returns a {Result} object. The {Result} class is a decorator for
    # [Process::Status](https://docs.ruby-lang.org/en/3.4/Process/Status.html) that
    # provides additional attributes about the command's status. This includes the
    # {Result#command command} that was run, the {Result#options options} used to run
    # it, {Result#elapsed_time elapsed_time} of the command, and whether the command
    # {Result#timed_out? timed_out?}.
    #
    # @api public
    # @example command line given as a single string
    #   result = ProcessExecuter.spawn_with_timeout('echo "3\n2\n1" | sort')
    #   result.exited? # => true
    #   result.success? # => true
    #   result.exitstatus # => 0
    #   result.timed_out? # => false
    # @example command given as an exe_path and args
    #   result = ProcessExecuter.spawn_with_timeout('ping', '-c', '1', 'localhost')
    # @example with a timeout
    #   result = ProcessExecuter.spawn_with_timeout('sleep 10', timeout_after: 0.01)
    #   result.exited? # => false
    #   result.success? # => nil
    #   result.signaled? # => true
    #   result.termsig # => 9
    #   result.timed_out? # => true
    # @example with a env hash
    #   env = { 'EXITSTATUS' => '1' }
    #   result = ProcessExecuter.spawn_with_timeout(env, 'exit $EXITSTATUS')
    #   result.success? # => false
    #   result.exitstatus # => 1
    # @example capture stdout to a StringIO buffer
    #   stdout_buffer = StringIO.new
    #   stdout_pipe = ProcessExecuter::MonitoredPipe.new(stdout_buffer)
    #   begin
    #   result = ProcessExecuter.spawn_with_timeout('echo "3\n2\n1" | sort', out: stdout_pipe)
    #   stdout_buffer.string # => "1\n2\n3\n"
    #   ensure
    #   stdout_pipe.close
    #   end
    # @overload spawn_with_timeout
    # @overload spawn_with_timeout
    # @raise [ProcessExecuter::ArgumentError] If the command or an option is not valid
    #
    #   Raised if an invalid option key or value is given, or both an options object
    #   and options_hash are given.
    # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
    #   command was run
    #
    #   Raised if the
    #   [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
    #   method raises an error before the command is run.
    # @return [ProcessExecuter::Result]
    #
    # source://process_executer//lib/process_executer.rb#122
    def spawn_with_timeout(*command, **options_hash); end

    private

    # Takes a command and options_hash to determine the options object
    #
    # To support either passing an options object or an options_hash, this method takes
    # a command and an options_hash and returns the command (with the trailing options
    # object removed if one is given) and and options object.
    #
    # @api private
    # @api public
    # @example options hash not empty
    #   command, options = ProcessExecuter.command_and_options(
    #   ProcessExecuter::Options::RunOptions,
    #   ['echo hello'],
    #   { out: $stdout }
    #   )
    #   command #=> ['echo hello']
    #   options #=> a new RunOptions instance initialized with the options hash
    # @example options_hash empty, command DOES NOT end with an options object
    #   command, options = ProcessExecuter.command_and_options(
    #   ProcessExecuter::Options::RunOptions,
    #   ['echo hello'],
    #   {}
    #   )
    #   command #=> ['echo hello']
    #   options #=> a new RunOptions instance initialized with defaults
    # @example options_hash empty, command ends with an options object
    #   command, options = ProcessExecuter.command_and_options(
    #   ProcessExecuter::Options::RunOptions,
    #   ['echo hello', ProcessExecuter::Options::RunOptions.new(out: $stdout)],
    #   {}
    #   )
    #   command #=> ['echo hello'] # options object is removed
    #   options #=> the RunOptions object from command[-1]
    # @param options_class [Class] the class of the options object
    # @param command [Array] the command to be executed (possibly with an instance of
    #   options_class at the end)
    # @param options_hash [Hash] the (possibly empty) hash of options
    # @raise [ProcessExecuter::ArgumentError] If both an options object and an
    #   options_hash are given
    # @return [Array] An array containing two elements: the command and an options object
    #
    #   The command is an array of strings and the options is an instance of the
    #   specified options_class.
    #
    # source://process_executer//lib/process_executer.rb#455
    def command_and_options(options_class, command, options_hash); end
  end
end

# Raised when an invalid argument is passed to a method
#
# @api public
# @example Raising ProcessExecuter::ArgumentError due to invalid option value
#   begin
#   ProcessExecuter.run('echo Hello', timeout_after: 'not_a_number')
#   rescue ProcessExecuter::ArgumentError => e
#   e.message #=> 'timeout_after must be nil or a non-negative real number but was "not_a_number"'
#   end
#
# source://process_executer//lib/process_executer/errors.rb#70
class ProcessExecuter::ArgumentError < ::ProcessExecuter::Error; end

# Raised when a command fails or exits because of an uncaught signal
#
# The command executed and its result are available from this object.
#
# This gem will raise a more specific error for each type of failure:
#
# * {FailedError}: when the command exits with a non-zero status
# * {SignaledError}: when the command exits because of an uncaught signal
# * {TimeoutError}: when the command times out
#
# @api public
#
# source://process_executer//lib/process_executer/errors.rb#84
class ProcessExecuter::CommandError < ::ProcessExecuter::Error
  # Create a CommandError object
  #
  # @api public
  # @example
  #   `exit 1` # set $? appropriately for this example
  #   result_data = {
  #   command: ['exit 1'],
  #   options: ProcessExecuter::Options::RunOptions.new,
  #   timed_out: false,
  #   elapsed_time: 0.01
  #   }
  #   result = ProcessExecuter::Result.new($?, **result_data)
  #   error = ProcessExecuter::CommandError.new(result)
  #   error.to_s #=> '["exit 1"], status: pid 29686 exit 1'
  # @param result [ProcessExecuter::Result] The result of the command including the
  #   command and exit status
  # @return [CommandError] a new instance of CommandError
  #
  # source://process_executer//lib/process_executer/errors.rb#102
  def initialize(result); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message #=> '["git", "status"], status: pid 89784 exit 1'
  # @return [String]
  #
  # source://process_executer//lib/process_executer/errors.rb#114
  def error_message; end

  # The result of the command including the command, its status and its output
  #
  # @api public
  # @example
  #   error.result #=> #<ProcessExecuter::Result:0x00007f9b1b8b3d20>
  # @return [ProcessExecuter::Result]
  #
  # source://process_executer//lib/process_executer/errors.rb#127
  def result; end
end

# Classes that implement commands for process execution
#
# @api private
#
# source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#6
module ProcessExecuter::Commands; end

# Run a command and return the {ProcessExecuter::Result}
#
# Extends {ProcessExecuter::Commands::SpawnWithTimeout} to provide the core functionality for
# {ProcessExecuter.run}.
#
# It accepts all [Process.spawn execution
# options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options)
# plus the additional options `timeout_after`, `raise_errors` and `logger`.
#
# This class wraps any stdout or stderr redirection destinations in a {MonitoredPipe}.
# This allows any class that implements `#write` to be used as an output redirection
# destination. This means that you can redirect to a StringIO which is not possible
# with `Process.spawn`.
#
# @api private
#
# source://process_executer//lib/process_executer/commands/run.rb#24
class ProcessExecuter::Commands::Run < ::ProcessExecuter::Commands::SpawnWithTimeout
  # Run a command and return the result
  #
  # Wrap the stdout and stderr redirection destinations in pipes and then execute
  # the command.
  #
  # @api private
  # @example
  #   options = ProcessExecuter::Options::RunOptions.new(raise_errors: true)
  #   result = ProcessExecuter::Commands::Run.new('echo hello', options).call
  #   result.success? # => true
  #   result.exitstatus # => 0
  # @raise [ProcessExecuter::FailedError] If the command ran and failed
  # @raise [ProcessExecuter::TimeoutError] If the command timed out
  # @raise [ProcessExecuter::ProcessIOError] If there was an exception while
  #   collecting subprocess output
  # @raise [ProcessExecuter::SignaledError] If the command ran and terminated due to
  #   an unhandled signal
  # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
  #   command was run
  # @return [ProcessExecuter::Result] The result of the completed subprocess
  #
  # source://process_executer//lib/process_executer/commands/run.rb#51
  def call; end

  private

  # Log the result of running the command
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/commands/run.rb#100
  def log_result; end

  # Raise an error if the command failed
  #
  # @api private
  # @raise [ProcessExecuter::FailedError] If the command ran and failed
  # @raise [ProcessExecuter::SignaledError] If the command ran and terminated due to an unhandled signal
  # @raise [ProcessExecuter::TimeoutError] If the command timed out
  # @return [void]
  #
  # source://process_executer//lib/process_executer/commands/run.rb#92
  def raise_errors; end

  # Raises a ProcessIOError if the given pipe has a recorded exception
  #
  # @api private
  # @param option_key [Object] The redirection option key
  #
  #   For example, `:out`, or an Array like `[:out, :err]` for merged streams.
  # @param pipe [ProcessExecuter::MonitoredPipe] The pipe that raised the exception
  # @raise [ProcessExecuter::ProcessIOError] If there was an exception while collecting subprocess output
  # @return [void]
  #
  # source://process_executer//lib/process_executer/commands/run.rb#116
  def raise_pipe_error(option_key, pipe); end

  # Should the redirection option be wrapped by a MonitoredPipe
  #
  # @api private
  # @param key [Object] The option key
  # @param value [Object] The option value
  # @return [Boolean] Whether the option should be wrapped
  #
  # source://process_executer//lib/process_executer/commands/run.rb#82
  def should_wrap?(key, value); end

  # Wrap the stdout and stderr redirection options with a MonitoredPipe
  #
  # @api private
  # @return [Hash<Object, ProcessExecuter::MonitoredPipe>] The opened pipes (the Object is the option key)
  #
  # source://process_executer//lib/process_executer/commands/run.rb#66
  def wrap_stdout_stderr; end
end

# Runs a subprocess, blocks until it completes, and returns the result
#
# Extends {ProcessExecuter::Commands::Run} to provide the core functionality for
# {ProcessExecuter.run_with_capture}.
#
# It accepts all [Process.spawn execution
# options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options)
# plus the additional options `timeout_after`, `raise_errors`, `logger`, and
# `merge_output`.
#
# Like {Run}, any stdout or stderr redirection destinations are wrapped in a
# {MonitoredPipe}.
#
# @api private
#
# source://process_executer//lib/process_executer/commands/run_with_capture.rb#22
class ProcessExecuter::Commands::RunWithCapture < ::ProcessExecuter::Commands::Run
  # Run a command and return the result which includes the captured output
  #
  # @api private
  # @example
  #   options = ProcessExecuter::Options::RunWithCaptureOptions.new(merge_output: false)
  #   result = ProcessExecuter::Commands::RunWithCapture.new('echo hello', options).call
  #   result.success? # => true
  #   result.exitstatus # => 0
  #   result.stdout # => "hello\n"
  # @raise [ProcessExecuter::FailedError] If the command ran and failed
  # @raise [ProcessExecuter::TimeoutError] If the command timed out
  # @raise [ProcessExecuter::ProcessIOError] If there was an exception while
  #   collecting subprocess output
  # @raise [ProcessExecuter::SignaledError] If the command ran and terminated due to
  #   an unhandled signal
  # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
  #   command was run
  # @return [ProcessExecuter::ResultWithCapture] The result of the completed subprocess
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#47
  def call; end

  # The buffer used to capture stderr
  #
  # @api private
  # @example
  #   run.stderr_buffer #=> StringIO
  # @return [StringIO]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#78
  def stderr_buffer; end

  # The buffer used to capture stdout
  #
  # @api private
  # @example
  #   run.stdout_buffer #=> StringIO
  # @return [StringIO]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#69
  def stdout_buffer; end

  private

  # Add the capture redirection to existing options (if any)
  #
  # @api private
  # @param redirection_source [Symbol, Integer] The source of the redirection (e.g., :out, :err)
  # @param given_source [Symbol, Integer, nil] The source provided by the user (if any)
  # @param given_destination [Object, nil] The destination provided by the user (if any)
  # @param capture_destination [Object] The additional destination to capture output to
  # @return [Hash] The option (including the capture_destination) to merge into options
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#128
  def capture_option(redirection_source, given_source, given_destination, capture_destination); end

  # Create a result object that includes the captured stdout and stderr
  #
  # @api private
  # @return [ProcessExecuter::ResultWithCapture] The result of the command with captured output
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#86
  def create_result; end

  # Log the captured command output to the given logger at debug level
  #
  # @api private
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#142
  def log_command_output; end

  # The destination for stderr redirection
  #
  # @api private
  # @return [Object]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#120
  def stderr_redirection_destination; end

  # The source for stderr redirection
  #
  # @api private
  # @return [Object]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#112
  def stderr_redirection_source; end

  # The destination for stdout redirection
  #
  # @api private
  # @return [Object]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#116
  def stdout_redirection_destination; end

  # The source for stdout redirection
  #
  # @api private
  # @return [Object]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#108
  def stdout_redirection_source; end

  # Updates {options} to include the stdout and stderr capture options
  #
  # @api private
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/commands/run_with_capture.rb#96
  def update_capture_options; end
end

# Spawns a subprocess, waits until it completes, and returns the result
#
# Wraps `Process.spawn` to provide the core functionality for
# {ProcessExecuter.spawn_with_timeout}.
#
# It accepts all [Process.spawn execution
# options](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-Execution+Options)
# plus the additional option `timeout_after`.
#
# @api private
#
# source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#18
class ProcessExecuter::Commands::SpawnWithTimeout
  # Create a new SpawnWithTimeout instance
  #
  # @api private
  # @example
  #   options = ProcessExecuter::Options::SpawnWithTimeoutOptions.new(timeout_after: 5)
  #   result = ProcessExecuter::Commands::SpawnWithTimeout.new('echo hello', options).call
  #   result.success? # => true
  #   result.exitstatus # => 0
  # @param command [Array<String>] The command to run in the subprocess
  # @param options [ProcessExecuter::Options::SpawnWithTimeoutOptions] The options to use when spawning the process
  # @return [SpawnWithTimeout] a new instance of SpawnWithTimeout
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#30
  def initialize(command, options); end

  # Run a command and return the result
  #
  # @api private
  # @example
  #   options = ProcessExecuter::Options::SpawnWithTimeoutOptions.new(timeout_after: 5)
  #   result = ProcessExecuter::Commands::SpawnWithTimeout.new('echo hello', options).call
  #   result.success? # => true
  #   result.exitstatus # => 0
  #   result.timed_out? # => false
  # @raise [ProcessExecuter::SpawnError] `Process.spawn` raised an error before the
  #   command was run
  # @return [ProcessExecuter::Result] The result of the completed subprocess
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#49
  def call; end

  # The command to be run in the subprocess
  #
  # @api private
  # @example
  #   spawn.command #=> ['echo', 'hello']
  # @return [Array<String>]
  # @see Process.spawn
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#64
  def command; end

  # The elapsed time in seconds that the command ran
  #
  # @api private
  # @example
  #   spawn.elapsed_time #=> 1.234
  # @return [Numeric]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#108
  def elapsed_time; end

  # The options that were used to spawn the process
  #
  # @api private
  # @example
  #   spawn.options #=> ProcessExecuter::Options::SpawnWithTimeoutOptions
  # @return [ProcessExecuter::Options::SpawnWithTimeoutOptions]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#70
  def options; end

  # The process ID of the spawned subprocess
  #
  # @api private
  # @example
  #   spawn.pid #=> 12345
  # @return [Integer]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#79
  def pid; end

  # The result of the completed subprocess
  #
  # @api private
  # @example
  #   spawn.result #=> ProcessExecuter::Result
  # @return [ProcessExecuter::Result]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#117
  def result; end

  # The status returned by Process.wait2
  #
  # @api private
  # @example
  #   spawn.status #=> #<Process::Status: pid 12345 exit 0>
  # @return [Process::Status]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#88
  def status; end

  # Whether the process timed out
  #
  # @api private
  # @example
  #   spawn.timed_out? #=> true
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#97
  def timed_out; end

  # Whether the process timed out
  #
  # @api private
  # @example
  #   spawn.timed_out? #=> true
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#97
  def timed_out?; end

  private

  # Create a result object that includes the status, command, and other details
  #
  # @api private
  # @return [ProcessExecuter::Result] The result of the command
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#139
  def create_result; end

  # Wait for process to terminate
  #
  # If a `:timeout_after` is specified in options, terminate the process after the
  # specified number of seconds.
  #
  # @api private
  # @return [ProcessExecuter::Result] The result of the completed subprocess
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#128
  def wait_for_process; end

  # Wait for a process to terminate returning the status and timed out flag
  #
  # @api private
  # @return [Array<Process::Status, Boolean>] an array containing the process status and a boolean
  #   indicating whether the process timed out
  #
  # source://process_executer//lib/process_executer/commands/spawn_with_timeout.rb#147
  def wait_for_process_raw; end
end

# Collection of destination handler implementations
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/destination_base.rb#4
module ProcessExecuter::Destinations
  class << self
    # Determines if the given destination type can be managed by a {MonitoredPipe}
    #
    # Returns true if {MonitoredPipe} can forward data to this destination type.
    #
    # Returns false otherwise (e.g., for destinations like :close or [:child, fd]
    # which have special meaning to Process.spawn and are not simply data sinks for
    # {MonitoredPipe}).
    #
    # @api private
    # @example
    #   ProcessExecuter::Destinations.compatible_with_monitored_pipe?(1)
    #   #=> true
    #   ProcessExecuter::Destinations.compatible_with_monitored_pipe?([:child, 6])
    #   #=> false
    #   ProcessExecuter::Destinations.compatible_with_monitored_pipe?(:close)
    #   #=> false
    # @param destination [Object] the destination to check
    # @return [Boolean] true if {MonitoredPipe} can forward data to this destination type
    #
    # source://process_executer//lib/process_executer/destinations.rb#64
    def compatible_with_monitored_pipe?(destination); end

    # Creates appropriate destination objects based on the given destination
    #
    # This factory method dynamically finds and instantiates the appropriate
    # destination class for handling the provided destination.
    #
    # @api private
    # @example
    #   ProcessExecuter::Destinations.factory(1) #=> Returns a Stdout instance
    #   ProcessExecuter::Destinations.factory("output.log") #=> Returns a FilePath instance
    # @param destination [Object] the destination to create a handler for
    # @raise [ProcessExecuter::ArgumentError] if no matching destination class is found
    # @return [ProcessExecuter::Destinations::DestinationBase] an instance of the
    #   appropriate destination handler
    #
    # source://process_executer//lib/process_executer/destinations.rb#37
    def factory(destination); end

    # Determines the destination class that can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Class, nil] the handler class for the given destination or `nil` if no match
    #
    # source://process_executer//lib/process_executer/destinations.rb#75
    def matching_destination_class(destination); end
  end
end

# Handles [:child, fd] redirection options as supported by `Process.spawn`
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/child_redirection.rb#10
class ProcessExecuter::Destinations::ChildRedirection < ::ProcessExecuter::Destinations::DestinationBase
  class << self
    # This class should not be wrapped in a monitored pipe
    #
    # @api private
    # @return [Boolean]
    #
    # source://process_executer//lib/process_executer/destinations/child_redirection.rb#21
    def compatible_with_monitored_pipe?; end

    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if the destination is an array in the format [:child, file_descriptor]
    #
    # source://process_executer//lib/process_executer/destinations/child_redirection.rb#15
    def handles?(destination); end
  end
end

# Base class for all destination handlers
#
# Provides the common interface and functionality for all destination
# classes that handle different types of output redirection.
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/destination_base.rb#11
class ProcessExecuter::Destinations::DestinationBase
  # Initializes a new destination handler
  #
  # @api private
  # @param destination [Object] the destination to write to
  # @return [DestinationBase] a new instance of DestinationBase
  #
  # source://process_executer//lib/process_executer/destinations/destination_base.rb#16
  def initialize(destination); end

  # Closes the destination if necessary
  #
  # By default, this method does nothing. Subclasses should override
  # this method if they need to perform cleanup.
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/destination_base.rb#44
  def close; end

  # Determines if this destination instance can be wrapped by MonitoredPipe
  #
  # @api private
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/destinations/destination_base.rb#68
  def compatible_with_monitored_pipe?; end

  # The destination object this handler manages
  #
  # @api private
  # @return [Object] the destination object
  #
  # source://process_executer//lib/process_executer/destinations/destination_base.rb#23
  def destination; end

  # Writes data to the destination
  #
  # Subclasses should override this method to provide specific write behavior.
  # The base implementation is a no-op.
  #
  # @api private
  # @param _data [String] the data to write
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/destination_base.rb#34
  def write(_data); end

  class << self
    # Determines if this destination class can be wrapped by MonitoredPipe
    #
    # All destination types can be wrapped by MonitoredPipe unless they explicitly
    # opt out.
    #
    # @api private
    # @return [Boolean]
    #
    # source://process_executer//lib/process_executer/destinations/destination_base.rb#63
    def compatible_with_monitored_pipe?; end

    # Determines if this class can handle the given destination
    #
    # This is an abstract class method that must be implemented by subclasses.
    #
    # @api private
    # @param destination [Object] the destination to check
    # @raise [NotImplementedError] if the subclass doesn't implement this method
    # @return [Boolean] true if this class can handle the destination
    #
    # source://process_executer//lib/process_executer/destinations/destination_base.rb#53
    def handles?(destination); end
  end
end

# Handles numeric file descriptors
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/file_descriptor.rb#10
class ProcessExecuter::Destinations::FileDescriptor < ::ProcessExecuter::Destinations::DestinationBase
  # Writes data to the file descriptor
  #
  # @api private
  # @example
  #   fd_handler = ProcessExecuter::Destinations::FileDescriptor.new(3)
  #   fd_handler.write("Hello world")
  # @param data [String] the data to write
  # @raise [SystemCallError] if the file descriptor is invalid
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/file_descriptor.rb#23
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is a file descriptor that's not stdout or stderr
    #
    # source://process_executer//lib/process_executer/destinations/file_descriptor.rb#35
    def handles?(destination); end
  end
end

# Handles file path destinations
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/file_path.rb#10
class ProcessExecuter::Destinations::FilePath < ::ProcessExecuter::Destinations::DestinationBase
  # Initializes a new file path destination handler
  #
  # Redirects to the file at destination via `open(destination, 'w', 0644)`
  #
  # @api private
  # @param destination [String] the file path to write to
  # @raise [Errno::ENOENT] if the file path is invalid
  # @return [FilePath] a new instance of FilePath
  #
  # source://process_executer//lib/process_executer/destinations/file_path.rb#19
  def initialize(destination); end

  # Closes the file if it's open
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/file_path.rb#49
  def close; end

  # The opened file object
  #
  # @api private
  # @return [File] the opened file
  #
  # source://process_executer//lib/process_executer/destinations/file_path.rb#27
  def file; end

  # Writes data to the file
  #
  # @api private
  # @example
  #   file_handler = ProcessExecuter::Destinations::FilePath.new("output.log")
  #   file_handler.write("Log entry")
  # @param data [String] the data to write
  # @raise [IOError] if the file is closed
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/file_path.rb#41
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is a String
    #
    # source://process_executer//lib/process_executer/destinations/file_path.rb#57
    def handles?(destination); end
  end
end

# Handles file paths with specific open modes
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/file_path_mode.rb#10
class ProcessExecuter::Destinations::FilePathMode < ::ProcessExecuter::Destinations::DestinationBase
  # Initializes a new file path with mode destination handler
  #
  # Redirects to the file at destination via `open(destination[0], destination[1], 0644)`
  #
  # @api private
  # @param destination [Array<String, String>] array with file path and mode
  # @raise [Errno::ENOENT] if the file path is invalid
  # @raise [ArgumentError] if the mode is invalid
  # @return [FilePathMode] a new instance of FilePathMode
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode.rb#18
  def initialize(destination); end

  # Closes the file if it's open
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode.rb#48
  def close; end

  # The opened file object
  #
  # @api private
  # @return [File] the opened file
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode.rb#26
  def file; end

  # Writes data to the file
  #
  # @api private
  # @example
  #   mode_handler = ProcessExecuter::Destinations::FilePathMode.new(["output.log", "a"])
  #   mode_handler.write("Appended log entry")
  # @param data [String] the data to write
  # @raise [IOError] if the file is closed
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode.rb#40
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is an Array with path and mode
    #
    # source://process_executer//lib/process_executer/destinations/file_path_mode.rb#56
    def handles?(destination); end
  end
end

# Handles file paths with specific open modes and permissions
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#10
class ProcessExecuter::Destinations::FilePathModePerms < ::ProcessExecuter::Destinations::DestinationBase
  # Initializes a new file path with mode and permissions destination handler
  #
  # Opens the file at the given path with the specified mode and permissions.
  #
  # @api private
  # @param destination [Array<String, String, Integer>] array with file path, mode, and permissions
  # @raise [Errno::ENOENT] if the file path is invalid
  # @raise [ArgumentError] if the mode is invalid
  # @return [FilePathModePerms] a new instance of FilePathModePerms
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#21
  def initialize(destination); end

  # Closes the file if it's open
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#51
  def close; end

  # The opened file object
  #
  # @api private
  # @return [File] the opened file
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#29
  def file; end

  # Writes data to the file
  #
  # @api private
  # @example
  #   perms_handler = ProcessExecuter::Destinations::FilePathModePerms.new(["output.log", "w", 0644])
  #   perms_handler.write("Log entry with specific permissions")
  # @param data [String] the data to write
  # @raise [IOError] if the file is closed
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#43
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is an Array with path, mode, and permissions
    #
    # source://process_executer//lib/process_executer/destinations/file_path_mode_perms.rb#59
    def handles?(destination); end
  end
end

# Handles IO objects
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/io.rb#10
class ProcessExecuter::Destinations::IO < ::ProcessExecuter::Destinations::DestinationBase
  # Writes data to the IO object
  #
  # @api private
  # @example
  #   io = File.open('file.txt', 'w')
  #   io_handler = ProcessExecuter::Destinations::IO.new(io)
  #   io_handler.write("Hello world")
  # @param data [String] the data to write
  # @raise [IOError] if the IO object is closed
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/io.rb#24
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is an IO with a valid file descriptor
    #
    # source://process_executer//lib/process_executer/destinations/io.rb#33
    def handles?(destination); end
  end
end

# Handles monitored pipes
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/monitored_pipe.rb#10
class ProcessExecuter::Destinations::MonitoredPipe < ::ProcessExecuter::Destinations::DestinationBase
  # Closes the pipe if it's open
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/monitored_pipe.rb#31
  def close; end

  # Writes data to the monitored pipe
  #
  # @api private
  # @example
  #   stringio_dest = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(stringio_dest)
  #   pipe_handler = ProcessExecuter::Destinations::MonitoredPipe.new(pipe)
  #   pipe_handler.write("Data to pipe")
  # @param data [String] the data to write
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/monitored_pipe.rb#23
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is a ProcessExecuter::MonitoredPipe
    #
    # source://process_executer//lib/process_executer/destinations/monitored_pipe.rb#39
    def handles?(destination); end
  end
end

# Handles standard error redirection
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/stderr.rb#10
class ProcessExecuter::Destinations::Stderr < ::ProcessExecuter::Destinations::DestinationBase
  # Writes data to standard error
  #
  # @api private
  # @example
  #   stderr_handler = ProcessExecuter::Destinations::Stderr.new(:err)
  #   stderr_handler.write("Error message")
  # @param data [String] the data to write
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/stderr.rb#21
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is :err or 2
    #
    # source://process_executer//lib/process_executer/destinations/stderr.rb#30
    def handles?(destination); end
  end
end

# Handles standard output redirection
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/stdout.rb#10
class ProcessExecuter::Destinations::Stdout < ::ProcessExecuter::Destinations::DestinationBase
  # Writes data to standard output
  #
  # @api private
  # @example
  #   stdout_handler = ProcessExecuter::Destinations::Stdout.new(:out)
  #   stdout_handler.write("Hello world")
  # @param data [String] the data to write
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/stdout.rb#21
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is :out or 1
    #
    # source://process_executer//lib/process_executer/destinations/stdout.rb#30
    def handles?(destination); end
  end
end

# Handles a destination for writing to multiple destinations
#
# The destination is an array with the first element being :tee and the rest
# being the destinations.
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/tee.rb#13
class ProcessExecuter::Destinations::Tee < ::ProcessExecuter::Destinations::DestinationBase
  # Initializes a destination handler for writing to multiple output destinations
  #
  # @api private
  # @param destination [Array<Symbol, Object...>] array in the form [:tee, destination...]
  # @raise [ArgumentError] if a child destination is invalid or incompatible
  # @return [Tee] a new instance of Tee
  #
  # source://process_executer//lib/process_executer/destinations/tee.rb#20
  def initialize(destination); end

  # An array of child destinations
  #
  # @api private
  # @return [Array<ProcessExecuter::Destinations::DestinationBase>] An array of the child destination handlers
  #
  # source://process_executer//lib/process_executer/destinations/tee.rb#30
  def child_destinations; end

  # Closes the child_destinations
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/destinations/tee.rb#54
  def close; end

  # Writes data each of the {child_destinations}
  #
  # @api private
  # @example
  #   tee = ProcessExecuter::Destinations::Tee.new([:tee, "output1.log", "output2.log"])
  #   tee.write("Log entry with specific permissions")
  #   tee.close # Important to close the tee to ensure all data is flushed
  # @param data [String] the data to write
  # @raise [IOError] if the file is closed
  # @return [Integer] the number of bytes in the input data (which is written to each destination)
  #
  # source://process_executer//lib/process_executer/destinations/tee.rb#45
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination is an Array in the form [:tee, destination...]
    #
    # source://process_executer//lib/process_executer/destinations/tee.rb#62
    def handles?(destination); end
  end
end

# Handles generic objects that respond to `#write`
#
# @api private
#
# source://process_executer//lib/process_executer/destinations/writer.rb#10
class ProcessExecuter::Destinations::Writer < ::ProcessExecuter::Destinations::DestinationBase
  # Writes data to the destination object
  #
  # @api private
  # @example
  #   buffer = StringIO.new
  #   writer_handler = ProcessExecuter::Destinations::Writer.new(buffer)
  #   writer_handler.write("Hello world")
  # @param data [String] the data to write
  # @return [Integer] the number of bytes written
  #
  # source://process_executer//lib/process_executer/destinations/writer.rb#22
  def write(data); end

  class << self
    # Determines if this class can handle the given destination
    #
    # @api private
    # @param destination [Object] the destination to check
    # @return [Boolean] true if destination responds to #write and is not an IO object with a #fileno
    #
    # source://process_executer//lib/process_executer/destinations/writer.rb#33
    def handles?(destination); end
  end
end

# Base class for all {ProcessExecuter} errors
#
# It is recommended to rescue {ProcessExecuter::Error} to catch any runtime error
# raised by this gem unless you need more specific error handling.
#
# Custom errors are arranged in the following class hierarchy:
#
# ```text
# ::StandardError
#   > Error
#       > ArgumentError
#       > CommandError
#          > FailedError
#          > SignaledError
#              > TimeoutError
#       > ProcessIOError
#       > SpawnError
# ```
#
# | Error Class | Description |
# | --- | --- |
# | `Error` | This catch-all error serves as the base class for other custom errors. |
# | `ArgumentError` | Raised when an invalid argument is passed to a method. |
# | `CommandError` | A subclass of this error is raised when there is a problem executing a command. |
# | `FailedError` | Raised when the command exits with a non-zero exit status. |
# | `SignaledError` | Raised when the command is terminated as a result of receiving a signal. This could happen if the process is forcibly terminated or if there is a serious system error. |
# | `TimeoutError` | This is a specific type of `SignaledError` that is raised when the command times out and is killed via the SIGKILL signal. |
# | `ProcessIOError` | Raised when an error was encountered reading or writing to the command's subprocess. |
# | `SpawnError` | Raised when the process could not execute. Check the `#cause` for the original exception from `Process.spawn`.  |
#
# @api public
# @example Rescuing any error
#   begin
#   ProcessExecuter.run('git', 'status')
#   rescue ProcessExecuter::Error => e
#   puts "An error occurred: #{e.message}"
#   end
# @example Rescuing a timeout error
#   begin
#   timeout_after = 0.1 # seconds
#   ProcessExecuter.run('sleep', '1', timeout_after:)
#   rescue ProcessExecuter::TimeoutError => e # Catch the more specific error first!
#   puts "Command took too long and timed out: #{e}"
#   rescue ProcessExecuter::Error => e
#   puts "Some other error occurred: #{e}"
#   end
#
# source://process_executer//lib/process_executer/errors.rb#55
class ProcessExecuter::Error < ::StandardError; end

# Raised when the command returns a non-zero exit status
#
# @api public
#
# source://process_executer//lib/process_executer/errors.rb#134
class ProcessExecuter::FailedError < ::ProcessExecuter::CommandError; end

# Acts as a pipe that writes the data written to it to one or more destinations
#
# {ProcessExecuter::MonitoredPipe} was created to expand the output redirection
# options for
# [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
# and methods derived from it within the `ProcessExecuter` module.
#
# This class's initializer accepts any redirection destination supported by
# [Process.spawn](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn)
# (this is the `value` part of the file redirection option described in [the File
# Redirection section of
# `Process.spawn`](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-File+Redirection+-28File+Descriptor-29).
#
# In addition to the standard redirection destinations, {ProcessExecuter::MonitoredPipe} also
# supports these additional types of destinations:
#
# - **Arbitrary Writers**
#
#   You can redirect subprocess output to any Ruby object that implements the
#   `#write` method. This is particularly useful for:
#
#     - capturing command output in in-memory buffers like `StringIO`
#     - sending command output to custom logging objects that do not have a file
#       descriptor
#     - processing with a streaming parser to parse and process command output as
#       the command is running
#
# - **Multiple Destinations**
#
#   MonitoredPipe supports duplicating (or "teeing") output to multiple
#   destinations simultaneously. This is achieved by providing a redirection
#   destination in the form `[:tee, destination1, destination2, ...]`, where each
#   `destination` can be any value that `MonitoredPipe` itself supports (including
#   another tee or MonitoredPipe).
#
# When a new MonitoredPipe is created, a pipe is created (via IO.pipe) and
# a thread is created to read data written to the pipe. As data is read from the pipe,
# it is written to the destination provided in the MonitoredPipe initializer.
#
# If the destination raises an exception, the monitoring thread will exit, the
# pipe will be closed, and the exception will be saved in `#exception`.
#
# > ** WARNING**
# >
# > `#close` must be called to ensure that (1) the pipe is closed, (2) all data is
#   read from the pipe and written to the destination, and (3) the monitoring thread is
#   killed.
#
# @api public
# @example Collect pipe data into a StringIO object
#   pipe_data = StringIO.new
#   begin
#   pipe = ProcessExecuter::MonitoredPipe.new(pipe_data)
#   pipe.write("Hello World")
#   ensure
#   pipe.close
#   end
#   pipe_data.string #=> "Hello World"
# @example Collect pipe data into a string AND a file
#   pipe_data_string = StringIO.new
#   pipe_data_file = File.open("pipe_data.txt", "w")
#   begin
#   pipe = ProcessExecuter::MonitoredPipe.new([:tee, pipe_data_string, pipe_data_file])
#   pipe.write("Hello World")
#   ensure
#   pipe.close
#   end
#   pipe_data_string.string #=> "Hello World"
#   # It is your responsibility to close the file you opened
#   pipe_data_file.close
#   File.read("pipe_data.txt") #=> "Hello World"
# @example Using a MonitoredPipe with Process.spawn
#   stdout_buffer = StringIO.new
#   begin
#   stdout_pipe = ProcessExecuter::MonitoredPipe.new(stdout_buffer)
#   pid = Process.spawn('echo Hello World', out: stdout_pipe)
#   _waited_pid, status = Process.wait2(pid)
#   ensure
#   stdout_pipe.close
#   end
#   stdout_buffer.string #=> "Hello World\n"
#
# source://process_executer//lib/process_executer/monitored_pipe.rb#93
class ProcessExecuter::MonitoredPipe
  include ::TrackOpenInstances
  extend ::TrackOpenInstances::ClassMethods

  # Create a new monitored pipe
  #
  # Creates an IO.pipe and starts a monitoring thread to read data written to the
  # pipe.
  #
  # @api public
  # @example
  #   redirection_destination = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(redirection_destination)
  # @param redirection_destination [Object] as data is read from the pipe,
  #   it is written to this destination
  #
  #   Accepts any redirection destination supported by
  #   [`Process.spawn`](https://docs.ruby-lang.org/en/3.4/Process.html#method-c-spawn).
  #   This is the `value` part of the file redirection option described in [the
  #   File Redirection section of
  #   `Process.spawn`](https://docs.ruby-lang.org/en/3.4/Process.html#module-Process-label-File+Redirection+-28File+Descriptor-29).
  #
  #   In addition to the standard redirection destinations, `MonitoredPipe` also
  #   accepts (1) another monitored pipe, (2) any object that implements a `#write` method and
  #   (3) an array in the form `[:tee, destination1, destination2, ...]` where each
  #   `destination` can be any value that `MonitoredPipe` itself supports (including
  #   another tee or MonitoredPipe).
  # @param chunk_size [Integer] the size of the chunks to read from the pipe
  # @return [MonitoredPipe] a new instance of MonitoredPipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#122
  def initialize(redirection_destination, chunk_size: T.unsafe(nil)); end

  # The size of the chunks to read from the pipe
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.chunk_size #=> 100_000
  # @return [Integer] the size of the chunks to read from the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#247
  def chunk_size; end

  # Set the state to `:closing` and wait for the state to be set to `:closed`
  #
  # The monitoring thread will see that the state has changed and will close the pipe.
  #
  # @api public
  # @example
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.state #=> :open
  #   pipe.write('Hello World')
  #   pipe.close
  #   pipe.state #=> :closed
  #   data_collector.string #=> "Hello World"
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#159
  def close; end

  # The redirection destination to write data that is read from the pipe
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.destination #=> #<ProcessExecuter::Destinations::Writer>
  # @return [ProcessExecuter::Destinations::DestinationBase]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#261
  def destination; end

  # The exception raised by a destination
  #
  # If an exception is raised by a destination, it is stored here. Otherwise, it is `nil`.
  #
  # @api public
  # @example
  #   pipe.exception #=> nil
  # @return [Exception, nil] the exception raised by a destination or `nil` if no exception was raised
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#294
  def exception; end

  # The file descriptor for the write end of the pipe
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.fileno == pipe.to_io.fileno #=> true
  # @return [Integer] the file descriptor for the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#205
  def fileno; end

  # The read end of the pipe
  #
  # @api private
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.pipe_reader #=> #<IO:fd 11>
  # @return [IO]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#324
  def pipe_reader; end

  # The write end of the pipe
  #
  # @api private
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.pipe_writer #=> #<IO:fd 12>
  # @return [IO] the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#338
  def pipe_writer; end

  # The state of the pipe
  #
  # Must be either `:open`, `:closing`, or `:closed`
  #
  # * `:open` - the pipe is open and data can be written to it
  # * `:closing` - the pipe is being closed and data can no longer be written to it
  # * `:closed` - the pipe is closed and data can no longer be written to it
  #
  # @api public
  # @example
  #   pipe = ProcessExecuter::MonitoredPipe.new($stdout)
  #   pipe.state #=> :open
  #   pipe.close
  #   pipe.state #=> :closed
  # @return [Symbol] the state of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#281
  def state; end

  # The thread that monitors the pipe
  #
  # @api private
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.thread #=> #<Thread:0x00007f8b1a0b0e00>
  # @return [Thread]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#310
  def thread; end

  # Return the write end of the pipe so that data can be written to it
  #
  # Data written to this end of the pipe will be read by the monitor thread and
  # written to the destination.
  #
  # This is so we can provide a MonitoredPipe to Process.spawn as a FD
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.to_io.write('Hello World')
  #   pipe.close
  #   data_collector.string #=> "Hello World"
  # @return [IO] the write end of the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#189
  def to_io; end

  # Writes data to the pipe so that it can be read by the monitor thread
  #
  # Primarily used for testing.
  #
  # @api public
  # @example
  #   require 'stringio'
  #   data_collector = StringIO.new
  #   pipe = ProcessExecuter::MonitoredPipe.new(data_collector)
  #   pipe.write('Hello World')
  #   pipe.close
  #   data_collector.string #=> "Hello World"
  # @param data [String] the data to write to the pipe
  # @raise [IOError] if the pipe is not open
  # @return [Integer] the number of bytes written to the pipe
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#227
  def write(data); end

  private

  # Raise an error if the destination is not compatible with MonitoredPipe
  #
  # @api private
  # @raise [ArgumentError] if the destination is not compatible with MonitoredPipe
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#368
  def assert_destination_is_compatible_with_monitored_pipe; end

  # Read any remaining data from the pipe and close it
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#438
  def close_pipe; end

  # The condition variable used to synchronize access to the state
  #
  # In particular, it is used while waiting for the state to change to :closed
  #
  # @api private
  # @return [ConditionVariable]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#362
  def condition_variable; end

  # Read data from the pipe until `#state` is changed to `:closing`
  #
  # The state is changed to `:closed` by calling `#close`.
  #
  # Before this method returns, state is set to `:closed`
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#393
  def monitor; end

  # Read data from the pipe until `#state` is changed to `:closing`
  #
  # Data read from the pipe is written to the destination.
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#409
  def monitor_pipe; end

  # The mutex used to synchronize access to the state variable
  #
  # @api private
  # @return [Mutex]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#350
  def mutex; end

  # Start the thread to monitor the pipe and write data to the destination
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#377
  def start_monitoring_thread; end

  # Write the data read from the pipe to the destination
  #
  # If an exception is raised by a writer, set the state to `:closing`
  # so that the pipe can be closed.
  #
  # @api private
  # @param data [String] the data read from the pipe
  # @return [void]
  #
  # source://process_executer//lib/process_executer/monitored_pipe.rb#425
  def write_data(data); end
end

# Options related to spawning or running a command
#
# @api public
#
# source://process_executer//lib/process_executer/options/option_definition.rb#4
module ProcessExecuter::Options; end

# Defines, validates, and holds a set of option values
#
# Options are defined by subclasses by overriding the `define_options` method.
#
# @api public
# @example Define an options class with two options
#   class MyOptions < ProcessExecuter::Options::Base
#   def define_options
#   # Call super to include options defined in the parent class
#   [
#   *super,
#   ProcessExecuter::Options::OptionDefinition.new(
#   :option1, default: '', validator: method(:assert_is_string)
#   ),
#   ProcessExecuter::Options::OptionDefinition.new(
#   :option2, default: '', validator: method(:assert_is_string)
#   ),
#   ProcessExecuter::Options::OptionDefinition.new(
#   :option3, default: '', validator: method(:assert_is_string)
#   )
#   ]
#   end
#   def assert_is_string(key, value)
#   return if value.is_a?(String)
#   errors << "#{key} must be a String but was #{value}"
#   end
#   end
#   options = MyOptions.new(option1: 'value1', option2: 'value2')
#   options.option1 # => 'value1'
#   options.option2 # => 'value2'
# @example invalid option values
#   begin
#   options = MyOptions.new(option1: 1, option2: 2)
#   rescue ProcessExecuter::ArgumentError => e
#   e.message #=> "option1 must be a String but was 1\noption2 must be a String but was 2"
#   end
#
# source://process_executer//lib/process_executer/options/base.rb#45
class ProcessExecuter::Options::Base
  # Create a new Options object
  #
  # Normally you would use a subclass instead of instantiating this class
  # directly.
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  # @example with invalid option values
  #   begin
  #   options = MyOptions.new(option1: 1, option2: 2)
  #   rescue ProcessExecuter::ArgumentError => e
  #   e.message #=> "option1 must be a String but was 1\noption2 must be a String but was 2"
  #   end
  # @param options_hash [Hash] a hash of options
  # @return [Base] a new instance of Base
  #
  # source://process_executer//lib/process_executer/options/base.rb#63
  def initialize(**options_hash); end

  # All the allowed options as a hash whose keys are the option names
  #
  # The returned hash what is returned from `define_options` but with the option
  # names as keys. The values are instances of `OptionDefinition`.
  #
  # The returned hash is frozen and cannot be modified.
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.allowed_options # => {
  #   option1: #<OptionDefinition>,
  #   option2: #<OptionDefinition>
  #   }
  # @return [Hash<Symbol, ProcessExecuter::Options::OptionDefinition>] A hash
  #   where keys are option names and values are their definitions.
  #
  # source://process_executer//lib/process_executer/options/base.rb#88
  def allowed_options; end

  # Iterate over each option with an object
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.each_with_object({}) { |(option_key, option_value), obj| obj[option_key] = option_value }
  #   # => { option1: "value1", option2: "value2" }
  # @return [Object] the obj passed to the block
  # @yield [key_value, obj]
  # @yieldparam key_value [Array<Object, Object>] An array containing the option key and its value
  # @yieldparam obj [Object] The object passed to the block.
  #
  # source://process_executer//lib/process_executer/options/base.rb#146
  def each_with_object(obj, &_arg1); end

  # A string representation of the options
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.inspect # => '{:option1=>"value1", :option2=>"value2"}'
  # @return [String]
  #
  # source://process_executer//lib/process_executer/options/base.rb#115
  def inspect; end

  # Returns a new options object formed by merging self with each of other_hashes
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.object_id # => 1025
  #   h1 = { option2: 'new_value2' }
  #   h2 = { option3: 'value3' }
  #   merged_options = options.merge(h1, h2)
  #   merged_options.object_id # => 1059
  # @param other_options_hashes [Array<Hash>] the options to merge into the current options
  # @return [self.class]
  #
  # source://process_executer//lib/process_executer/options/base.rb#184
  def merge(*other_options_hashes); end

  # Merge the given options into the current options object
  #
  # Subsequent hashes' values overwrite earlier ones for the same key.
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   h1 = { option2: 'new_value2' }
  #   h2 = { option3: 'value3' }
  #   options.merge!(h1, h2) => {option1: "value1", option2: "new_value2", option3: "value3"}
  # @param other_options_hashes [Array<Hash>] zero of more hashes to merge into the current options
  # @return [self] the current options object with the merged options
  #
  # source://process_executer//lib/process_executer/options/base.rb#166
  def merge!(*other_options_hashes); end

  # A hash representation of the options
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.to_h # => { option1: "value1", option2: "value2" }
  # @return [Hash]
  #
  # source://process_executer//lib/process_executer/options/base.rb#127
  def to_h; end

  # A string representation of the object that includes the options
  #
  # @api public
  # @example
  #   options = MyOptions.new(option1: 'value1', option2: 'value2')
  #   options.to_s # => #<MyOptions option1: "value1", option2: "value2">'
  # @return [String]
  #
  # source://process_executer//lib/process_executer/options/base.rb#103
  def to_s; end

  protected

  # An array of OptionDefinition objects that define the allowed options
  #
  # Subclasses MUST override this method to define the allowed options.
  #
  # @api private
  # @return [Array<OptionDefinition>]
  #
  # source://process_executer//lib/process_executer/options/base.rb#199
  def define_options; end

  # Determine if the given option is a valid option
  #
  # May be overridden by subclasses to add additional validation.
  #
  # @api private
  # @param option [Symbol] the option to be tested
  # @return [Boolean] true if the given option is a valid option
  #
  # source://process_executer//lib/process_executer/options/base.rb#210
  def valid_option?(option); end

  private

  # Determine if the options hash contains any unknown options
  #
  # @api private
  # @raise [ProcessExecuter::ArgumentError] if the options hash contains any unknown options
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options/base.rb#264
  def assert_no_unknown_options; end

  # Define accessor methods for each option
  #
  # @api private
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options/base.rb#252
  def define_accessor_methods; end

  # The list of validation errors
  #
  # Validators should add error messages to this array.
  #
  # @api private
  # @return [Array<String>]
  #
  # source://process_executer//lib/process_executer/options/base.rb#224
  def errors; end

  # A hash of all options keyed by the option name
  #
  # @api private
  # @return [Hash<Object, Object>]
  #
  # source://process_executer//lib/process_executer/options/base.rb#234
  def options_hash; end

  # Raise an argument error for invalid option values
  #
  # @api private
  # @raise [ProcessExecuter::ArgumentError] if any invalid option values are found
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options/base.rb#240
  def validate_options; end
end

# Defines an option that can be used by an Options object
#
# @api public
#
# source://process_executer//lib/process_executer/options/option_definition.rb#9
class ProcessExecuter::Options::OptionDefinition
  # Create a new option definition
  #
  # @api public
  # @example
  #   option = ProcessExecuter::Options::OptionDefinition.new(
  #   :timeout_after, default: 10, validator: ->(_k, _v) { timeout_after.is_a?(Numeric) }
  #   )
  # @return [OptionDefinition] a new instance of OptionDefinition
  #
  # source://process_executer//lib/process_executer/options/option_definition.rb#53
  def initialize(name, default: T.unsafe(nil), validator: T.unsafe(nil)); end

  # The default value of the option
  #
  # @api public
  # @example
  #   option = ProcessExecuter::Options::OptionDefinition.new(:timeout_after, default: 10)
  #   option.default # => 10
  # @return [Object]
  #
  # source://process_executer//lib/process_executer/options/option_definition.rb#28
  def default; end

  # The name of the option
  #
  # @api public
  # @example
  #   option = ProcessExecuter::Options::OptionDefinition.new(:timeout_after)
  #   option.name # => :timeout_after
  # @return [Symbol]
  #
  # source://process_executer//lib/process_executer/options/option_definition.rb#18
  def name; end

  # A method or proc that validates the option
  #
  # A callable that receives `option_key`, `option_value` and is executed in the
  # context of the options instance. It should add messages to an `errors` array
  # if validation fails.
  #
  # @api public
  # @example
  #   option = ProcessExecuter::Options::OptionDefinition.new(
  #   :timeout_after, validator: method(:validate_timeout_after)
  #   )
  #   option.validator # => #<Method: ProcessExecuter#validate_timeout_after>
  # @return [Method, Proc, nil]
  #
  # source://process_executer//lib/process_executer/options/option_definition.rb#44
  def validator; end
end

# Define options for {ProcessExecuter.run}
#
# @api public
#
# source://process_executer//lib/process_executer/options/run_options.rb#12
class ProcessExecuter::Options::RunOptions < ::ProcessExecuter::Options::SpawnWithTimeoutOptions
  private

  # The options allowed for objects of this class
  #
  # @api private
  # @return [Array<OptionDefinition>]
  #
  # source://process_executer//lib/process_executer/options/run_options.rb#18
  def define_options; end

  # Note an error if the logger option is not valid
  #
  # @api private
  # @param _key [Symbol] the option key (not used)
  # @param _value [Object] the option value (not used)
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/options/run_options.rb#42
  def validate_logger(_key, _value); end

  # Note an error if raise_errors is not true or false
  #
  # @api private
  # @param _key [Symbol] the option key (not used)
  # @param _value [Object] the option value (not used)
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/options/run_options.rb#31
  def validate_raise_errors(_key, _value); end
end

# Define options for {ProcessExecuter.run_with_capture}
#
# @api public
#
# source://process_executer//lib/process_executer/options/run_with_capture_options.rb#12
class ProcessExecuter::Options::RunWithCaptureOptions < ::ProcessExecuter::Options::RunOptions
  # Determines the character encoding to use for stderr
  #
  # It prioritizes `stderr_encoding` if set, otherwise falls back to
  # `encoding`, and finally defaults to `DEFAULT_ENCODING` if neither
  # is available.
  #
  # @api private
  # @return [Encoding]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#44
  def effective_stderr_encoding; end

  # Determines the character encoding to use for stdout
  #
  # It prioritizes `stdout_encoding` if set, otherwise falls back to
  # `encoding`, and finally defaults to `DEFAULT_ENCODING` if neither
  # is available.
  #
  # @api private
  # @return [Encoding]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#30
  def effective_stdout_encoding; end

  private

  # The options allowed for objects of this class
  #
  # @api private
  # @return [Array<OptionDefinition>]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#53
  def define_options; end

  # False if the value is not a valid encoding type, true otherwise
  #
  # @api private
  # @param key [Symbol] the option key
  # @param value [Object] the option value
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#113
  def valid_encoding_type?(key, value); end

  # Note an error if the encoding option is not valid
  #
  # @api private
  # @param key [Symbol] the option key
  # @param value [Object] the option value
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#93
  def validate_encoding_option(key, value); end

  # Note an error if the encoding string is not valid
  #
  # @api private
  # @param key [Symbol] the option key
  # @param value [String] the option value
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#149
  def validate_encoding_string(key, value); end

  # Note an error if the encoding symbol is not valid
  #
  # @api private
  # @param key [Symbol] the option key
  # @param value [Symbol] the option value
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#132
  def validate_encoding_symbol(key, value); end

  # Note any errors in the merge_output option
  #
  # Possible errors include:
  # - if the merge_output value is not a Boolean
  # - if merge_output: true and a stderr redirection is given
  # - if merge_output: true and stdout and stderr encodings are different
  #
  # @api private
  # @param _key [Symbol] the option key (not used)
  # @param _value [Object] the option value (not used)
  # @return [Void]
  #
  # source://process_executer//lib/process_executer/options/run_with_capture_options.rb#74
  def validate_merge_output(_key, _value); end
end

# The default encoding used for stdout and stderr
# if no other encoding is specified.
#
# @api public
# @return [Encoding]
#
# source://process_executer//lib/process_executer/options/run_with_capture_options.rb#18
ProcessExecuter::Options::RunWithCaptureOptions::DEFAULT_ENCODING = T.let(T.unsafe(nil), Encoding)

# Defines and validates options accepted by `Process.spawn`
#
# Allows subclasses to add additional options that are not passed to `Process.spawn`.
#
# Provides a method (#spawn_options) to retrieve only those options directly
# applicable to Process.spawn.
#
# @api public
#
# source://process_executer//lib/process_executer/options/spawn_options.rb#17
class ProcessExecuter::Options::SpawnOptions < ::ProcessExecuter::Options::Base
  # Determine if the given option key indicates a redirection option
  #
  # @api private
  # @param option_key [Symbol, Integer, IO, Array] the option key to be tested
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#57
  def redirection?(option_key); end

  # Returns the options to be passed to Process.spawn
  #
  # Any options added by subclasses that are not part of the SPAWN_OPTIONS or
  # are not a redirection option will not be included in the returned hash.
  #
  # @api public
  # @example
  #   options = ProcessExecuter::Options::SpawnOptions.new(out: $stdout, chdir: '/tmp')
  #   options.spawn_options # => { out: $stdout, chdir: '/tmp' }
  # @return [Hash]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#45
  def spawn_options; end

  # Does option_key indicate a standard redirection such as stdin, stdout, or stderr
  #
  # @api private
  # @param option_key [Symbol, Integer, IO, Array] the option key to be tested
  # @param symbol [:in, :out, :err] the symbol to test for
  # @param fileno [Integer] the file descriptor number to test for
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#68
  def std_redirection?(option_key, symbol, fileno); end

  # Determine if the given option key indicates a redirection option for stderr
  #
  # @api private
  # @param option_key [Symbol, Integer, IO, Array] the option key to be tested
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#97
  def stderr_redirection?(option_key); end

  # Determine redirection destination for stderr if it exists
  #
  # @api private
  # @return [Symbol, Integer, IO, Array, nil] nil if stderr is not redirected
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#109
  def stderr_redirection_destination; end

  # Determine the option key that indicates a redirection option for stderr
  #
  # @api private
  # @return [Symbol, Integer, IO, Array, nil] nil if not found
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#102
  def stderr_redirection_source; end

  # Determine if the given option key indicates a redirection option for stdout
  #
  # @api private
  # @param option_key [Symbol, Integer, IO, Array] the option key to be tested
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#77
  def stdout_redirection?(option_key); end

  # Return the redirection destination for stdout
  #
  # @api private
  # @return [Symbol, Integer, IO, Array, nil] nil if stdout is not redirected
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#89
  def stdout_redirection_destination; end

  # Determine the option key that indicates a redirection option for stdout
  #
  # @api private
  # @return [Symbol, Integer, IO, Array, nil] nil if not found
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#82
  def stdout_redirection_source; end

  private

  # Define the allowed options
  #
  # @api private
  # @return [Array<OptionDefinition>]
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#120
  def define_options; end

  # Determine if the given option should be passed to `Process.spawn`
  #
  # @api private
  # @param option_key [Object] the option to be tested
  # @param value [Object] the value of the option
  # @return [Boolean] true if the given option should be passed to `Process.spawn`
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#129
  def include_spawn_option?(option_key, value); end

  # Spawn allows IO object and integers as options
  #
  # @api private
  # @param option_key [Object] the option to be tested
  # @return [Boolean] true if the given option is a valid option
  #
  # source://process_executer//lib/process_executer/options/spawn_options.rb#139
  def valid_option?(option_key); end
end

# Options that are passed to Process.spawn
#
# They are not passed if the value is :not_set
#
# @api public
# @return [Array<OptionDefinition>]
#
# source://process_executer//lib/process_executer/options/spawn_options.rb#24
ProcessExecuter::Options::SpawnOptions::SPAWN_OPTIONS = T.let(T.unsafe(nil), Array)

# Defines options for {ProcessExecuter.spawn_with_timeout}
#
# @api public
#
# source://process_executer//lib/process_executer/options/spawn_with_timeout_options.rb#12
class ProcessExecuter::Options::SpawnWithTimeoutOptions < ::ProcessExecuter::Options::SpawnOptions
  private

  # The options allowed for objects of this class
  #
  # @api private
  # @return [Array<OptionDefinition>]
  #
  # source://process_executer//lib/process_executer/options/spawn_with_timeout_options.rb#18
  def define_options; end

  # Note an error if timeout_after is not nil or a non-negative real number
  #
  # @api private
  # @param _key [Symbol] the option key (not used)
  # @param _value [Object] the option value (not used)
  # @return [void]
  #
  # source://process_executer//lib/process_executer/options/spawn_with_timeout_options.rb#35
  def validate_timeout_after(_key, _value); end
end

# Raised if an exception occurred while processing subprocess output
#
# @api public
#
# source://process_executer//lib/process_executer/errors.rb#159
class ProcessExecuter::ProcessIOError < ::ProcessExecuter::Error; end

# A decorator for Process::Status that adds the following attributes:
#
# * `command`: the command that was used to spawn the process
# * `options`: the options that were used to spawn the process
# * `elapsed_time`: the seconds the command ran
# * `timed_out?`: true if the process timed out
#
# @api public
#
# source://process_executer//lib/process_executer/result.rb#15
class ProcessExecuter::Result < ::SimpleDelegator
  # Create a new Result object
  #
  # @api public
  # @example
  #   command = ['sleep 1']
  #   options = ProcessExecuter::Options::SpawnOptions.new
  #   pid = Process.spawn(*command, **options.spawn_options)
  #   _pid, status = Process.wait2(pid)
  #   timed_out = false
  #   elapsed_time = 0.01
  #
  #   ProcessExecuter::Result.new(status, command:, options:, timed_out:, elapsed_time:)
  # @param command [Array] the command that was used to spawn the process
  # @param timed_out [Boolean] true if the process timed out
  # @param elapsed_time [Numeric] the seconds the command ran
  # @param options [ProcessExecuter::Options::Base] the options that were used to spawn the process
  # @param status [Process::Status] the status to delegate to
  # @return [Result] a new instance of Result
  #
  # source://process_executer//lib/process_executer/result.rb#38
  def initialize(status, command:, options:, timed_out:, elapsed_time:); end

  # The command that was used to spawn the process
  #
  # @api public
  # @example
  #   result.command #=> [{ 'GIT_DIR' => '/path/to/repo' }, 'git', 'status']
  # @return [Array]
  # @see Process.spawn
  #
  # source://process_executer//lib/process_executer/result.rb#51
  def command; end

  # The seconds the command ran
  #
  # @api public
  # @example
  #   result.elapsed_time #=> 10.0
  # @return [Numeric]
  #
  # source://process_executer//lib/process_executer/result.rb#70
  def elapsed_time; end

  # The options that were used to spawn the process
  #
  # @api public
  # @example
  #   # Looks like a hash, but is actually an object that derives from
  #   # ProcessExecuter::Options::Base
  #   result.options #=> { chdir: '/path/to/repo', timeout_after: 0.5 }
  # @return [ProcessExecuter::Options::Base]
  # @see Process.spawn
  #
  # source://process_executer//lib/process_executer/result.rb#64
  def options; end

  # Overrides the default `success?` method to return `nil` if the process timed out
  #
  # This is because when a timeout occurs, Windows will still return true.
  #
  # @api public
  # @example
  #   result = ProcessExecuter.spawn_with_timeout('sleep 10', timeout_after: 0.01)
  #   result.success? # => nil
  # @return [true, false, nil]
  #
  # source://process_executer//lib/process_executer/result.rb#91
  def success?; end

  # True if the process timed out and was sent the SIGKILL signal
  #
  # @api public
  # @example
  #   result = ProcessExecuter.spawn_with_timeout('sleep 10', timeout_after: 0.01)
  #   result.timed_out? # => true
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/result.rb#79
  def timed_out; end

  # True if the process timed out and was sent the SIGKILL signal
  #
  # @api public
  # @example
  #   result = ProcessExecuter.spawn_with_timeout('sleep 10', timeout_after: 0.01)
  #   result.timed_out? # => true
  # @return [Boolean]
  #
  # source://process_executer//lib/process_executer/result.rb#79
  def timed_out?; end

  # Return a string representation of the result
  #
  # @api public
  # @example
  #   result = ProcessExecuter.spawn_with_timeout('sleep 10', timeout_after: 1)
  #   # This message is platform dependent, but will look like this on Linux:
  #   result.to_s #=> "pid 70144 SIGKILL (signal 9) timed out after 1s"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/result.rb#104
  def to_s; end
end

# A decorator for ProcessExecuter::Result that adds the following attributes:
#
# * `stdout`: the captured stdout of the command
# * `stderr`: the captured stderr of the command
#
# @api public
#
# source://process_executer//lib/process_executer/result_with_capture.rb#13
class ProcessExecuter::ResultWithCapture < ::SimpleDelegator
  # Create a new ResultWithCapture object
  #
  # @api public
  # @example manually create a ResultWithCapture instance
  #   stdout_buffer = StringIO.new
  #   stderr_buffer = StringIO.new
  #   command = ['echo HELLO; echo ERROR >&2']
  #   result = ProcessExecuter.run(*command, out: stdout_buffer, err: stderr_buffer)
  #   result_with_capture = ProcessExecuter::ResultWithCapture.new(result, stdout_buffer:, stderr_buffer:)
  #
  #   # Normally, you would use the `run_with_capture` method to create a
  #   # ResultWithCapture instance. The above code is equivalent to:
  #
  #   result_with_capture = ProcessExecuter.run_with_capture('echo HELLO; echo ERROR >&2')
  # @param result [ProcessExecuter::Result] the result to delegate to
  # @param stdout_buffer [StringIO] the captured stdout
  # @param stderr_buffer [StringIO] the captured stderr
  # @return [ResultWithCapture] a new instance of ResultWithCapture
  #
  # source://process_executer//lib/process_executer/result_with_capture.rb#32
  def initialize(result, stdout_buffer:, stderr_buffer:); end

  # The captured stderr of the command
  #
  # @api public
  # @example
  #   result.stderr #=> "ERROR\n"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/result_with_capture.rb#60
  def stderr; end

  # The buffer used to capture stderr
  #
  # @api public
  # @example
  #   result.stderr_buffer #=> #<StringIO:0x00007f8c1b0a2d80>
  # @return [StringIO]
  #
  # source://process_executer//lib/process_executer/result_with_capture.rb#54
  def stderr_buffer; end

  # The captured stdout of the command
  #
  # @api public
  # @example
  #   result.stdout #=> "HELLO\n"
  # @return [String]
  #
  # source://process_executer//lib/process_executer/result_with_capture.rb#48
  def stdout; end

  # The buffer used to capture stdout
  #
  # @api public
  # @example
  #   result.stdout_buffer #=> #<StringIO:0x00007f8c1b0a2d80>
  # @return [StringIO]
  #
  # source://process_executer//lib/process_executer/result_with_capture.rb#42
  def stdout_buffer; end
end

# Raised when the command exits because of an uncaught signal
#
# @api public
#
# source://process_executer//lib/process_executer/errors.rb#140
class ProcessExecuter::SignaledError < ::ProcessExecuter::CommandError; end

# Raised when spawn could not execute the process
#
# See the `cause` for the exception that Process.spawn raised.
#
# @api public
#
# source://process_executer//lib/process_executer/errors.rb#167
class ProcessExecuter::SpawnError < ::ProcessExecuter::Error; end

# Raised when the command takes longer than the configured timeout_after
#
# @api public
# @example
#   begin
#   ProcessExecuter.spawn_with_timeout('sleep 1', timeout_after: 0.1)
#   rescue ProcessExecuter::TimeoutError => e
#   puts "Command timed out: #{e.result.command}"
#   end
#
# source://process_executer//lib/process_executer/errors.rb#153
class ProcessExecuter::TimeoutError < ::ProcessExecuter::SignaledError; end

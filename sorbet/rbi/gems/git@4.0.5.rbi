# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `git` gem.
# Please instead update this file by running `bin/tapioca gem git`.


# The Git module provides the basic functions to open a git
# reference to work with. You can open a working directory,
# open a bare repository, initialize a new repo or clone an
# existing remote repository.
#
# @author Scott Chacon (mailto:schacon@gmail.com)
#
# source://git//lib/git.rb#6
module Git
  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # source://git//lib/git.rb#49
  def config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  # source://git//lib/git.rb#71
  def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git.rb#103
    def bare(git_dir, options = T.unsafe(nil)); end

    # Return the version of the git binary
    #
    # @example
    #   Git.binary_version # => [2, 46, 0]
    # @return [Array<Integer>] the version of the git binary
    #
    # source://git//lib/git.rb#395
    def binary_version(binary_path = T.unsafe(nil)); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone a repository and set multiple config options
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: ['user.name=John Doe', 'user.email=john@doe.com']
    #   )
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone a repository and set a single config option
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: 'submodule.recurse=true'
    #   )
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git.rb#193
    def clone(repository_url, directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # source://git//lib/git.rb#67
    def config; end

    # @yield [Base.config]
    #
    # source://git//lib/git.rb#63
    def configure; end

    # Returns the name of the default branch of the given repository
    #
    # @example with a URI string
    #   Git.default_branch('https://github.com/ruby-git/ruby-git') # => 'master'
    #   Git.default_branch('https://github.com/rspec/rspec-core') # => 'main'
    # @example with a URI object
    #   repository_uri = URI('https://github.com/ruby-git/ruby-git')
    #   Git.default_branch(repository_uri) # => 'master'
    # @example with a local repository
    #   Git.default_branch('.') # => 'master'
    # @example with a local repository Pathname
    #   repository_path = Pathname('.')
    #   Git.default_branch(repository_path) # => 'master'
    # @example with the logging option
    #   logger = Logger.new(STDOUT, level: Logger::INFO)
    #   Git.default_branch('.', log: logger) # => 'master'
    #   I, [2022-04-13T16:01:33.221596 #18415]  INFO -- : git '-c' 'core.quotePath=true'
    #   '-c' 'color.ui=false' ls-remote '--symref' '--' '.' 'HEAD'  2>&1
    # @option options
    # @param repository [URI, Pathname, String] The (possibly remote) repository to get the default branch name for
    #
    #   See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [String] the name of the default branch
    #
    # source://git//lib/git.rb#236
    def default_branch(repository, options = T.unsafe(nil)); end

    # Export the current HEAD (or a branch, if <tt>options[:branch]</tt>
    # is specified) into the +name+ directory, then remove all traces of git from the
    # directory.
    #
    # See +clone+ for options.  Does not obey the <tt>:remote</tt> option,
    # since the .git info will be deleted anyway; always uses the default
    # remote, 'origin.'
    #
    # source://git//lib/git.rb#247
    def export(repository, name, options = T.unsafe(nil)); end

    # Same as g.config, but forces it to be at the global level
    #
    # g.config('user.name', 'Scott Chacon') # sets value
    # g.config('user.email', 'email@email.com')  # sets value
    # g.config('user.name')  # returns 'Scott Chacon'
    # g.config # returns whole config hash
    #
    # source://git//lib/git.rb#260
    def global_config(name = T.unsafe(nil), value = T.unsafe(nil)); end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git.rb#324
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # returns a Hash containing information about the references
    # of the target repository
    #
    # options
    #   :refs
    #
    # @param location [String|NilClass] the target repository location or nil for '.'
    # @return [{String=>Hash}] the available references of the target repo.
    #
    # source://git//lib/git.rb#336
    def ls_remote(location = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git.rb#384
    def open(working_dir, options = T.unsafe(nil)); end
  end
end

# Takes a hash of user options and a declarative map and produces
# an array of command-line arguments. Also validates that only
# supported options are provided based on the map.
#
# @api private
#
# source://git//lib/git/args_builder.rb#9
class Git::ArgsBuilder
  # @api private
  # @return [ArgsBuilder] a new instance of ArgsBuilder
  #
  # source://git//lib/git/args_builder.rb#40
  def initialize(opts, option_map); end

  # @api private
  #
  # source://git//lib/git/args_builder.rb#45
  def build; end

  private

  # @api private
  #
  # source://git//lib/git/args_builder.rb#59
  def build_arg_for_option(config, value); end

  class << self
    # Main entrypoint to validate options and build arguments
    #
    # @api private
    #
    # source://git//lib/git/args_builder.rb#29
    def build(opts, option_map); end

    # Public validation method that can be called independently
    #
    # @api private
    #
    # source://git//lib/git/args_builder.rb#35
    def validate!(opts, option_map); end

    private

    # @api private
    # @raise [ArgumentError]
    #
    # source://git//lib/git/args_builder.rb#82
    def check_for_missing_required_option!(opts, config); end

    # @api private
    #
    # source://git//lib/git/args_builder.rb#73
    def validate_configured_options!(opts, option_map); end

    # @api private
    # @raise [ArgumentError]
    #
    # source://git//lib/git/args_builder.rb#91
    def validate_option_value!(opts, config); end

    # @api private
    # @raise [ArgumentError]
    #
    # source://git//lib/git/args_builder.rb#64
    def validate_unsupported_keys!(opts, option_map); end
  end
end

# This hash maps an option type to a lambda that knows how to build the
# corresponding command-line argument. This is a scalable dispatch table.
#
# @api private
#
# source://git//lib/git/args_builder.rb#12
Git::ArgsBuilder::ARG_BUILDERS = T.let(T.unsafe(nil), Hash)

# An author in a Git commit
#
# source://git//lib/git/author.rb#5
class Git::Author
  # @return [Author] a new instance of Author
  #
  # source://git//lib/git/author.rb#8
  def initialize(author_string); end

  # Returns the value of attribute date.
  #
  # source://git//lib/git/author.rb#6
  def date; end

  # Sets the attribute date
  #
  # @param value the value to set the attribute date to.
  #
  # source://git//lib/git/author.rb#6
  def date=(_arg0); end

  # Returns the value of attribute email.
  #
  # source://git//lib/git/author.rb#6
  def email; end

  # Sets the attribute email
  #
  # @param value the value to set the attribute email to.
  #
  # source://git//lib/git/author.rb#6
  def email=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/author.rb#6
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/author.rb#6
  def name=(_arg0); end
end

# The main public interface for interacting with Git commands
#
# Instead of creating a Git::Base directly, obtain a Git::Base instance by
# calling one of the follow {Git} class methods: {Git.open}, {Git.init},
# {Git.clone}, or {Git.bare}.
#
# @api public
#
# source://git//lib/git/base.rb#15
class Git::Base
  # Create an object that executes Git commands in the context of a working
  # copy or a bare repository.
  #
  # @api public
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] The options for this command (see list of valid
  #   options below)
  # @return [Git::Base] an object that can execute git commands in the context
  #   of the opened working copy or bare repository
  #
  # source://git//lib/git/base.rb#154
  def initialize(options = T.unsafe(nil)); end

  # Update the index from the current worktree to prepare the for the next commit
  #
  # @api public
  # @example
  #   lib.add('path/to/file')
  #   lib.add(['path/to/file1','path/to/file2'])
  #   lib.add(all: true)
  # @option options
  # @option options
  # @param paths [String, Array<String>] a file or files to be added to the repository (relative to the worktree root)
  # @param options [Hash]
  #
  # source://git//lib/git/base.rb#173
  def add(paths = T.unsafe(nil), **options); end

  # adds a new remote to this repository
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.add_remote('scotts_git', 'git://repo.or.cz/rubygit.git')
  #  @git.fetch('scotts_git')
  #  @git.merge('scotts_git/master')
  #
  # Options:
  #   :fetch => true
  #   :track => <branch_name>
  #
  # @api public
  #
  # source://git//lib/git/base.rb#187
  def add_remote(name, url, opts = T.unsafe(nil)); end

  # Create a new git tag
  #
  # @api public
  # @example
  #   repo.add_tag('tag_name', object_reference)
  #   repo.add_tag('tag_name', object_reference, {:options => 'here'})
  #   repo.add_tag('tag_name', {:options => 'here'})
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param name [String] The name of the tag to add
  # @param options [Hash] Opstions to pass to `git tag`.
  #   See [git-tag](https://git-scm.com/docs/git-tag) for more details.
  #
  # source://git//lib/git/base.rb#565
  def add_tag(name, *options); end

  # @api public
  #
  # source://git//lib/git/base.rb#589
  def apply(file); end

  # @api public
  #
  # source://git//lib/git/base.rb#595
  def apply_mail(file); end

  # creates an archive file of the given tree-ish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#576
  def archive(treeish, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Branch] an object for branch_name
  #
  # source://git//lib/git/base.rb#713
  def branch(branch_name = T.unsafe(nil)); end

  # returns +true+ if the branch exists
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#305
  def branch?(branch); end

  # @api public
  # @return [Git::Branches] a collection of all the branches in the repository.
  #   Each branch is represented as a {Git::Branch}.
  #
  # source://git//lib/git/base.rb#719
  def branches; end

  # @api public
  #
  # source://git//lib/git/base.rb#696
  def cat_file(objectish); end

  # changes current working directory for a block
  # to the git working directory
  #
  # example
  #  @git.chdir do
  #    # write files
  #    @git.add
  #    @git.commit('message')
  #  end
  #
  # @api public
  #
  # source://git//lib/git/base.rb#202
  def chdir; end

  # checks out a branch as the new git working directory
  #
  # @api public
  #
  # source://git//lib/git/base.rb#443
  def checkout(*_arg0, **_arg1); end

  # checks out an old version of a file
  #
  # @api public
  #
  # source://git//lib/git/base.rb#448
  def checkout_file(version, file); end

  # @api public
  #
  # source://git//lib/git/base.rb#633
  def checkout_index(opts = T.unsafe(nil)); end

  # cleans the working directory
  #
  # options:
  #  :force
  #  :d
  #  :ff
  #
  # @api public
  #
  # source://git//lib/git/base.rb#389
  def clean(opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository
  #
  # options:
  #   :all
  #   :allow_empty
  #   :amend
  #   :author
  #
  # @api public
  #
  # source://git//lib/git/base.rb#430
  def commit(message, opts = T.unsafe(nil)); end

  # commits all pending changes in the index file to the git repository,
  # but automatically adds all modified files without having to explicitly
  # calling @git.add() on them.
  #
  # @api public
  #
  # source://git//lib/git/base.rb#437
  def commit_all(message, opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object::Commit] a commit object
  #
  # source://git//lib/git/base.rb#735
  def commit_tree(tree = T.unsafe(nil), opts = T.unsafe(nil)); end

  # g.config('user.name', 'Scott Chacon') # sets value
  # g.config('user.email', 'email@email.com')  # sets value
  # g.config('user.email', 'email@email.com', file: 'path/to/custom/config)  # sets value in file
  # g.config('user.name')  # returns 'Scott Chacon'
  # g.config # returns whole config hash
  #
  # @api public
  #
  # source://git//lib/git/base.rb#213
  def config(name = T.unsafe(nil), value = T.unsafe(nil), options = T.unsafe(nil)); end

  # The name of the branch HEAD refers to or 'HEAD' if detached
  #
  # Returns one of the following:
  #   * The branch name that HEAD refers to (even if it is an unborn branch)
  #   * 'HEAD' if in a detached HEAD state
  #
  # @api public
  # @return [String] the name of the branch HEAD refers to or 'HEAD' if detached
  #
  # source://git//lib/git/base.rb#708
  def current_branch; end

  # deletes a tag
  #
  # @api public
  #
  # source://git//lib/git/base.rb#571
  def delete_tag(name); end

  # returns the most recent tag that is reachable from a commit
  #
  # options:
  #  :all
  #  :tags
  #  :contains
  #  :debug
  #  :exact_match
  #  :dirty
  #  :abbrev
  #  :candidates
  #  :long
  #  :always
  #  :match
  #
  # @api public
  #
  # source://git//lib/git/base.rb#408
  def describe(committish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Diff] a Git::Diff object
  #
  # source://git//lib/git/base.rb#740
  def diff(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # Returns a Git::Diff::PathStatus object for accessing the name-status report.
  # Provided for backwards compatibility
  #
  # @api public
  # @param objectish [String] The first commit or object to compare. Defaults to 'HEAD'.
  # @param obj2 [String, nil] The second commit or object to compare.
  # @return [Git::Diff::PathStatus]
  #
  # source://git//lib/git/base.rb#816
  def diff_name_status(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # Returns a Git::Diff::PathStatus object for accessing the name-status report.
  #
  # @api public
  # @param objectish [String] The first commit or object to compare. Defaults to 'HEAD'.
  # @param obj2 [String, nil] The second commit or object to compare.
  # @return [Git::Diff::PathStatus]
  #
  # source://git//lib/git/base.rb#816
  def diff_path_status(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # Returns a Git::Diff::Stats object for accessing diff statistics.
  #
  # @api public
  # @param objectish [String] The first commit or object to compare. Defaults to 'HEAD'.
  # @param obj2 [String, nil] The second commit or object to compare.
  # @return [Git::Diff::Stats]
  #
  # source://git//lib/git/base.rb#807
  def diff_stats(objectish = T.unsafe(nil), obj2 = T.unsafe(nil)); end

  # returns a reference to the working directory
  #  @git.dir.path
  #  @git.dir.writeable?
  #
  # @api public
  #
  # source://git//lib/git/base.rb#229
  def dir; end

  # iterates over the files which are unmerged
  #
  # @api public
  #
  # source://git//lib/git/base.rb#492
  def each_conflict(&_arg0); end

  # fetches changes from a remote branch - this does not modify the working directory,
  # it just gets the changes from the remote if there are any
  #
  # @api public
  #
  # source://git//lib/git/base.rb#454
  def fetch(remote = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#745
  def gblob(objectish); end

  # @api public
  #
  # source://git//lib/git/base.rb#585
  def gc; end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#750
  def gcommit(objectish); end

  # Run a grep for 'string' on the HEAD of the git repository
  #
  # @api public
  # @example Using grep results:
  #   git.grep("TODO").each do |sha, arr|
  #   puts "in blob #{sha}:"
  #   arr.each do |line_no, match_string|
  #   puts "\t line #{line_no}: '#{match_string}'"
  #   end
  #   end
  # @example Limit grep's scope by calling grep() from a specific object:
  #   git.object("v2.3").grep('TODO')
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param string [String] the string to search for
  # @param path_limiter [String, Array] a path or array of paths to limit the search to or nil for no limit
  # @param opts [Hash] options to pass to the underlying `git grep` command
  # @return [Hash<String, Array>] a hash of arrays
  #   ```Ruby
  #   {
  #   'tree-ish1' => [[line_no1, match_string1], ...],
  #   'tree-ish2' => [[line_no1, match_string1], ...],
  #   ...
  #   }
  #   ```
  #
  # source://git//lib/git/base.rb#353
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Object] a Git object
  #
  # source://git//lib/git/base.rb#755
  def gtree(objectish); end

  # List the files in the worktree that are ignored by git
  #
  # @api public
  # @return [Array<String>] the list of ignored files relative to teh root of the worktree
  #
  # source://git//lib/git/base.rb#360
  def ignored_files; end

  # returns reference to the git index file
  #
  # @api public
  #
  # source://git//lib/git/base.rb#234
  def index; end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#310
  def is_branch?(branch); end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#288
  def is_local_branch?(branch); end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#299
  def is_remote_branch?(branch); end

  # this is a convenience method for accessing the class that wraps all the
  # actual 'git' forked system calls.  At some point I hope to replace the Git::Lib
  # class with one that uses native methods or libgit C bindings
  #
  # @api public
  #
  # source://git//lib/git/base.rb#318
  def lib; end

  # returns +true+ if the branch exists locally
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#283
  def local_branch?(branch); end

  # @api public
  # @return [Git::Log] a log with the specified number of commits
  #
  # source://git//lib/git/base.rb#760
  def log(count = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#654
  def ls_files(location = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#692
  def ls_tree(objectish, opts = T.unsafe(nil)); end

  # merges one or more branches into the current working branch
  #
  # you can specify more than one branch to merge by passing an array of branches
  #
  # @api public
  #
  # source://git//lib/git/base.rb#487
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Find as good common ancestors as possible for a merge
  # example: g.merge_base('master', 'some_branch', 'some_sha', octopus: true)
  #
  # @api public
  # @return [Array<Git::Object::Commit>] a collection of common ancestors
  #
  # source://git//lib/git/base.rb#797
  def merge_base(*_arg0); end

  # returns a Git::Object of the appropriate type
  # you can also call @git.gtree('tree'), but that's
  # just for readability.  If you call @git.gtree('HEAD') it will
  # still return a Git::Object::Commit object.
  #
  # object calls a method that will run a rev-parse
  # on the objectish and determine the type of the object and return
  # an appropriate object for that type
  #
  # @api public
  # @return [Git::Object] an instance of the appropriate type of Git::Object
  #
  # source://git//lib/git/base.rb#774
  def object(objectish); end

  # Pulls the given branch from the given remote into the current branch
  #
  # @api public
  # @example pulls from origin/master
  #   @git.pull
  # @example pulls from upstream/master
  #   @git.pull('upstream')
  # @example pulls from upstream/develop
  #   @git.pull('upstream', 'develop')
  # @option opts
  # @param remote [String] the remote repository to pull from
  # @param branch [String] the branch to pull from
  # @param opts [Hash] options to pass to the pull command
  # @raise [Git::FailedError] if the pull fails
  # @raise [ArgumentError] if a branch is given without a remote
  # @return [Void]
  #
  # source://git//lib/git/base.rb#515
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Push changes to a remote repository
  #
  # @api public
  # @overload push
  #
  # source://git//lib/git/base.rb#480
  def push(*_arg0, **_arg1); end

  # @api public
  #
  # source://git//lib/git/base.rb#637
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # @api public
  # @return [Git::Remote] a remote of the specified name
  #
  # source://git//lib/git/base.rb#779
  def remote(remote_name = T.unsafe(nil)); end

  # returns +true+ if the branch exists remotely
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/base.rb#294
  def remote_branch?(branch); end

  # returns an array of Git:Remote objects
  #
  # @api public
  #
  # source://git//lib/git/base.rb#520
  def remotes; end

  # removes file(s) from the git repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#365
  def remove(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # removes a remote from this repository
  #
  # @git.remove_remote('scott_git')
  #
  # @api public
  #
  # source://git//lib/git/base.rb#538
  def remove_remote(name); end

  # repacks the repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#581
  def repack; end

  # returns reference to the git repository directory
  #  @git.dir.path
  #
  # @api public
  #
  # source://git//lib/git/base.rb#238
  def repo; end

  # returns the repository size in bytes
  #
  # @api public
  #
  # source://git//lib/git/base.rb#243
  def repo_size; end

  # resets the working directory to the provided commitish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#372
  def reset(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # resets the working directory to the commitish with '--hard'
  #
  # @api public
  #
  # source://git//lib/git/base.rb#377
  def reset_hard(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  #
  # @api public
  # @example
  #   git.rev_parse("HEAD^^")
  #   git.rev_parse('v2.4^{tree}')
  #   git.rev_parse('v2.4:/doc/index.html')
  #
  # source://git//lib/git/base.rb#685
  def rev_parse(objectish); end

  # reverts the working directory to the provided commitish.
  # Accepts a range, such as comittish..HEAD
  #
  # options:
  #   :no_edit
  #
  # @api public
  #
  # source://git//lib/git/base.rb#418
  def revert(commitish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # runs git rev-parse to convert the objectish to a full sha
  # For backwards compatibility
  #
  # @api public
  # @example
  #   git.rev_parse("HEAD^^")
  #   git.rev_parse('v2.4^{tree}')
  #   git.rev_parse('v2.4:/doc/index.html')
  #
  # source://git//lib/git/base.rb#685
  def revparse(objectish); end

  # removes file(s) from the git repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#365
  def rm(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#252
  def set_index(index_file, check = T.unsafe(nil), must_exist: T.unsafe(nil)); end

  # sets the url for a remote
  # url can be a git url or a Git::Base object if it's a local reference
  #
  #  @git.set_remote_url('scotts_git', 'git://repo.or.cz/rubygit.git')
  #
  # @api public
  #
  # source://git//lib/git/base.rb#529
  def set_remote_url(name, url); end

  # @api public
  #
  # source://git//lib/git/base.rb#267
  def set_working(work_dir, check = T.unsafe(nil), must_exist: T.unsafe(nil)); end

  # Shows objects
  #
  # @api public
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/base.rb#604
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # @api public
  # @return [Git::Status] a status object
  #
  # source://git//lib/git/base.rb#784
  def status; end

  # @api public
  # @return [Git::Object::Tag] a tag object
  #
  # source://git//lib/git/base.rb#789
  def tag(tag_name); end

  # returns an array of all Git::Tag objects for this repository
  #
  # @api public
  #
  # source://git//lib/git/base.rb#543
  def tags; end

  # @api public
  #
  # source://git//lib/git/base.rb#650
  def update_ref(branch, commit); end

  # LOWER LEVEL INDEX OPERATIONS ##
  #
  # @api public
  #
  # source://git//lib/git/base.rb#610
  def with_index(new_index); end

  # @api public
  #
  # source://git//lib/git/base.rb#618
  def with_temp_index(&_arg0); end

  # @api public
  #
  # source://git//lib/git/base.rb#669
  def with_temp_working(&_arg0); end

  # :yields: the Git::WorkingDirectory
  #
  # @api public
  #
  # source://git//lib/git/base.rb#658
  def with_working(work_dir); end

  # returns a Git::Worktree object for dir, commitish
  #
  # @api public
  #
  # source://git//lib/git/base.rb#724
  def worktree(dir, commitish = T.unsafe(nil)); end

  # returns a Git::worktrees object of all the Git::Worktrees
  # objects for this repo
  #
  # @api public
  #
  # source://git//lib/git/base.rb#730
  def worktrees; end

  # @api public
  #
  # source://git//lib/git/base.rb#645
  def write_and_commit_tree(opts = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/base.rb#641
  def write_tree; end

  private

  # Sets default paths in the options hash for direct `Git::Base.new` calls
  #
  # Factory methods like `Git.open` pre-populate these options by calling
  # `normalize_paths`, making this a fallback. It avoids mutating the
  # original options hash by returning a new one.
  #
  # @api public
  # @param options [Hash] the original options hash
  # @return [Hash] a new options hash with defaults applied
  #
  # source://git//lib/git/base.rb#833
  def default_paths(options); end

  # Initializes the core git objects based on the provided options
  #
  # @api public
  # @param options [Hash] The processed options hash.
  #
  # source://git//lib/git/base.rb#851
  def initialize_components(options); end

  # Initializes the logger from the provided options
  #
  # @api public
  # @param log_option [Logger, nil] The logger instance from options.
  #
  # source://git//lib/git/base.rb#844
  def setup_logger(log_option); end

  class << self
    # Open a bare repository
    #
    # Opens a bare repository located in the `git_dir` directory.
    # Since there is no working copy, you can not checkout or commit
    # but you can do most read operations.
    #
    # @example Open a bare repository and retrieve the first commit SHA
    #   repository = Git.bare('ruby-git.git')
    #   puts repository.log[0].sha #=> "64c6fa011d3287bab9158049c85f3e85718854a0"
    # @option options
    # @param git_dir [Pathname] The path to the bare repository directory
    #   containing an initialized Git repository. If a relative path is given, it
    #   is converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the bare repository.
    # @see https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefbarerepositoryabarerepository What is a bare repository?
    #
    # source://git//lib/git/base.rb#17
    def bare(git_dir, options = T.unsafe(nil)); end

    # @api public
    #
    # source://git//lib/git/base.rb#41
    def binary_version(binary_path); end

    # Clone a repository into an empty or newly created directory
    #
    # @example Clone a repository and set multiple config options
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: ['user.name=John Doe', 'user.email=john@doe.com']
    #   )
    # @example Clone into the default directory `ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git')
    # @example Clone and then checkout the `development` branch
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', branch: 'development')
    # @example Clone into a different directory `my-ruby-git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', 'my-ruby-git')
    #   # or:
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', path: 'my-ruby-git')
    # @example Create a bare repository in the directory `ruby-git.git`
    #   git = Git.clone('https://github.com/ruby-git/ruby-git.git', bare: true)
    # @example Clone a repository and set a single config option
    #   git = Git.clone(
    #   'https://github.com/ruby-git/ruby-git.git',
    #   config: 'submodule.recurse=true'
    #   )
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param repository_url [URI, Pathname] The (possibly remote) repository url to clone
    #   from. See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param directory [Pathname, nil] The directory to clone into
    #
    #   If `directory` is a relative directory it is relative to the `path` option if
    #   given. If `path` is not given, `directory` is relative to the current working
    #   directory.
    #
    #   If `nil`, `directory` will be set to the basename of the last component of
    #   the path from the `repository_url`. For example, for the URL:
    #   `https://github.com/org/repo.git`, `directory` will be set to `repo`.
    #
    #   If the last component of the path is `.git`, the next-to-last component of
    #   the path is used. For example, for the URL `/Users/me/foo/.git`, `directory`
    #   will be set to `foo`.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the cloned local working copy or cloned repository.
    # @see https://git-scm.com/docs/git-clone git clone
    # @see https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a GIT URLs
    #
    # source://git//lib/git/base.rb#23
    def clone(repository_url, directory, options = T.unsafe(nil)); end

    # Returns (and initialize if needed) a Git::Config instance
    #
    # @api public
    # @return [Git::Config] the current config instance.
    #
    # source://git//lib/git/base.rb#37
    def config; end

    # Create an empty Git repository or reinitialize an existing Git repository
    #
    # @example Initialize a repository in some other directory
    #   git = Git.init '~/code/ruby-git'
    # @example Initialize a bare repository
    #   git = Git.init '~/code/ruby-git.git', bare: true
    # @example Initialize a repository in the current directory
    #   git = Git.init
    # @example Initialize a repository in a non-default location (outside of the working copy)
    #   git = Git.init '~/code/ruby-git', repository: '~/code/ruby-git.git'
    # @option options
    # @option options
    # @option options
    # @option options
    # @param directory [Pathname] If the `:bare` option is NOT given or is not
    #   `true`, the repository will be created in `"#{directory}/.git"`.
    #   Otherwise, the repository is created in `"#{directory}"`.
    #
    #   All directories along the path to `directory` are created if they do not exist.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the newly initialized repository
    # @see https://git-scm.com/docs/git-init git init
    #
    # source://git//lib/git/base.rb#69
    def init(directory = T.unsafe(nil), options = T.unsafe(nil)); end

    # Open a an existing Git working directory
    #
    # Git.open will most likely be the most common way to create
    # a git reference, referring to an existing working directory.
    #
    # If not provided in the options, the library will assume
    # the repository and index are in the default places (`.git/`, `.git/index`).
    #
    # @example Open a Git working directory in some other directory
    #   git = Git.open('~/Projects/ruby-git')
    # @example Open the Git working directory in the current directory
    #   git = Git.open
    # @example Use a logger to see what is going on
    #   logger = Logger.new(STDOUT)
    #   git = Git.open('~/Projects/ruby-git', log: logger)
    # @example Open a working copy whose repository is in a non-standard directory
    #   git = Git.open('~/Projects/ruby-git', repository: '~/Project/ruby-git.git')
    # @option options
    # @option options
    # @option options
    # @param working_dir [Pathname] the path to the working directory to use
    #   for git commands.
    #
    #   A relative path is referenced from the current working directory of the process
    #   and converted to an absolute path using
    #   [File.expand_path](https://www.rubydoc.info/stdlib/core/File.expand_path).
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [Git::Base] an object that can execute git commands in the context
    #   of the opened working copy
    #
    # source://git//lib/git/base.rb#122
    def open(working_dir, options = T.unsafe(nil)); end

    # Returns the name of the default branch of the given repository
    #
    # @example with a URI string
    #   Git.default_branch('https://github.com/ruby-git/ruby-git') # => 'master'
    #   Git.default_branch('https://github.com/rspec/rspec-core') # => 'main'
    # @example with a URI object
    #   repository_uri = URI('https://github.com/ruby-git/ruby-git')
    #   Git.default_branch(repository_uri) # => 'master'
    # @example with a local repository
    #   Git.default_branch('.') # => 'master'
    # @example with a local repository Pathname
    #   repository_path = Pathname('.')
    #   Git.default_branch(repository_path) # => 'master'
    # @example with the logging option
    #   logger = Logger.new(STDOUT, level: Logger::INFO)
    #   Git.default_branch('.', log: logger) # => 'master'
    #   I, [2022-04-13T16:01:33.221596 #18415]  INFO -- : git '-c' 'core.quotePath=true'
    #   '-c' 'color.ui=false' ls-remote '--symref' '--' '.' 'HEAD'  2>&1
    # @option options
    # @param repository [URI, Pathname, String] The (possibly remote) repository to get the default branch name for
    #
    #   See [GIT URLS](https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
    #   for more information.
    # @param options [Hash] The options for this command (see list of valid
    #   options below)
    # @return [String] the name of the default branch
    #
    # source://git//lib/git/base.rb#30
    def repository_default_branch(repository, options = T.unsafe(nil)); end

    # @api public
    # @raise [ArgumentError]
    #
    # source://git//lib/git/base.rb#96
    def root_of_worktree(working_dir); end

    private

    # @api public
    #
    # source://git//lib/git/base.rb#49
    def execute_git_version(binary_path); end

    # @api public
    #
    # source://git//lib/git/base.rb#103
    def execute_rev_parse_toplevel(working_dir); end

    # Determines the initial, potential path to the repository directory
    #
    # This path is considered 'initial' because it is not guaranteed to be the
    # final repository location. For features like submodules or worktrees,
    # this path may point to a text file containing a `gitdir:` pointer to the
    # actual repository directory elsewhere. This initial path must be
    # subsequently resolved.
    #
    # @api private
    # @api public
    # @param options [Hash] The options hash, checked for `[:repository]`.
    # @param default [String] A fallback path if `options[:repository]` is not set.
    # @param bare [Boolean] Whether the repository is bare, which changes path resolution.
    # @return [String] The initial, absolute path to the `.git` directory or file.
    #
    # source://git//lib/git/base.rb#943
    def initial_repository_path(options, default:, bare:); end

    # Normalize options[:index]
    #
    # If options[:index] is a relative directory, convert it to an absolute
    # directory relative to the repository directory
    #
    # @api public
    #
    # source://git//lib/git/base.rb#979
    def normalize_index(options); end

    # Normalize options before they are sent to Git::Base.new
    #
    # Updates the options parameter by setting appropriate values for the following keys:
    #   * options[:working_directory]
    #   * options[:repository]
    #   * options[:index]
    #
    # All three values will be set to absolute paths. An exception is that
    # :working_directory will be set to nil if bare is true.
    #
    # @api public
    #
    # source://git//lib/git/base.rb#867
    def normalize_paths(options, default_working_directory: T.unsafe(nil), default_repository: T.unsafe(nil), bare: T.unsafe(nil)); end

    # Normalize options[:repository]
    #
    # If working with a bare repository, set to the first non-nil value out of:
    #   1. `options[:repository]`
    #   2. the `default` parameter
    #   3. the current working directory
    #
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:repository]`
    #   2. `.git`
    #
    # Next, if options[:repository] refers to a *file* and not a *directory*, set
    # options[:repository] to the contents of that file.  This is the case when
    # working with a submodule or a secondary working tree (created with git worktree
    # add). In these cases the repository is actually contained/nested within the
    # parent's repository directory.
    #
    # Finally, if options[:repository] is a relative path, convert it to an absolute
    # path relative to:
    #   1. the current directory if working with a bare repository or
    #   2. the working directory if NOT working with a bare repository
    #
    # @api public
    #
    # source://git//lib/git/base.rb#919
    def normalize_repository(options, default:, bare: T.unsafe(nil)); end

    # Normalize options[:working_directory]
    #
    # If working with a bare repository, set to `nil`.
    # Otherwise, set to the first non-nil value of:
    #   1. `options[:working_directory]`,
    #   2. the `default` parameter, or
    #   3. the current working directory
    #
    # Finally, if options[:working_directory] is a relative path, convert it to an absoluite
    # path relative to the current directory.
    #
    # @api public
    #
    # source://git//lib/git/base.rb#886
    def normalize_working_directory(options, default:, bare: T.unsafe(nil)); end

    # @api public
    #
    # source://git//lib/git/base.rb#60
    def parse_version_string(raw_string); end

    # @api public
    # @raise [ArgumentError]
    #
    # source://git//lib/git/base.rb#115
    def process_rev_parse_result(result, status, working_dir); end

    # Resolves the path to the actual repository if it's a `gitdir:` pointer file.
    #
    # If `path` points to a file (common in submodules and worktrees), this
    # method reads the `gitdir:` path from it and returns the real repository
    # path. Otherwise, it returns the original path.
    #
    # @api private
    # @api public
    # @param path [String] The initial path to the repository, which may be a pointer file.
    # @param working_dir [String] The working directory, used as a base to resolve the path.
    # @return [String] The final, resolved absolute path to the repository directory.
    #
    # source://git//lib/git/base.rb#965
    def resolve_gitdir_if_present(path, working_dir); end
  end
end

# Represents a Git branch
#
# source://git//lib/git/branch.rb#7
class Git::Branch
  # @return [Branch] a new instance of Branch
  #
  # source://git//lib/git/branch.rb#10
  def initialize(base, name); end

  # source://git//lib/git/branch.rb#32
  def archive(file, opts = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#27
  def checkout; end

  # @return [Boolean]
  #
  # source://git//lib/git/branch.rb#64
  def contains?(commit); end

  # source://git//lib/git/branch.rb#52
  def create; end

  # source://git//lib/git/branch.rb#60
  def current; end

  # source://git//lib/git/branch.rb#56
  def delete; end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/branch.rb#8
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/branch.rb#8
  def full=(_arg0); end

  # source://git//lib/git/branch.rb#18
  def gcommit; end

  # g.branch('new_branch').in_branch do
  #   # create new file
  #   # do other stuff
  #   return true # auto commits and switches back
  # end
  #
  # source://git//lib/git/branch.rb#41
  def in_branch(message = T.unsafe(nil)); end

  # source://git//lib/git/branch.rb#68
  def merge(branch = T.unsafe(nil), message = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/branch.rb#8
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/branch.rb#8
  def name=(_arg0); end

  # Returns the value of attribute remote.
  #
  # source://git//lib/git/branch.rb#8
  def remote; end

  # Sets the attribute remote
  #
  # @param value the value to set the attribute remote to.
  #
  # source://git//lib/git/branch.rb#8
  def remote=(_arg0); end

  # source://git//lib/git/branch.rb#23
  def stashes; end

  # source://git//lib/git/branch.rb#89
  def to_a; end

  # source://git//lib/git/branch.rb#93
  def to_s; end

  # source://git//lib/git/branch.rb#81
  def update_ref(commit); end

  private

  # source://git//lib/git/branch.rb#138
  def check_if_create; end

  # Given a full branch name return an Array containing the remote and branch names.
  #
  # Removes 'remotes' from the beggining of the name (if present).
  # Takes the second part (splittign by '/') as the remote name.
  # Takes the rest as the repo name (can also hold one or more '/').
  #
  # Example:
  #   # local branches
  #   parse_name('master') #=> [nil, 'master']
  #   parse_name('origin/master') #=> [nil, 'origin/master']
  #   parse_name('origin/master/v2') #=> [nil, 'origin/master']
  #
  #   # remote branches
  #   parse_name('remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('remotes/origin/master/v2') #=> ['origin', 'master/v2']
  #   parse_name('refs/remotes/origin/master') #=> ['origin', 'master']
  #   parse_name('refs/remotes/origin/master/v2') #=> ['origin', 'master/v2']
  #
  # param [String] name branch full name.
  # return [<Git::Remote,NilClass,String>] an Array containing the remote and branch names.
  #
  # source://git//lib/git/branch.rb#130
  def parse_name(name); end
end

# source://git//lib/git/branch.rb#97
Git::Branch::BRANCH_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

# object that holds all the available branches
#
# source://git//lib/git/branches.rb#5
class Git::Branches
  include ::Enumerable

  # @return [Branches] a new instance of Branches
  #
  # source://git//lib/git/branches.rb#8
  def initialize(base); end

  # Returns the target branch
  #
  # Example:
  #   Given (git branch -a):
  #    master
  #    remotes/working/master
  #
  #   g.branches['master'].full #=> 'master'
  #   g.branches['working/master'].full => 'remotes/working/master'
  #   g.branches['remotes/working/master'].full => 'remotes/working/master'
  #
  # @param branch_name [#to_s] the target branch name.
  # @return [Git::Branch] the target branch.
  #
  # source://git//lib/git/branches.rb#49
  def [](branch_name); end

  # source://git//lib/git/branches.rb#32
  def each(&_arg0); end

  # source://git//lib/git/branches.rb#18
  def local; end

  # source://git//lib/git/branches.rb#22
  def remote; end

  # array like methods
  #
  # source://git//lib/git/branches.rb#28
  def size; end

  # source://git//lib/git/branches.rb#60
  def to_s; end
end

# Runs a git command and returns the result
#
# @api public
#
# source://git//lib/git/command_line.rb#13
class Git::CommandLine
  # Create a Git::CommandLine object
  #
  # @api public
  # @example
  #   env = { 'GIT_DIR' => '/path/to/git/dir' }
  #   binary_path = '/usr/bin/git'
  #   global_opts = %w[--git-dir /path/to/git/dir]
  #   logger = Logger.new(STDOUT)
  #   cli = CommandLine.new(env, binary_path, global_opts, logger)
  #   cli.run('version') #=> #<Git::CommandLineResult:0x00007f9b0c0b0e00
  # @param env [Hash<String, String>] environment variables to set
  # @param global_opts [Array<String>] global options to pass to git
  # @param logger [Logger] the logger to use
  # @return [CommandLine] a new instance of CommandLine
  #
  # source://git//lib/git/command_line.rb#28
  def initialize(env, binary_path, global_opts, logger); end

  # The path to the command line binary to run
  #
  # @api public
  # @example
  #   binary_path = '/usr/bin/git'
  #   command_line = Git::CommandLine.new({}, binary_path, ['version'], Logger.new(STDOUT))
  #   command_line.binary_path #=> '/usr/bin/git'
  # @return [String]
  #
  # source://git//lib/git/command_line.rb#62
  def binary_path; end

  # Variables to set (or unset) in the git command's environment
  #
  # @api public
  # @example
  #   env = { 'GIT_DIR' => '/path/to/git/dir' }
  #   command_line = Git::CommandLine.new(env, '/usr/bin/git', [], Logger.new(STDOUT))
  #   command_line.env #=> { 'GIT_DIR' => '/path/to/git/dir' }
  # @return [Hash<String, String>]
  # @see https://ruby-doc.org/3.2.1/Process.html#method-c-spawn Process.spawn
  #   for details on how to set environment variables using the `env` parameter
  #
  # source://git//lib/git/command_line.rb#49
  def env; end

  # The global options to pass to git
  #
  # These are options that are passed to git before the command name and
  # arguments. For example, in `git --git-dir /path/to/git/dir version`, the
  # global options are %w[--git-dir /path/to/git/dir].
  #
  # @api public
  # @example
  #   env = {}
  #   global_opts = %w[--git-dir /path/to/git/dir]
  #   logger = Logger.new(nil)
  #   cli = CommandLine.new(env, '/usr/bin/git', global_opts, logger)
  #   cli.global_opts #=> %w[--git-dir /path/to/git/dir]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line.rb#81
  def global_opts; end

  # The logger to use for logging git commands and results
  #
  # @api public
  # @example
  #   env = {}
  #   global_opts = %w[]
  #   logger = Logger.new(STDOUT)
  #   cli = CommandLine.new(env, '/usr/bin/git', global_opts, logger)
  #   cli.logger == logger #=> true
  # @return [Logger]
  #
  # source://git//lib/git/command_line.rb#96
  def logger; end

  # Execute a git command, wait for it to finish, and return the result
  #
  # Non-option the command line arguements to pass to git. If you collect
  # the command line arguments in an array, make sure you splat the array
  # into the parameter list.
  #
  # NORMALIZATION
  #
  # The command output is returned as a Unicde string containing the binary output
  # from the command. If the binary output is not valid UTF-8, the output will
  # cause problems because the encoding will be invalid.
  #
  # Normalization is a process that trys to convert the binary output to a valid
  # UTF-8 string. It uses the `rchardet` gem to detect the encoding of the binary
  # output and then converts it to UTF-8.
  #
  # Normalization is not enabled by default. Pass `normalize: true` to Git::CommandLine#run
  # to enable it. Normalization will only be performed on stdout and only if the `out:`` option
  # is nil or is a StringIO object. If the out: option is set to a file or other IO object,
  # the normalize option will be ignored.
  #
  # @api public
  # @example Run a command and return the output
  #   cli.run('version') #=> "git version 2.39.1\n"
  # @example The args array should be splatted into the parameter list
  #   args = %w[log -n 1 --oneline]
  #   cli.run(*args) #=> "f5baa11 beginning of Ruby/Git project\n"
  # @example Run a command and return the chomped output
  #   cli.run('version', chomp: true) #=> "git version 2.39.1"
  # @example Run a command and without normalizing the output
  #   cli.run('version', normalize: false) #=> "git version 2.39.1\n"
  # @example Capture stdout in a temporary file
  #   require 'tempfile'
  #   tempfile = Tempfile.create('git') do |file|
  #   cli.run('version', out: file)
  #   file.rewind
  #   file.read #=> "git version 2.39.1\n"
  #   end
  # @example Capture stderr in a StringIO object
  #   require 'stringio'
  #   stderr = StringIO.new
  #   begin
  #   cli.run('log', 'nonexistent-branch', err: stderr)
  #   rescue Git::FailedError => e
  #   stderr.string #=> "unknown revision or path not in the working tree.\n"
  #   end
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @param options_hash [Hash] the options to pass to the command
  # @raise [ArgumentError] if `args` is not an array of strings
  # @raise [Git::SignaledError] if the command was terminated because of an uncaught signal
  # @raise [Git::FailedError] if the command returned a non-zero exitstatus
  # @raise [Git::ProcessIOError] if an exception was raised while collecting subprocess output
  # @raise [Git::TimeoutError] if the command times out
  # @return [Git::CommandLineResult] the output of the command
  #
  #   This result of running the command.
  #
  # source://git//lib/git/command_line.rb#194
  def run(*_arg0, **options_hash); end

  # @api private
  # @return [Git::CommandLineResult] the result of running the command
  #
  # source://git//lib/git/command_line.rb#207
  def run_with_capture(*args, **options_hash); end

  # @api public
  #
  # source://git//lib/git/command_line.rb#215
  def run_with_capture_options(**options_hash); end

  private

  # Build the git command line from the available sources to send to `Process.spawn`
  #
  # @api private
  # @raise [ArgumentError]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line.rb#244
  def build_git_cmd(args); end

  # @api public
  #
  # source://git//lib/git/command_line.rb#291
  def command_line_result(command, result, processed_out, processed_err, timeout); end

  # @api public
  #
  # source://git//lib/git/command_line.rb#286
  def log_result(result, command, processed_out, processed_err); end

  # Post-process and return an array of raw output strings
  #
  # For each raw output string:
  #
  # * If normalize: is true, normalize the encoding by transcoding each line from
  #   the detected encoding to UTF-8.
  # * If chomp: is true chomp the output after normalization.
  #
  # Even if no post-processing is done based on the options, the strings returned
  # are a copy of the raw output strings. The raw output strings are not modified.
  #
  # @api private
  # @param result [ProcessExecuter::ResultWithCapture] the command's output to post-process
  # @param normalize [Boolean] whether to normalize the output of each writer
  # @param chomp [Boolean] whether to chomp the output of each writer
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line.rb#321
  def post_process_output(result, normalize, chomp); end

  # Process the result of the command and return a Git::CommandLineResult
  #
  # Post process output, log the command and result, and raise an error if the
  # command failed.
  #
  # @api private
  # @param result [ProcessExecuter::Command::Result] the result it is a
  #   Process::Status and include command, stdout, and stderr
  # @param normalize [Boolean] whether to normalize the output of each writer
  # @param chomp [Boolean] whether to chomp the output of each writer
  # @param timeout [Numeric, nil] the maximum seconds to wait for the command to
  #   complete
  # @raise [Git::FailedError] if the command failed
  # @raise [Git::SignaledError] if the command was signaled
  # @raise [Git::TimeoutError] if the command times out
  # @raise [Git::ProcessIOError] if an exception was raised while collecting
  #   subprocess output
  # @return [Git::CommandLineResult] the result of the command to return to the
  #   caller
  #
  # source://git//lib/git/command_line.rb#279
  def process_result(result, normalize, chomp, timeout); end
end

# @api public
#
# source://git//lib/git/command_line.rb#228
Git::CommandLine::RUN_ARGS = T.let(T.unsafe(nil), Hash)

# Raised when a git command fails or exits because of an uncaught signal
#
# The git command executed, status, stdout, and stderr are available from this
# object.
#
# The Gem will raise a more specific error for each type of failure:
#
# * {Git::FailedError}: when the git command exits with a non-zero status
# * {Git::SignaledError}: when the git command exits because of an uncaught signal
# * {Git::TimeoutError}: when the git command times out
#
# @api public
#
# source://git//lib/git/errors.rb#89
class Git::CommandLineError < ::Git::Error
  # Create a CommandLineError object
  #
  # @api public
  # @example
  #   `exit 1` # set $? appropriately for this example
  #   result = Git::CommandLineResult.new(%w[git status], $?, 'stdout', 'stderr')
  #   error = Git::CommandLineError.new(result)
  #   error.to_s #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @param result [Git::CommandLineResult] the result of the git command including
  #   the git command, status, stdout, and stderr
  # @return [CommandLineError] a new instance of CommandLineError
  #
  # source://git//lib/git/errors.rb#101
  def initialize(result); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message #=> '["git", "status"], status: pid 89784 exit 1, stderr: "stderr"'
  # @return [String]
  #
  # source://git//lib/git/errors.rb#113
  def error_message; end

  # The result of the git command including the git command and its status and output
  #
  # @api public
  # @example
  #   error.result #=> #<Git::CommandLineResult:0x00000001046bd488 ...>
  # @return [Git::CommandLineResult]
  #
  # source://git//lib/git/errors.rb#126
  def result; end
end

# The result of running a git command
#
# This object stores the Git command executed and its status, stdout, and stderr.
#
# @api public
#
# source://git//lib/git/command_line_result.rb#10
class Git::CommandLineResult
  # Create a CommandLineResult object
  #
  # @api public
  # @example
  #   `true`
  #   git_cmd = %w[git version]
  #   status = $?
  #   stdout = "git version 2.39.1\n"
  #   stderr = ""
  #   result = Git::CommandLineResult.new(git_cmd, status, stdout, stderr)
  # @param git_cmd [Array<String>] the git command that was executed
  # @param status [ProcessExecuter::ResultWithCapture] the status of the process
  # @param stdout [String] the processed stdout of the process
  # @param stderr [String] the processed stderr of the process
  # @return [CommandLineResult] a new instance of CommandLineResult
  #
  # source://git//lib/git/command_line_result.rb#26
  def initialize(git_cmd, status, stdout, stderr); end

  # The git command that was executed
  #
  # @api public
  # @example
  #   git_cmd = %w[git version]
  #   result = Git::CommandLineResult.new(git_cmd, $?, "", "")
  #   result.git_cmd #=> ["git", "version"]
  # @return [Array<String>]
  #
  # source://git//lib/git/command_line_result.rb#50
  def git_cmd; end

  # The status of the process
  #
  # @api public
  # @example
  #   `true`
  #   status = $?
  #   result = Git::CommandLineResult.new(status, "", "")
  #   result.status #=> #<Process::Status: pid 87859 exit 0>
  # @return [Process::Status]
  #
  # source://git//lib/git/command_line_result.rb#64
  def status; end

  # The error output of the process
  #
  # @api public
  # @example
  #   stderr = "Tag not found\n"
  #   result = Git::CommandLineResult.new($?, "", stderr)
  #   result.stderr #=> "Tag not found\n"
  # @return [String]
  #
  # source://git//lib/git/command_line_result.rb#90
  def stderr; end

  # The output of the process
  #
  # @api public
  # @example
  #   stdout = "git version 2.39.1\n"
  #   result = Git::CommandLineResult.new($?, stdout, "")
  #   result.stdout #=> "git version 2.39.1\n"
  # @return [String]
  #
  # source://git//lib/git/command_line_result.rb#77
  def stdout; end
end

# The global configuration for this gem
#
# source://git//lib/git/config.rb#5
class Git::Config
  # @return [Config] a new instance of Config
  #
  # source://git//lib/git/config.rb#8
  def initialize; end

  # source://git//lib/git/config.rb#14
  def binary_path; end

  # Sets the attribute binary_path
  #
  # @param value the value to set the attribute binary_path to.
  #
  # source://git//lib/git/config.rb#6
  def binary_path=(_arg0); end

  # source://git//lib/git/config.rb#18
  def git_ssh; end

  # Sets the attribute git_ssh
  #
  # @param value the value to set the attribute git_ssh to.
  #
  # source://git//lib/git/config.rb#6
  def git_ssh=(_arg0); end

  # source://git//lib/git/config.rb#22
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  #
  # source://git//lib/git/config.rb#6
  def timeout=(_arg0); end
end

# source://git//lib/git.rb#7
Git::Deprecation = T.let(T.unsafe(nil), ActiveSupport::Deprecation)

# object that holds the diff between two commits
#
# source://git//lib/git/diff.rb#8
class Git::Diff
  include ::Enumerable

  # @return [Diff] a new instance of Diff
  #
  # source://git//lib/git/diff.rb#11
  def initialize(base, from = T.unsafe(nil), to = T.unsafe(nil)); end

  # source://git//lib/git/diff.rb#31
  def [](key); end

  # source://git//lib/git/diff.rb#57
  def deletions; end

  # source://git//lib/git/diff.rb#36
  def each(&_arg0); end

  # Returns the value of attribute from.
  #
  # source://git//lib/git/diff.rb#19
  def from; end

  # source://git//lib/git/diff.rb#61
  def insertions; end

  # source://git//lib/git/diff.rb#53
  def lines; end

  # DEPRECATED METHODS
  #
  # source://git//lib/git/diff.rb#49
  def name_status; end

  # source://git//lib/git/diff.rb#26
  def patch; end

  # source://git//lib/git/diff.rb#21
  def path(path); end

  # source://git//lib/git/diff.rb#41
  def size; end

  # source://git//lib/git/diff.rb#65
  def stats; end

  # Returns the value of attribute to.
  #
  # source://git//lib/git/diff.rb#19
  def to; end

  # source://git//lib/git/diff.rb#26
  def to_s; end

  private

  # source://git//lib/git/diff.rb#111
  def path_status_provider; end

  # source://git//lib/git/diff.rb#105
  def process_full; end

  # source://git//lib/git/diff.rb#119
  def process_full_diff; end

  # source://git//lib/git/diff.rb#115
  def stats_provider; end
end

# The changes for a single file within a diff
#
# source://git//lib/git/diff.rb#73
class Git::Diff::DiffFile
  # @return [DiffFile] a new instance of DiffFile
  #
  # source://git//lib/git/diff.rb#79
  def initialize(base, hash); end

  # @return [Boolean]
  #
  # source://git//lib/git/diff.rb#90
  def binary?; end

  # source://git//lib/git/diff.rb#94
  def blob(type = T.unsafe(nil)); end

  # Returns the value of attribute dst.
  #
  # source://git//lib/git/diff.rb#74
  def dst; end

  # Sets the attribute dst
  #
  # @param value the value to set the attribute dst to.
  #
  # source://git//lib/git/diff.rb#74
  def dst=(_arg0); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/diff.rb#74
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/diff.rb#74
  def mode=(_arg0); end

  # Returns the value of attribute patch.
  #
  # source://git//lib/git/diff.rb#74
  def patch; end

  # Sets the attribute patch
  #
  # @param value the value to set the attribute patch to.
  #
  # source://git//lib/git/diff.rb#74
  def patch=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/diff.rb#74
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/diff.rb#74
  def path=(_arg0); end

  # Returns the value of attribute src.
  #
  # source://git//lib/git/diff.rb#74
  def src; end

  # Sets the attribute src
  #
  # @param value the value to set the attribute src to.
  #
  # source://git//lib/git/diff.rb#74
  def src=(_arg0); end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/diff.rb#74
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/diff.rb#74
  def type=(_arg0); end
end

# source://git//lib/git/diff.rb#77
Git::Diff::DiffFile::NIL_BLOB_REGEXP = T.let(T.unsafe(nil), Regexp)

# A private parser class to process the output of `git diff`
#
# @api private
#
# source://git//lib/git/diff.rb#125
class Git::Diff::FullDiffParser
  # @api private
  # @return [FullDiffParser] a new instance of FullDiffParser
  #
  # source://git//lib/git/diff.rb#126
  def initialize(base, patch_text); end

  # @api private
  #
  # source://git//lib/git/diff.rb#134
  def parse; end

  private

  # @api private
  #
  # source://git//lib/git/diff.rb#155
  def append_to_current_file(line); end

  # @api private
  #
  # source://git//lib/git/diff.rb#180
  def check_for_binary(line); end

  # @api private
  #
  # source://git//lib/git/diff.rb#173
  def parse_file_mode_line(line); end

  # @api private
  #
  # source://git//lib/git/diff.rb#165
  def parse_index_line(line); end

  # @api private
  #
  # source://git//lib/git/diff.rb#141
  def process_line(line); end

  # @api private
  #
  # source://git//lib/git/diff.rb#149
  def start_new_file(match, line); end
end

# The files and their status (e.g., added, modified, deleted) between two commits
#
# source://git//lib/git/diff_path_status.rb#5
class Git::DiffPathStatus
  include ::Enumerable

  # @private
  # @return [DiffPathStatus] a new instance of DiffPathStatus
  #
  # source://git//lib/git/diff_path_status.rb#9
  def initialize(base, from, to, path_limiter = T.unsafe(nil)); end

  # Iterates over each file's status.
  #
  # @yield [path, status]
  #
  # source://git//lib/git/diff_path_status.rb#25
  def each(&_arg0); end

  # Returns the name-status report as a Hash.
  #
  # @return [Hash<String, String>] A hash where keys are file paths
  #   and values are their status codes.
  #
  # source://git//lib/git/diff_path_status.rb#33
  def to_h; end

  private

  # Lazily fetches and caches the path status from the git lib.
  #
  # source://git//lib/git/diff_path_status.rb#40
  def fetch_path_status; end
end

# Provides access to the statistics of a diff between two commits,
# including insertions, deletions, and file-level details.
#
# source://git//lib/git/diff_stats.rb#6
class Git::DiffStats
  # @private
  # @return [DiffStats] a new instance of DiffStats
  #
  # source://git//lib/git/diff_stats.rb#8
  def initialize(base, from, to, path_limiter = T.unsafe(nil)); end

  # Returns the total number of lines deleted.
  #
  # source://git//lib/git/diff_stats.rb#22
  def deletions; end

  # Returns a hash of statistics for each file in the diff.
  #
  # @return [Hash<String, {insertions: Integer, deletions: Integer}>]
  #
  # source://git//lib/git/diff_stats.rb#39
  def files; end

  # Returns the total number of lines inserted.
  #
  # source://git//lib/git/diff_stats.rb#27
  def insertions; end

  # Returns the total number of lines changed (insertions + deletions).
  #
  # source://git//lib/git/diff_stats.rb#32
  def lines; end

  # Returns a hash of the total statistics for the diff.
  #
  # @return [{insertions: Integer, deletions: Integer, lines: Integer, files: Integer}]
  #
  # source://git//lib/git/diff_stats.rb#46
  def total; end

  private

  # Lazily fetches and caches the stats from the git lib.
  #
  # source://git//lib/git/diff_stats.rb#53
  def fetch_stats; end
end

# Method that can be used to detect and normalize string encoding
#
# source://git//lib/git/encoding_utils.rb#7
module Git::EncodingUtils
  class << self
    # source://git//lib/git/encoding_utils.rb#12
    def best_guess_encoding; end

    # source://git//lib/git/encoding_utils.rb#8
    def default_encoding; end

    # source://git//lib/git/encoding_utils.rb#17
    def detected_encoding(str); end

    # source://git//lib/git/encoding_utils.rb#21
    def encoding_options; end

    # source://git//lib/git/encoding_utils.rb#25
    def normalize_encoding(str); end
  end
end

# Base class for all custom git module errors
#
# The git gem will only raise an `ArgumentError` or an error that is a subclass of
# `Git::Error`. It does not explicitly raise any other types of errors.
#
# It is recommended to rescue `Git::Error` to catch any runtime error raised by
# this gem unless you need more specific error handling.
#
# Git's custom errors are arranged in the following class heirarchy:
#
# ```text
# StandardError
# > Git::Error
#     > Git::CommandLineError
#        > Git::FailedError
#        > Git::SignaledError
#            > Git::TimeoutError
#     > Git::ProcessIOError
#     > Git::UnexpectedResultError
# ```
#
# | Error Class | Description |
# | --- | --- |
# | `Error` | This catch-all error serves as the base class for other custom errors raised by the git gem. |
# | `CommandLineError` | A subclass of this error is raised when there is a problem executing the git command line. |
# | `FailedError` | This error is raised when the git command line exits with a non-zero status code that is not expected by the git gem. |
# | `SignaledError` | This error is raised when the git command line is terminated as a result of receiving a signal. This could happen if the process is forcibly terminated or if there is a serious system error. |
# | `TimeoutError` | This is a specific type of `SignaledError` that is raised when the git command line operation times out and is killed via the SIGKILL signal. This happens if the operation takes longer than the timeout duration configured in `Git.config.timeout` or via the `:timeout` parameter given in git methods that support timeouts. |
# | `ProcessIOError` | An error was encountered reading or writing to a subprocess. |
# | `UnexpectedResultError` | The command line ran without error but did not return the expected results. |
#
# @api public
# @example Rescuing a timeout error
#   begin
#   timeout_duration = 0.001 # seconds
#   repo = Git.clone('https://github.com/ruby-git/ruby-git', 'ruby-git-temp', timeout: timeout_duration)
#   rescue Git::TimeoutError => e # Catch the more specific error first!
#   puts "Git clone took too long and timed out #{e}"
#   rescue Git::Error => e
#   puts "Received the following error: #{e}"
#   end
# @example Rescuing a generic error
#   begin
#   # some git operation
#   rescue Git::Error => e
#   puts "An error occurred: #{e.message}"
#   end
# @see Git::SignaledError
# @see Git::TimeoutError
# @see Git::ProcessIOError
# @see Git::UnexpectedResultError
# @see Git::CommandLineError
# @see Git::FailedError
#
# source://git//lib/git/errors.rb#63
class Git::Error < ::StandardError; end

# Represents an escaped Git path string
#
# Git commands that output paths (e.g. ls-files, diff), will escape unusual
# characters in the path with backslashes in the same way C escapes control
# characters (e.g. \t for TAB, \n for LF, \\ for backslash) or bytes with values
# larger than 0x80 (e.g. octal \302\265 for "micro" in UTF-8).
#
# @example
#   Git::GitPath.new('\302\265').unescape # => ""
#
# source://git//lib/git/escaped_path.rb#14
class Git::EscapedPath
  # @return [EscapedPath] a new instance of EscapedPath
  #
  # source://git//lib/git/escaped_path.rb#31
  def initialize(path); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/escaped_path.rb#29
  def path; end

  # Convert an escaped path to an unescaped path
  #
  # source://git//lib/git/escaped_path.rb#36
  def unescape; end

  private

  # source://git//lib/git/escaped_path.rb#66
  def escaped_path_to_bytes(path); end

  # source://git//lib/git/escaped_path.rb#48
  def extract_escape(path, index); end

  # source://git//lib/git/escaped_path.rb#44
  def extract_octal(path, index); end

  # source://git//lib/git/escaped_path.rb#52
  def extract_single_char(path, index); end

  # source://git//lib/git/escaped_path.rb#56
  def next_byte(path, index); end
end

# source://git//lib/git/escaped_path.rb#15
Git::EscapedPath::UNESCAPES = T.let(T.unsafe(nil), Hash)

# This error is raised when a git command returns a non-zero exitstatus
#
# The git command executed, status, stdout, and stderr are available from this
# object.
#
# @api public
#
# source://git//lib/git/errors.rb#136
class Git::FailedError < ::Git::CommandLineError; end

# The URI for git's alternative scp-like syntax
#
# This class is necessary to ensure that #to_s returns the same string
# that was passed to the initializer.
#
# @api public
#
# source://git//lib/git/url.rb#85
class Git::GitAltURI < ::Addressable::URI
  # Create a new GitAltURI object
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.to_s #=> 'james@github.com/james/ruby-git'
  # @param user [String, nil] the user from the URL or nil
  # @param host [String] the host from the URL
  # @param path [String] the path from the URL
  # @return [GitAltURI] a new instance of GitAltURI
  #
  # source://git//lib/git/url.rb#96
  def initialize(user:, host:, path:); end

  # Convert the URI to a String
  #
  # Addressible::URI forces path to be absolute by prepending a '/' to the
  # path. This method removes the '/' when converting back to a string
  # since that is what is expected by git. The following is a valid git URL:
  #
  #  `james@github.com:ruby-git/ruby-git.git`
  #
  # and the following (with the initial '/'' in the path) is NOT a valid git URL:
  #
  #  `james@github.com:/ruby-git/ruby-git.git`
  #
  # @api public
  # @example
  #   uri = Git::GitAltURI.new(user: 'james', host: 'github.com', path: 'james/ruby-git')
  #   uri.path #=> '/james/ruby-git'
  #   uri.to_s #=> 'james@github.com:james/ruby-git'
  # @return [String] the URI as a String
  #
  # source://git//lib/git/url.rb#119
  def to_s; end
end

# An alias for Git::Error
#
# Git::GitExecuteError error class is an alias for Git::Error for backwards
# compatibility. It is recommended to use Git::Error directly.
#
# @deprecated Use Git::Error instead
#
# source://git//lib/git/errors.rb#74
Git::GitExecuteError = Git::Error

# source://git//lib/git/index.rb#4
class Git::Index < ::Git::Path; end

# Internal git operations
#
# @api private
#
# source://git//lib/git/lib.rb#18
class Git::Lib
  # Create a new Git::Lib object
  #
  # @api private
  # @overload initialize
  # @overload initialize
  # @return [Lib] a new instance of Lib
  #
  # source://git//lib/git/lib.rb#65
  def initialize(base = T.unsafe(nil), logger = T.unsafe(nil)); end

  # Update the index from the current worktree to prepare the for the next commit
  #
  # @api private
  # @example
  #   lib.add('path/to/file')
  #   lib.add(['path/to/file1','path/to/file2'])
  #   lib.add(:all => true)
  # @option options
  # @option options
  # @param paths [String, Array<String>] files to be added to the repository (relative to the worktree root)
  # @param options [Hash]
  #
  # source://git//lib/git/lib.rb#1048
  def add(paths = T.unsafe(nil), options = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1170
  def apply(patch_file); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1176
  def apply_mail(patch_file); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1507
  def archive(sha, file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Validate that the given arguments cannot be mistaken for a command-line option
  #
  # @api private
  # @param arg_name [String] the name of the arguments to mention in the error message
  # @param args [Array<String, nil>] the arguments to validate
  # @raise [ArgumentError] if any of the parameters are a string starting with a hyphen
  # @return [void]
  #
  # source://git//lib/git/lib.rb#820
  def assert_args_are_not_options(arg_name, *args); end

  # @api private
  #
  # source://git//lib/git/lib.rb#781
  def branch_contains(commit, branch_name = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#776
  def branch_current; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1213
  def branch_delete(branch); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1209
  def branch_new(branch); end

  # @api private
  #
  # source://git//lib/git/lib.rb#694
  def branches_all; end

  # Return a hash of commit data
  #
  # The returned commit data has the following keys:
  #    * tree [String]
  #    * parent [Array<String>]
  #    * author [String] the author name, email, and commit timestamp
  #    * committer [String] the committer name, email, and merge timestamp
  #    * message [String] the commit message
  #    * gpgsig [String] the public signing key of the commit (if signed)
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] commit data
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#482
  def cat_file_commit(object); end

  # Output the contents or other properties of one or more objects.
  #
  # @api private
  # @example Get the contents of a file without a block
  #   lib.cat_file_contents('README.md') # => "This is a README file\n"
  # @example Get the contents of a file with a block
  #   lib.cat_file_contents('README.md') { |f| f.read } # => "This is a README file\n"
  # @param object [String] the object whose contents to return
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object contents
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#408
  def cat_file_contents(object); end

  # Get the size for the given object
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#456
  def cat_file_size(object); end

  # Return a hash of annotated tag data
  #
  # Does not work with lightweight tags. List all annotated tags in your repository
  # with the following command:
  #
  # ```sh
  # git for-each-ref --format='%(refname:strip=2)' refs/tags | \
  #   while read tag; do git cat-file tag $tag >/dev/null 2>&1 && echo $tag; done
  # ```
  #
  # The returned commit data has the following keys:
  #   * object [String] the sha of the tag object
  #   * type [String]
  #   * tag [String] tag name
  #   * tagger [String] the name and email of the user who created the tag
  #     and the timestamp of when the tag was created
  #   * message [String] the tag message
  #
  # @api private
  # @param object [String] the tag to retrieve
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] tag data
  #
  #   Example tag data returned:
  #   ```ruby
  #   {
  #   "name" => "annotated_tag",
  #   "object" => "46abbf07e3c564c723c7c039a43ab3a39e5d02dd",
  #   "type" => "commit",
  #   "tag" => "annotated_tag",
  #   "tagger" => "Scott Chacon <schacon@gmail.com> 1724799270 -0700",
  #   "message" => "Creating an annotated tag\n"
  #   }
  #   ```
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#551
  def cat_file_tag(object); end

  # Get the type for the given object
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#438
  def cat_file_type(object); end

  # @api private
  #
  # source://git//lib/git/lib.rb#666
  def change_head_branch(branch_name); end

  # Runs checkout command to checkout or create branch
  #
  # accepts options:
  #  :new_branch
  #  :force
  #  :start_point
  #
  # @api private
  # @param branch [String]
  # @param opts [Hash]
  #
  # source://git//lib/git/lib.rb#1232
  def checkout(branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1245
  def checkout_file(version, file); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1487
  def checkout_index(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1151
  def clean(opts = T.unsafe(nil)); end

  # Clones a repository into a newly created directory
  #
  # @api private
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param repository_url [String] the URL of the repository to clone
  # @param directory [String, nil] the directory to clone into
  #
  #   If nil, the repository is cloned into a directory with the same name as
  #   the repository.
  # @param opts [Hash] the options for this command
  # @return [Hash] the options to pass to {Git::Base.new}
  # @todo make this work with SSH password or auth_key
  #
  # source://git//lib/git/lib.rb#149
  def clone(repository_url, directory, opts = T.unsafe(nil)); end

  # Takes the commit message with the options and executes the commit command
  #
  # accepts options:
  #  :amend
  #  :all
  #  :allow_empty
  #  :author
  #  :date
  #  :no_verify
  #  :allow_empty_message
  #  :gpg_sign (accepts true or a gpg key ID as a String)
  #  :no_gpg_sign (conflicts with :gpg_sign)
  #
  # @api private
  # @param message [String] the commit message to be used
  # @param opts [Hash] the commit options to be used
  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1123
  def commit(message, opts = T.unsafe(nil)); end

  # Return a hash of commit data
  #
  # The returned commit data has the following keys:
  #    * tree [String]
  #    * parent [Array<String>]
  #    * author [String] the author name, email, and commit timestamp
  #    * committer [String] the committer name, email, and merge timestamp
  #    * message [String] the commit message
  #    * gpgsig [String] the public signing key of the commit (if signed)
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] commit data
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#482
  def commit_data(object); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1468
  def commit_tree(tree, opts = T.unsafe(nil)); end

  # Returns current_command_version <=> other_version
  #
  # @api private
  # @example
  #   lib.current_command_version #=> [2, 42, 0]
  #
  #   lib.compare_version_to(2, 41, 0) #=> 1
  #   lib.compare_version_to(2, 42, 0) #=> 0
  #   lib.compare_version_to(2, 43, 0) #=> -1
  # @param other_version [Array<Object>] the other version to compare to
  # @return [Integer] -1 if this version is less than other_version, 0 if equal, or 1 if greater than
  #
  # source://git//lib/git/lib.rb#1543
  def compare_version_to(*other_version); end

  # @api private
  #
  # source://git//lib/git/lib.rb#972
  def config_get(name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#980
  def config_list; end

  # @api private
  #
  # source://git//lib/git/lib.rb#964
  def config_remote(name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1020
  def config_set(name, value, options = T.unsafe(nil)); end

  # :yields: file, your, their
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#1294
  def conflicts; end

  # The current branch state which is the state of `HEAD`
  #
  # @api private
  # @return [HeadState] the state and name of the current branch
  #
  # source://git//lib/git/lib.rb#768
  def current_branch_state; end

  # returns the current version of git, as an Array of Fixnums.
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#1524
  def current_command_version; end

  # Finds most recent tag that is reachable from a commit
  #
  # @api private
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param commit_ish [String, nil] target commit sha or object name
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String] the tag name
  # @see https://git-scm.com/docs/git-describe git-describe
  #
  # source://git//lib/git/lib.rb#228
  def describe(commit_ish = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the working directory
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#883
  def diff_files; end

  # @api private
  #
  # source://git//lib/git/lib.rb#832
  def diff_full(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # compares the index and the repository
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#888
  def diff_index(treeish); end

  # @api private
  #
  # source://git//lib/git/lib.rb#871
  def diff_path_status(reference1 = T.unsafe(nil), reference2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#851
  def diff_stats(obj1 = T.unsafe(nil), obj2 = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#502
  def each_cat_file_header(data); end

  # Returns true if the repository is empty (meaning it has no commits)
  #
  # @api private
  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1076
  def empty?; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1375
  def fetch(remote, opts); end

  # Return the commits that are within the given revision range
  #
  # @api private
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the revision range (specified with :between or
  #   :object) is a string starting with a hyphen
  # @return [Array<Hash>] the log output parsed into an array of hashs for each commit
  #
  #   Each hash contains the following keys:
  #
  #   * 'sha' [String] the commit sha
  #   * 'author' [String] the author of the commit
  #   * 'message' [String] the commit message
  #   * 'parent' [Array<String>] the commit shas of the parent commits
  #   * 'tree' [String] the tree sha
  #   * 'author' [String] the author of the commit and timestamp of when the
  #   changes were created
  #   * 'committer' [String] the committer of the commit and timestamp of when the
  #   commit was applied
  #   * 'merges' [Boolean] if truthy, only include merge commits (aka commits with
  #   2 or more parents)
  # @see https://git-scm.com/docs/git-log git-log
  #
  # source://git//lib/git/lib.rb#337
  def full_log_commits(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#658
  def full_tree(sha); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1445
  def gc; end

  # The path to the Git repository directory.  The default is
  # `"#{git_work_dir}/.git"`.
  #
  # @api private
  # @return [Pathname] the Git repository directory.
  # @see [Git repository](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefrepositoryarepository)
  #
  # source://git//lib/git/lib.rb#34
  def git_dir; end

  # The Git index file used to stage changes (using `git add`) before they
  # are committed.
  #
  # @api private
  # @return [Pathname] the Git index file
  # @see [Git index file](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefindexaindex)
  #
  # source://git//lib/git/lib.rb#43
  def git_index_file; end

  # The path to the Git working copy.  The default is '"./.git"'.
  #
  # @api private
  # @return [Pathname] the path to the Git working copy.
  # @see [Git working tree](https://git-scm.com/docs/gitglossary#Documentation/gitglossary.txt-aiddefworkingtreeaworkingtree)
  #
  # source://git//lib/git/lib.rb#25
  def git_work_dir; end

  # @api private
  #
  # source://git//lib/git/lib.rb#976
  def global_config_get(name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#984
  def global_config_list; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1026
  def global_config_set(name, value); end

  # returns hash
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  # [tree-ish] = [[line_no, match], [line_no, match2]]
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#797
  def grep(string, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#954
  def ignored_files; end

  # creates or reinitializes the repository
  #
  # options:
  #   :bare
  #   :working_directory
  #   :initial_branch
  #
  # @api private
  #
  # source://git//lib/git/lib.rb#88
  def init(opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#735
  def list_files(ref_dir); end

  # Return the commits that are within the given revision range
  #
  # @api private
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash] the given options
  # @raise [ArgumentError] if the resulting revision range is a string starting with a hyphen
  # @return [Array<String>] the log output
  # @see https://git-scm.com/docs/git-log git-log
  #
  # source://git//lib/git/lib.rb#264
  def log_commits(opts = T.unsafe(nil)); end

  # List all files that are in the index
  #
  # @api private
  # @param location [String] the location to list the files from
  # @return [Hash<String, Hash>] a hash of files in the index
  #   * key: file [String] the file path
  #   * value: file_info [Hash] the file information containing the following keys:
  #   * :path [String] the file path
  #   * :mode_index [String] the file mode
  #   * :sha_index [String] the file sha
  #   * :stage [String] the file stage
  #
  # source://git//lib/git/lib.rb#904
  def ls_files(location = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#944
  def ls_remote(location = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#638
  def ls_tree(sha, opts = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://git//lib/git/lib.rb#1551
  def meets_required_version?; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1258
  def merge(branch, message = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1276
  def merge_base(*args); end

  # @api private
  #
  # source://git//lib/git/lib.rb#654
  def mv(file1, file2); end

  # Find the first symbolic name for given commit_ish
  #
  # @api private
  # @param commit_ish [String] the commit_ish to find the symbolic name of
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String, nil] the first symbolic name or nil if the commit_ish isn't found
  #
  # source://git//lib/git/lib.rb#384
  def name_rev(commit_ish); end

  # Find the first symbolic name for given commit_ish
  #
  # @api private
  # @param commit_ish [String] the commit_ish to find the symbolic name of
  # @raise [ArgumentError] if the commit_ish is a string starting with a hyphen
  # @return [String, nil] the first symbolic name or nil if the commit_ish isn't found
  #
  # source://git//lib/git/lib.rb#384
  def namerev(commit_ish); end

  # Output the contents or other properties of one or more objects.
  #
  # @api private
  # @example Get the contents of a file without a block
  #   lib.cat_file_contents('README.md') # => "This is a README file\n"
  # @example Get the contents of a file with a block
  #   lib.cat_file_contents('README.md') { |f| f.read } # => "This is a README file\n"
  # @param object [String] the object whose contents to return
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object contents
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#408
  def object_contents(object); end

  # Get the size for the given object
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#456
  def object_size(object); end

  # Get the type for the given object
  #
  # @api private
  # @param object [String] the object to get the type
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [String] the object type
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#438
  def object_type(object); end

  # @api private
  #
  # source://git//lib/git/lib.rb#997
  def parse_config(file); end

  # @api private
  #
  # source://git//lib/git/lib.rb#988
  def parse_config_list(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#491
  def process_commit_data(data, sha); end

  # @api private
  #
  # source://git//lib/git/lib.rb#572
  def process_commit_log_data(data); end

  # @api private
  #
  # source://git//lib/git/lib.rb#560
  def process_tag_data(data, name); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1417
  def pull(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1397
  def push(remote = T.unsafe(nil), branch = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1453
  def read_tree(treeish, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1312
  def remote_add(name, url, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1330
  def remote_remove(name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1322
  def remote_set_url(name, url); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1334
  def remotes; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1441
  def repack; end

  # Returns the name of the default branch of the given repository
  #
  # @api private
  # @param repository [URI, Pathname, String] The (possibly remote) repository to clone from
  # @raise [Git::UnexpectedResultError]
  # @return [String] the name of the default branch
  #
  # source://git//lib/git/lib.rb#167
  def repository_default_branch(repository); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1547
  def required_command_version; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1138
  def reset(commit, opts = T.unsafe(nil)); end

  # Verify and resolve a Git revision to its full SHA
  #
  # @api private
  # @example
  #   lib.rev_parse('HEAD') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  #   lib.rev_parse('9b9b31e') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  # @param revision [String] the revision to resolve
  # @raise [ArgumentError] if the revision is a string starting with a hyphen
  # @raise [Git::FailedError] if the revision cannot be resolved
  # @return [String] the full commit hash
  # @see https://git-scm.com/docs/git-rev-parse git-rev-parse
  # @see https://git-scm.com/docs/git-rev-parse#_specifying_revisions Valid ways to specify revisions
  # @see https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrefnamegtemegemmasterememheadsmasterememrefsheadsmasterem Ref disambiguation rules
  #
  # source://git//lib/git/lib.rb#367
  def rev_parse(revision); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1160
  def revert(commitish, opts = T.unsafe(nil)); end

  # Verify and resolve a Git revision to its full SHA
  # For backwards compatibility with the old method name
  #
  # @api private
  # @example
  #   lib.rev_parse('HEAD') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  #   lib.rev_parse('9b9b31e') # => '9b9b31e704c0b85ffdd8d2af2ded85170a5af87d'
  # @param revision [String] the revision to resolve
  # @raise [ArgumentError] if the revision is a string starting with a hyphen
  # @raise [Git::FailedError] if the revision cannot be resolved
  # @return [String] the full commit hash
  # @see https://git-scm.com/docs/git-rev-parse git-rev-parse
  # @see https://git-scm.com/docs/git-rev-parse#_specifying_revisions Valid ways to specify revisions
  # @see https://git-scm.com/docs/git-rev-parse#Documentation/git-rev-parse.txt-emltrefnamegtemegemmasterememheadsmasterememrefsheadsmasterem Ref disambiguation rules
  #
  # source://git//lib/git/lib.rb#367
  def revparse(revision); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1063
  def rm(path = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Shows objects
  #
  # @api private
  # @param objectish [String|NilClass] the target object reference (nil == HEAD)
  # @param path [String|NilClass] the path of the file to be shown
  # @return [String] the object information
  #
  # source://git//lib/git/lib.rb#1006
  def show(objectish = T.unsafe(nil), path = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1193
  def stash_apply(id = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1201
  def stash_clear; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1205
  def stash_list; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1188
  def stash_save(message); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1182
  def stashes_all; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1350
  def tag(name, *args); end

  # Return a hash of annotated tag data
  #
  # Does not work with lightweight tags. List all annotated tags in your repository
  # with the following command:
  #
  # ```sh
  # git for-each-ref --format='%(refname:strip=2)' refs/tags | \
  #   while read tag; do git cat-file tag $tag >/dev/null 2>&1 && echo $tag; done
  # ```
  #
  # The returned commit data has the following keys:
  #   * object [String] the sha of the tag object
  #   * type [String]
  #   * tag [String] tag name
  #   * tagger [String] the name and email of the user who created the tag
  #     and the timestamp of when the tag was created
  #   * message [String] the tag message
  #
  # @api private
  # @param object [String] the tag to retrieve
  # @raise [ArgumentError] if object is a string starting with a hyphen
  # @return [Hash] tag data
  #
  #   Example tag data returned:
  #   ```ruby
  #   {
  #   "name" => "annotated_tag",
  #   "object" => "46abbf07e3c564c723c7c039a43ab3a39e5d02dd",
  #   "type" => "commit",
  #   "tag" => "annotated_tag",
  #   "tagger" => "Scott Chacon <schacon@gmail.com> 1724799270 -0700",
  #   "message" => "Creating an annotated tag\n"
  #   }
  #   ```
  # @see https://git-scm.com/docs/git-cat-file git-cat-file
  #
  # source://git//lib/git/lib.rb#551
  def tag_data(object); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1428
  def tag_sha(tag_name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1338
  def tags; end

  # @api private
  #
  # source://git//lib/git/lib.rb#662
  def tree_depth(sha); end

  # Unescape a path if it is quoted
  #
  # Git commands that output paths (e.g. ls-files, diff), will escape unusual
  # characters.
  #
  # @api private
  # @example
  #   lib.unescape_if_quoted('"quoted_file_\\342\\230\\240"') # => 'quoted_file_'
  #   lib.unescape_if_quoted('unquoted_file')   # => 'unquoted_file'
  # @param path [String] the path to unescape if quoted
  # @return [String] the unescaped path if quoted otherwise the original path
  #
  # source://git//lib/git/lib.rb#932
  def unescape_quoted_path(path); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1286
  def unmerged; end

  # @api private
  #
  # source://git//lib/git/lib.rb#958
  def untracked_files; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1476
  def update_ref(ref, commit); end

  # @api private
  #
  # source://git//lib/git/lib.rb#721
  def worktree_add(dir, commitish = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#731
  def worktree_prune; end

  # @api private
  #
  # source://git//lib/git/lib.rb#727
  def worktree_remove(dir); end

  # @api private
  #
  # source://git//lib/git/lib.rb#701
  def worktrees_all; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1459
  def write_tree; end

  private

  # @api private
  #
  # source://git//lib/git/lib.rb#1871
  def apply_gzip(file); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1623
  def build_args(opts, option_map); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1612
  def build_checkout_positional_args(branch, opts); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1765
  def build_files_hash(file_stats); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1747
  def build_final_stats_hash(file_stats); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1846
  def build_push_args(remote, branch, opts); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1754
  def build_total_stats(file_stats); end

  # Runs a git command and returns the output
  #
  # Additional args are passed to the command line. They should exclude the 'git'
  # command itself and global options. Remember to splat the the arguments if given
  # as an array.
  #
  # For example, to run `git log --pretty=oneline`, you would create the array
  # `args = ['log', '--pretty=oneline']` and call `command(*args)`.
  #
  # is true)
  #
  # @api private
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @option options_hash
  # @param options_hash [Hash] the options to pass to the command
  # @raise [ArgumentError] if an unknown option is passed
  # @raise [Git::FailedError] if the command failed
  # @raise [Git::SignaledError] if the command was signaled
  # @raise [Git::TimeoutError] if the command times out
  # @raise [Git::ProcessIOError] if an exception was raised while collecting subprocess output
  #
  #   The exception's `result` attribute is a {Git::CommandLineResult} which will
  #   contain the result of the command including the exit status, stdout, and
  #   stderr.
  # @return [String] the command's stdout (or merged stdout and stderr if `merge`
  # @see Git::CommandLine#run
  #
  # source://git//lib/git/lib.rb#1956
  def command(*_arg0, **options_hash); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1904
  def command_line; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1876
  def command_lines(cmd, *opts, chdir: T.unsafe(nil)); end

  # Takes the diff command line output (as Array) and parse it into a Hash
  #
  # @api private
  # @param diff_command [String] the diff commadn to be used
  # @param opts [Array] the diff options to be used
  # @return [Hash] the diff as Hash
  #
  # source://git//lib/git/lib.rb#1972
  def diff_as_hash(diff_command, opts = T.unsafe(nil)); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1886
  def env_overrides; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1706
  def execute_grep_command(args); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1674
  def format_branch_data(match_data); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1695
  def get_branch_state(branch_name); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1896
  def global_opts; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1627
  def initialize_from_base(base_object); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1633
  def initialize_from_hash(base_hash); end

  # Returns an array holding the common options for the log commands
  #
  # @api private
  # @param opts [Hash] the given options
  # @return [Array] the set of common options that the log command will use
  #
  # source://git//lib/git/lib.rb#1991
  def log_common_options(opts); end

  # Retrurns an array holding path options for the log commands
  #
  # @api private
  # @param opts [Hash] the given options
  # @return [Array] the set of path options that the log command will use
  #
  # source://git//lib/git/lib.rb#2003
  def log_path_options(opts); end

  # @api private
  # @raise [Git::UnexpectedResultError]
  #
  # source://git//lib/git/lib.rb#1667
  def match_branch_line(line, index, all_lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1831
  def normalize_push_args(remote, branch, opts); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1864
  def parse_archive_format_options(opts); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1659
  def parse_branch_line(line, index, all_lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1605
  def parse_diff_path_status(args); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1725
  def parse_diff_stats_output(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1715
  def parse_grep_output(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1780
  def parse_ls_remote_line(line); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1769
  def parse_ls_remote_output(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1799
  def parse_stash_log_line(line, index); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1730
  def parse_stat_lines(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1647
  def process_commit_headers(data); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1639
  def return_base_opts_from_clone(clone_dir, opts); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1741
  def split_status_line(line); end

  # @api private
  #
  # source://git//lib/git/lib.rb#1792
  def stash_log_lines; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1857
  def temp_file_name; end

  # @api private
  #
  # source://git//lib/git/lib.rb#1683
  def unexpected_branch_line_error(lines, line, index); end

  # @api private
  # @raise [ArgumentError]
  #
  # source://git//lib/git/lib.rb#1822
  def validate_tag_options!(opts); end

  # Writes the staged content of a conflicted file to an IO stream
  #
  # @api private
  # @param path [String] the path to the file in the index
  # @param stage [Integer] the stage of the file to show (e.g., 2 for 'ours', 3 for 'theirs')
  # @param out_io [IO] the IO object to write the staged content to
  # @return [IO] the IO object that was written to
  #
  # source://git//lib/git/lib.rb#1817
  def write_staged_content(path, stage, out_io); end

  class << self
    # @api private
    #
    # source://git//lib/git/lib.rb#1555
    def warn_if_old_command(lib); end
  end
end

# @api private
#
# source://git//lib/git/lib.rb#1030
Git::Lib::ADD_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1498
Git::Lib::ARCHIVE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#670
Git::Lib::BRANCH_LINE_REGEXP = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://git//lib/git/lib.rb#500
Git::Lib::CAT_FILE_HEADER_LINE = T.let(T.unsafe(nil), Regexp)

# @api private
#
# source://git//lib/git/lib.rb#1480
Git::Lib::CHECKOUT_INDEX_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1217
Git::Lib::CHECKOUT_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1144
Git::Lib::CLEAN_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#93
Git::Lib::CLONE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1568
Git::Lib::COMMAND_ARG_DEFAULTS = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://git//lib/git/lib.rb#1086
Git::Lib::COMMIT_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1463
Git::Lib::COMMIT_TREE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# WRITE COMMANDS ##
#
# @api private
#
# source://git//lib/git/lib.rb#1016
Git::Lib::CONFIG_SET_OPTION_MAP = T.let(T.unsafe(nil), Array)

# The map defining how to translate user options to git command arguments.
#
# @api private
#
# source://git//lib/git/lib.rb#182
Git::Lib::DESCRIBE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#827
Git::Lib::DIFF_FULL_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#866
Git::Lib::DIFF_PATH_STATUS_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#846
Git::Lib::DIFF_STATS_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1363
Git::Lib::FETCH_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#277
Git::Lib::FULL_LOG_EXTRA_OPTIONS_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#785
Git::Lib::GREP_OPTION_MAP = T.let(T.unsafe(nil), Array)

# The state and name of branch pointed to by `HEAD`
#
# HEAD can be in the following states:
#
# **:active**: `HEAD` points to a branch reference which in turn points to a
# commit representing the tip of that branch. This is the typical state when
# working on a branch.
#
# **:unborn**: `HEAD` points to a branch reference that does not yet exist
# because no commits have been made on that branch. This state occurs in two
# scenarios:
#
# * When a repository is newly initialized, and no commits have been made on the
#   initial branch.
# * When a new branch is created using `git checkout --orphan <branch>`, starting
#   a new branch with no history.
#
# **:detached**: `HEAD` points directly to a specific commit (identified by its
# SHA) rather than a branch reference. This state occurs when you check out a
# commit, a tag, or any state that is not directly associated with a branch. The
# branch name in this case is `HEAD`.
#
# @api private
#
# source://git//lib/git/lib.rb#762
class Git::Lib::HeadState < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute state
  #
  # @return [Object] the current value of state
  def state; end

  # Sets the attribute state
  #
  # @param value [Object] the value to set the attribute state to.
  # @return [Object] the newly set value
  def state=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# @api private
#
# source://git//lib/git/lib.rb#76
Git::Lib::INIT_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1591
Git::Lib::LOG_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#940
Git::Lib::LS_REMOTE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#634
Git::Lib::LS_TREE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1269
Git::Lib::MERGE_BASE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1252
Git::Lib::MERGE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1413
Git::Lib::PULL_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1388
Git::Lib::PUSH_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1449
Git::Lib::READ_TREE_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1307
Git::Lib::REMOTE_ADD_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1134
Git::Lib::RESET_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1156
Git::Lib::REVERT_OPTION_MAP = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1057
Git::Lib::RM_OPTION_MAP = T.let(T.unsafe(nil), Array)

# A private parser class to process the output of `git log --pretty=raw`
#
# @api private
#
# source://git//lib/git/lib.rb#578
class Git::Lib::RawLogParser
  # @api private
  # @return [RawLogParser] a new instance of RawLogParser
  #
  # source://git//lib/git/lib.rb#579
  def initialize(lines); end

  # @api private
  #
  # source://git//lib/git/lib.rb#586
  def parse; end

  private

  # @api private
  #
  # source://git//lib/git/lib.rb#628
  def finalize_commit; end

  # @api private
  #
  # source://git//lib/git/lib.rb#594
  def process_line(line); end

  # @api private
  #
  # source://git//lib/git/lib.rb#605
  def process_message_line(line); end

  # @api private
  #
  # source://git//lib/git/lib.rb#609
  def process_metadata_line(line); end

  # @api private
  #
  # source://git//lib/git/lib.rb#623
  def start_new_commit(sha); end
end

# @api private
#
# source://git//lib/git/lib.rb#1578
Git::Lib::STATIC_GLOBAL_OPTS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://git//lib/git/lib.rb#1342
Git::Lib::TAG_OPTION_MAP = T.let(T.unsafe(nil), Array)

# Builds and executes a `git log` query.
#
# This class provides a fluent interface for building complex `git log` queries.
# The query is lazily executed when results are requested either via the modern
# `#execute` method or the deprecated Enumerable methods.
#
# @api public
# @example Using the modern `execute` API
#   log = git.log.max_count(50).between('v1.0', 'v1.1').author('Scott')
#   results = log.execute
#   puts "Found #{results.size} commits."
#   results.each { |commit| puts commit.sha }
#
# source://git//lib/git/log.rb#18
class Git::Log
  include ::Enumerable

  # Create a new Git::Log object
  #
  # @api public
  # @example
  #   git = Git.open('.')
  #   Git::Log.new(git)
  # @param base [Git::Base] the git repository object
  # @param max_count [Integer, Symbol, nil] the number of commits to return, or
  #   `:all` or `nil` to return all
  #
  #   Passing max_count to {#initialize} is equivalent to calling {#max_count} on the object.
  # @return [Log] a new instance of Log
  #
  # source://git//lib/git/log.rb#46
  def initialize(base, max_count = T.unsafe(nil)); end

  # @api public
  # @deprecated Use {#execute} and call the method on the result.
  #
  # source://git//lib/git/log.rb#137
  def [](index); end

  # @api public
  #
  # source://git//lib/git/log.rb#57
  def all; end

  # @api public
  #
  # source://git//lib/git/log.rb#59
  def author(regex); end

  # @api public
  #
  # source://git//lib/git/log.rb#65
  def between(val1, val2 = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/log.rb#66
  def cherry; end

  # @api public
  # @deprecated Use {#execute} and call `each` on the result.
  #
  # source://git//lib/git/log.rb#92
  def each(&_arg0); end

  # Executes the git log command and returns an immutable result object
  #
  # This is the preferred way to get log data. It separates the query
  # building from the execution, making the API more predictable.
  #
  # @api public
  # @example
  #   query = g.log.since('2 weeks ago').author('Scott')
  #   results = query.execute
  #   puts "Found #{results.size} commits"
  #   results.each do |commit|
  #   # ...
  #   end
  # @return [Git::Log::Result] an object containing the log results
  #
  # source://git//lib/git/log.rb#84
  def execute; end

  # @api public
  # @deprecated Use {#execute} and call the method on the result.
  #
  # source://git//lib/git/log.rb#119
  def first; end

  # @api public
  #
  # source://git//lib/git/log.rb#60
  def grep(regex); end

  # @api public
  # @deprecated Use {#execute} and call the method on the result.
  #
  # source://git//lib/git/log.rb#128
  def last; end

  # Set query options using a fluent interface.
  # Each method returns `self` to allow for chaining.
  #
  # @api public
  #
  # source://git//lib/git/log.rb#56
  def max_count(num); end

  # @api public
  #
  # source://git//lib/git/log.rb#67
  def merges; end

  # @api public
  #
  # source://git//lib/git/log.rb#58
  def object(objectish); end

  # @api public
  #
  # source://git//lib/git/log.rb#61
  def path(path); end

  # @api public
  #
  # source://git//lib/git/log.rb#63
  def since(date); end

  # @api public
  # @deprecated Use {#execute} and call `size` on the result.
  #
  # source://git//lib/git/log.rb#101
  def size; end

  # @api public
  #
  # source://git//lib/git/log.rb#62
  def skip(num); end

  # @api public
  # @deprecated Use {#execute} and call `to_s` on the result.
  #
  # source://git//lib/git/log.rb#110
  def to_s; end

  # @api public
  #
  # source://git//lib/git/log.rb#64
  def until(date); end

  private

  # @api public
  #
  # source://git//lib/git/log.rb#155
  def run_log_if_dirty; end

  # @api public
  #
  # source://git//lib/git/log.rb#149
  def set_option(key, value); end
end

# An immutable, Enumerable collection of `Git::Object::Commit` objects.
# Returned by `Git::Log#execute`.
#
# @api public
class Git::Log::Result < ::Data
  include ::Enumerable

  # source://git//lib/git/log.rb#29
  def [](index); end

  def commits; end

  # source://git//lib/git/log.rb#27
  def each(&block); end

  # source://git//lib/git/log.rb#28
  def last; end

  # source://git//lib/git/log.rb#31
  def size; end

  # source://git//lib/git/log.rb#30
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# represents a git object
#
# source://git//lib/git/object.rb#10
class Git::Object
  class << self
    # if we're calling this, we don't know what type it is yet
    # so this is our little factory method
    #
    # source://git//lib/git/object.rb#316
    def new(base, objectish, type = T.unsafe(nil), is_tag = T.unsafe(nil)); end

    private

    # source://git//lib/git/object.rb#330
    def new_tag(base, objectish); end
  end
end

# A base class for all Git objects
#
# source://git//lib/git/object.rb#12
class Git::Object::AbstractObject
  # @return [AbstractObject] a new instance of AbstractObject
  #
  # source://git//lib/git/object.rb#17
  def initialize(base, objectish); end

  # creates an archive of this object (tree)
  #
  # source://git//lib/git/object.rb#70
  def archive(file = T.unsafe(nil), opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#76
  def blob?; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#78
  def commit?; end

  # Get the object's contents.
  # If no block is given, the contents are cached in memory and returned as a string.
  # If a block is given, it yields an IO object (via IO::popen) which could be used to
  # read a large file in chunks.
  #
  # Use this for large files so that they are not held in memory.
  #
  # source://git//lib/git/object.rb#40
  def contents(&_arg0); end

  # source://git//lib/git/object.rb#48
  def contents_array; end

  # source://git//lib/git/object.rb#61
  def diff(objectish); end

  # source://git//lib/git/object.rb#56
  def grep(string, path_limiter = T.unsafe(nil), opts = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#65
  def log(count = T.unsafe(nil)); end

  # Returns the value of attribute mode.
  #
  # source://git//lib/git/object.rb#13
  def mode; end

  # Sets the attribute mode
  #
  # @param value the value to set the attribute mode to.
  #
  # source://git//lib/git/object.rb#13
  def mode=(_arg0); end

  # Returns the value of attribute objectish.
  #
  # source://git//lib/git/object.rb#13
  def objectish; end

  # Sets the attribute objectish
  #
  # @param value the value to set the attribute objectish to.
  #
  # source://git//lib/git/object.rb#13
  def objectish=(_arg0); end

  # source://git//lib/git/object.rb#26
  def sha; end

  # source://git//lib/git/object.rb#30
  def size; end

  # Sets the attribute size
  #
  # @param value the value to set the attribute size to.
  #
  # source://git//lib/git/object.rb#15
  def size=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#80
  def tag?; end

  # source://git//lib/git/object.rb#52
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#74
  def tree?; end

  # Returns the value of attribute type.
  #
  # source://git//lib/git/object.rb#13
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://git//lib/git/object.rb#13
  def type=(_arg0); end
end

# A Git blob object
#
# source://git//lib/git/object.rb#84
class Git::Object::Blob < ::Git::Object::AbstractObject
  # @return [Blob] a new instance of Blob
  #
  # source://git//lib/git/object.rb#85
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#90
  def blob?; end
end

# A Git commit object
#
# source://git//lib/git/object.rb#153
class Git::Object::Commit < ::Git::Object::AbstractObject
  # @return [Commit] a new instance of Commit
  #
  # source://git//lib/git/object.rb#154
  def initialize(base, sha, init = T.unsafe(nil)); end

  # git author
  #
  # source://git//lib/git/object.rb#191
  def author; end

  # source://git//lib/git/object.rb#196
  def author_date; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#229
  def commit?; end

  # git author
  #
  # source://git//lib/git/object.rb#201
  def committer; end

  # source://git//lib/git/object.rb#206
  def committer_date; end

  # source://git//lib/git/object.rb#206
  def date; end

  # source://git//lib/git/object.rb#211
  def diff_parent; end

  # source://git//lib/git/object.rb#220
  def from_data(data); end

  # source://git//lib/git/object.rb#175
  def gtree; end

  # source://git//lib/git/object.rb#166
  def message; end

  # source://git//lib/git/object.rb#171
  def name; end

  # source://git//lib/git/object.rb#180
  def parent; end

  # array of all parent commits
  #
  # source://git//lib/git/object.rb#185
  def parents; end

  # source://git//lib/git/object.rb#215
  def set_commit(data); end

  private

  # see if this object has been initialized and do so if not
  #
  # source://git//lib/git/object.rb#236
  def check_commit; end
end

# A Git tag object
#
# This class represents a tag in Git, which can be either annotated or lightweight.
#
# Annotated tags contain additional metadata such as the tagger's name, email, and
# the date when the tag was created, along with a message.
#
# TODO: Annotated tags are not objects
#
# source://git//lib/git/object.rb#253
class Git::Object::Tag < ::Git::Object::AbstractObject
  # @overload initialize
  # @overload initialize
  # @return [Tag] a new instance of Tag
  #
  # source://git//lib/git/object.rb#265
  def initialize(base, sha, name = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#279
  def annotated?; end

  # source://git//lib/git/object.rb#283
  def message; end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/object.rb#254
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/object.rb#254
  def name=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#288
  def tag?; end

  # source://git//lib/git/object.rb#292
  def tagger; end

  private

  # source://git//lib/git/object.rb#299
  def check_tag; end
end

# A Git tree object
#
# source://git//lib/git/object.rb#96
class Git::Object::Tree < ::Git::Object::AbstractObject
  # @return [Tree] a new instance of Tree
  #
  # source://git//lib/git/object.rb#97
  def initialize(base, sha, mode = T.unsafe(nil)); end

  # source://git//lib/git/object.rb#108
  def blobs; end

  # source://git//lib/git/object.rb#104
  def children; end

  # source://git//lib/git/object.rb#123
  def depth; end

  # source://git//lib/git/object.rb#108
  def files; end

  # source://git//lib/git/object.rb#119
  def full_tree; end

  # source://git//lib/git/object.rb#113
  def subdirectories; end

  # source://git//lib/git/object.rb#113
  def subtrees; end

  # @return [Boolean]
  #
  # source://git//lib/git/object.rb#127
  def tree?; end

  # source://git//lib/git/object.rb#113
  def trees; end

  private

  # actually run the git command
  #
  # source://git//lib/git/object.rb#134
  def check_tree; end
end

# A base class that represents and validates a filesystem path
#
# Use for tracking things relevant to a Git repository, such as the working
# directory or index file.
#
# source://git//lib/git/path.rb#9
class Git::Path
  # @raise [ArgumentError]
  # @return [Path] a new instance of Path
  #
  # source://git//lib/git/path.rb#12
  def initialize(path, must_exist: T.unsafe(nil)); end

  # Returns the value of attribute path.
  #
  # source://git//lib/git/path.rb#10
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://git//lib/git/path.rb#10
  def path=(_arg0); end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#20
  def readable?; end

  # source://git//lib/git/path.rb#28
  def to_s; end

  # @return [Boolean]
  #
  # source://git//lib/git/path.rb#24
  def writable?; end
end

# Raised when the output of a git command can not be read
#
# @api public
#
# source://git//lib/git/errors.rb#205
class Git::ProcessIOError < ::Git::Error; end

# A remote in a Git repository
#
# source://git//lib/git/remote.rb#5
class Git::Remote
  # @return [Remote] a new instance of Remote
  #
  # source://git//lib/git/remote.rb#8
  def initialize(base, name); end

  # source://git//lib/git/remote.rb#26
  def branch(branch = T.unsafe(nil)); end

  # source://git//lib/git/remote.rb#16
  def fetch(opts = T.unsafe(nil)); end

  # Returns the value of attribute fetch_opts.
  #
  # source://git//lib/git/remote.rb#6
  def fetch_opts; end

  # Sets the attribute fetch_opts
  #
  # @param value the value to set the attribute fetch_opts to.
  #
  # source://git//lib/git/remote.rb#6
  def fetch_opts=(_arg0); end

  # merge this remote locally
  #
  # source://git//lib/git/remote.rb#21
  def merge(branch = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://git//lib/git/remote.rb#6
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://git//lib/git/remote.rb#6
  def name=(_arg0); end

  # source://git//lib/git/remote.rb#31
  def remove; end

  # source://git//lib/git/remote.rb#35
  def to_s; end

  # Returns the value of attribute url.
  #
  # source://git//lib/git/remote.rb#6
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  #
  # source://git//lib/git/remote.rb#6
  def url=(_arg0); end
end

# source://git//lib/git/repository.rb#4
class Git::Repository < ::Git::Path; end

# This error is raised when a git command exits because of an uncaught signal
#
# @api public
#
# source://git//lib/git/errors.rb#142
class Git::SignaledError < ::Git::CommandLineError; end

# A stash in a Git repository
#
# source://git//lib/git/stash.rb#5
class Git::Stash
  # @return [Stash] a new instance of Stash
  #
  # source://git//lib/git/stash.rb#6
  def initialize(base, message, save: T.unsafe(nil)); end

  # Returns the value of attribute message.
  #
  # source://git//lib/git/stash.rb#20
  def message; end

  # source://git//lib/git/stash.rb#12
  def save; end

  # @return [Boolean]
  #
  # source://git//lib/git/stash.rb#16
  def saved?; end

  # source://git//lib/git/stash.rb#22
  def to_s; end
end

# object that holds all the available stashes
#
# source://git//lib/git/stashes.rb#5
class Git::Stashes
  include ::Enumerable

  # @return [Stashes] a new instance of Stashes
  #
  # source://git//lib/git/stashes.rb#8
  def initialize(base); end

  # source://git//lib/git/stashes.rb#52
  def [](index); end

  # Returns an multi-dimensional Array of elements that have been stash saved.
  # Array is based on position and name. See Example
  #
  # @example Returns Array of items that have been stashed
  #   .all - [0, "testing-stash-all"]]
  # @return [Array]
  #
  # source://git//lib/git/stashes.rb#26
  def all; end

  # source://git//lib/git/stashes.rb#35
  def apply(index = T.unsafe(nil)); end

  # source://git//lib/git/stashes.rb#39
  def clear; end

  # source://git//lib/git/stashes.rb#48
  def each(&_arg0); end

  # source://git//lib/git/stashes.rb#30
  def save(message); end

  # source://git//lib/git/stashes.rb#44
  def size; end
end

# The Status class gets the status of a git repository. It identifies which
# files have been modified, added, or deleted, including untracked files.
# The Status object is an Enumerable of StatusFile objects.
#
# @api public
#
# source://git//lib/git/status.rb#12
class Git::Status
  include ::Enumerable

  # @api public
  # @param base [Git::Base] The base git object
  # @return [Status] a new instance of Status
  #
  # source://git//lib/git/status.rb#16
  def initialize(base); end

  # Access a status file by path, or iterate over all status files.
  #
  # @api public
  #
  # source://git//lib/git/status.rb#36
  def [](file); end

  # @api public
  #
  # source://git//lib/git/status.rb#24
  def added; end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#31
  def added?(file); end

  # File status collections, memoized for performance.
  #
  # @api public
  #
  # source://git//lib/git/status.rb#23
  def changed; end

  # Predicate methods to check the status of a specific file.
  #
  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#30
  def changed?(file); end

  # @api public
  #
  # source://git//lib/git/status.rb#25
  def deleted; end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#32
  def deleted?(file); end

  # @api public
  #
  # source://git//lib/git/status.rb#37
  def each(&_arg0); end

  # Returns a formatted string representation of the status.
  #
  # @api public
  #
  # source://git//lib/git/status.rb#40
  def pretty; end

  # This works with `true` or `nil`
  #
  # @api public
  #
  # source://git//lib/git/status.rb#27
  def untracked; end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#33
  def untracked?(file); end

  private

  # @api public
  #
  # source://git//lib/git/status.rb#70
  def downcased_keys(collection_name); end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#61
  def file_in_collection?(collection_name, file_path); end

  # @api public
  # @return [Boolean]
  #
  # source://git//lib/git/status.rb#76
  def ignore_case?; end

  # @api public
  #
  # source://git//lib/git/status.rb#46
  def pretty_file(file); end

  # @api public
  #
  # source://git//lib/git/status.rb#57
  def select_files(&block); end
end

# Represents a single file's status in the git repository. Each instance
# holds information about a file's state in the index and working tree.
#
# @api public
#
# source://git//lib/git/status.rb#90
class Git::Status::StatusFile
  # @api public
  # @return [StatusFile] a new instance of StatusFile
  #
  # source://git//lib/git/status.rb#94
  def initialize(base, hash); end

  # Returns a Git::Object::Blob for either the index or repo version of the file.
  #
  # @api public
  #
  # source://git//lib/git/status.rb#107
  def blob(type = T.unsafe(nil)); end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def mode_index; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def mode_repo; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def path; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def sha_index; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def sha_repo; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def stage; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def type; end

  # @api public
  #
  # source://git//lib/git/status.rb#91
  def untracked; end
end

# A factory class responsible for fetching git status data and building
# a hash of StatusFile objects.
#
# @api private
#
# source://git//lib/git/status.rb#120
class Git::Status::StatusFileFactory
  # @api private
  # @return [StatusFileFactory] a new instance of StatusFileFactory
  #
  # source://git//lib/git/status.rb#121
  def initialize(base); end

  # Gathers all status data and builds a hash of file paths to
  # StatusFile objects.
  #
  # @api private
  #
  # source://git//lib/git/status.rb#128
  def construct_files; end

  private

  # Fetches and merges status information from multiple git commands.
  #
  # @api private
  #
  # source://git//lib/git/status.rb#138
  def fetch_all_files_data; end

  # @api private
  #
  # source://git//lib/git/status.rb#159
  def merge_head_diffs(files); end

  # @api private
  #
  # source://git//lib/git/status.rb#152
  def merge_modified_files(files); end

  # @api private
  #
  # source://git//lib/git/status.rb#146
  def merge_untracked_files(files); end
end

# This error is raised when a git command takes longer than the configured timeout
#
# The git command executed, status, stdout, and stderr, and the timeout duration
# are available from this object.
#
# result.status.timeout? will be `true`
#
# @api public
#
# source://git//lib/git/errors.rb#153
class Git::TimeoutError < ::Git::SignaledError
  # Create a TimeoutError object
  #
  # @api public
  # @example
  #   command = %w[sleep 10]
  #   timeout_duration = 1
  #   status = ProcessExecuter.spawn(*command, timeout: timeout_duration)
  #   result = Git::CommandLineResult.new(command, status, 'stdout', 'err output')
  #   error = Git::TimeoutError.new(result, timeout_duration)
  #   error.error_message
  #   #=> '["sleep", "10"], status: pid 70144 SIGKILL (signal 9), stderr: "err output", timed out after 1s'
  # @param result [Git::CommandLineResult] the result of the git command including
  #   the git command, status, stdout, and stderr
  # @param timeout_duration [Numeric] the amount of time the subprocess was allowed
  #   to run before being killed
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://git//lib/git/errors.rb#171
  def initialize(result, timeout_duration); end

  # The human readable representation of this error
  #
  # @api public
  # @example
  #   error.error_message
  #   #=> '["sleep", "10"], status: pid 88811 SIGKILL (signal 9), stderr: "err output", timed out after 1s'
  # @return [String]
  #
  # source://git//lib/git/errors.rb#184
  def error_message; end

  # The amount of time the subprocess was allowed to run before being killed
  #
  # @api public
  # @example
  #   `kill -9 $$` # set $? appropriately for this example
  #   result = Git::CommandLineResult.new(%w[git status], $?, '', "killed")
  #   error = Git::TimeoutError.new(result, 10)
  #   error.timeout_duration #=> 10
  # @return [Numeric]
  #
  # source://git//lib/git/errors.rb#198
  def timeout_duration; end
end

# Methods for parsing a Git URL
#
# Any URL that can be passed to `git clone` can be parsed by this class.
#
# @api public
# @see https://git-scm.com/docs/git-clone#_git_urls GIT URLs
# @see https://github.com/sporkmonger/addressable Addresable::URI
#
# source://git//lib/git/url.rb#15
class Git::URL
  class << self
    # The directory `git clone` would use for the repository directory for the given URL
    #
    # @api public
    # @example
    #   Git::URL.clone_to('https://github.com/ruby-git/ruby-git.git') #=> 'ruby-git'
    # @param url [String] the Git URL containing the repository directory
    # @return [String] the name of the repository directory
    #
    # source://git//lib/git/url.rb#64
    def clone_to(url, bare: T.unsafe(nil), mirror: T.unsafe(nil)); end

    # Parse a Git URL and return an Addressable::URI object
    #
    # The URI returned can be converted back to a string with 'to_s'. This is
    # guaranteed to return the same URL string that was parsed.
    #
    # @api public
    # @example
    #   uri = Git::URL.parse('https://github.com/ruby-git/ruby-git.git')
    #   #=> #<Addressable::URI:0x44c URI:https://github.com/ruby-git/ruby-git.git>
    #   uri.scheme #=> "https"
    #   uri.host #=> "github.com"
    #   uri.path #=> "/ruby-git/ruby-git.git"
    #
    #   Git::URL.parse('/Users/James/projects/ruby-git')
    #   #=> #<Addressable::URI:0x438 URI:/Users/James/projects/ruby-git>
    # @param url [String] the Git URL to parse
    # @return [Addressable::URI] the parsed URI
    #
    # source://git//lib/git/url.rb#47
    def parse(url); end
  end
end

# Regexp used to match a Git URL with an alternative SSH syntax
# such as `user@host:path`
#
# @api public
#
# source://git//lib/git/url.rb#19
Git::URL::GIT_ALTERNATIVE_SSH_SYNTAX = T.let(T.unsafe(nil), Regexp)

# Raised when the git command result was not as expected
#
# @api public
#
# source://git//lib/git/errors.rb#211
class Git::UnexpectedResultError < ::Git::Error; end

# The current gem version
#
# @return [String] the current gem version.
#
# source://git//lib/git/version.rb#6
Git::VERSION = T.let(T.unsafe(nil), String)

# source://git//lib/git/working_directory.rb#4
class Git::WorkingDirectory < ::Git::Path; end

# A worktree in a Git repository
#
# source://git//lib/git/worktree.rb#7
class Git::Worktree
  # @return [Worktree] a new instance of Worktree
  #
  # source://git//lib/git/worktree.rb#10
  def initialize(base, dir, gcommit = T.unsafe(nil)); end

  # source://git//lib/git/worktree.rb#23
  def add; end

  # Returns the value of attribute dir.
  #
  # source://git//lib/git/worktree.rb#8
  def dir; end

  # Sets the attribute dir
  #
  # @param value the value to set the attribute dir to.
  #
  # source://git//lib/git/worktree.rb#8
  def dir=(_arg0); end

  # Returns the value of attribute full.
  #
  # source://git//lib/git/worktree.rb#8
  def full; end

  # Sets the attribute full
  #
  # @param value the value to set the attribute full to.
  #
  # source://git//lib/git/worktree.rb#8
  def full=(_arg0); end

  # source://git//lib/git/worktree.rb#18
  def gcommit; end

  # source://git//lib/git/worktree.rb#27
  def remove; end

  # source://git//lib/git/worktree.rb#31
  def to_a; end

  # source://git//lib/git/worktree.rb#35
  def to_s; end
end

# object that holds all the available worktrees
#
# source://git//lib/git/worktrees.rb#5
class Git::Worktrees
  include ::Enumerable

  # @return [Worktrees] a new instance of Worktrees
  #
  # source://git//lib/git/worktrees.rb#8
  def initialize(base); end

  # source://git//lib/git/worktrees.rb#29
  def [](worktree_name); end

  # source://git//lib/git/worktrees.rb#25
  def each(&_arg0); end

  # source://git//lib/git/worktrees.rb#43
  def prune; end

  # array like methods
  #
  # source://git//lib/git/worktrees.rb#21
  def size; end

  # source://git//lib/git/worktrees.rb#35
  def to_s; end
end

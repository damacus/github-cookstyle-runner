# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/process_executer/all/process_executer.rbi
#
# process_executer-4.0.0

module ProcessExecuter
  def self.command_and_options(options_class, command, options_hash); end
  def self.run(*command, **options_hash); end
  def self.run_with_capture(*command, **options_hash); end
  def self.spawn_with_timeout(*command, **options_hash); end
end
class ProcessExecuter::Error < StandardError
end
class ProcessExecuter::ArgumentError < ProcessExecuter::Error
end
class ProcessExecuter::CommandError < ProcessExecuter::Error
  def error_message; end
  def initialize(result); end
  def result; end
end
class ProcessExecuter::FailedError < ProcessExecuter::CommandError
end
class ProcessExecuter::SignaledError < ProcessExecuter::CommandError
end
class ProcessExecuter::TimeoutError < ProcessExecuter::SignaledError
end
class ProcessExecuter::ProcessIOError < ProcessExecuter::Error
end
class ProcessExecuter::SpawnError < ProcessExecuter::Error
end
module ProcessExecuter::Commands
end
class ProcessExecuter::Commands::SpawnWithTimeout
  def call; end
  def command; end
  def create_result; end
  def elapsed_time; end
  def initialize(command, options); end
  def options; end
  def pid; end
  def result; end
  def status; end
  def timed_out; end
  def timed_out?; end
  def wait_for_process; end
  def wait_for_process_raw; end
end
class ProcessExecuter::Commands::Run < ProcessExecuter::Commands::SpawnWithTimeout
  def call; end
  def log_result; end
  def raise_errors; end
  def raise_pipe_error(option_key, pipe); end
  def should_wrap?(key, value); end
  def wrap_stdout_stderr; end
end
class ProcessExecuter::Commands::RunWithCapture < ProcessExecuter::Commands::Run
  def call; end
  def capture_option(redirection_source, given_source, given_destination, capture_destination); end
  def create_result; end
  def log_command_output; end
  def stderr_buffer; end
  def stderr_redirection_destination; end
  def stderr_redirection_source; end
  def stdout_buffer; end
  def stdout_redirection_destination; end
  def stdout_redirection_source; end
  def update_capture_options; end
end
module ProcessExecuter::Destinations
  def self.compatible_with_monitored_pipe?(destination); end
  def self.factory(destination); end
  def self.matching_destination_class(destination); end
end
class ProcessExecuter::Destinations::DestinationBase
  def close; end
  def compatible_with_monitored_pipe?; end
  def destination; end
  def initialize(destination); end
  def self.compatible_with_monitored_pipe?; end
  def self.handles?(destination); end
  def write(_data); end
end
class ProcessExecuter::Destinations::ChildRedirection < ProcessExecuter::Destinations::DestinationBase
  def self.compatible_with_monitored_pipe?; end
  def self.handles?(destination); end
end
class ProcessExecuter::Destinations::FileDescriptor < ProcessExecuter::Destinations::DestinationBase
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::FilePath < ProcessExecuter::Destinations::DestinationBase
  def close; end
  def file; end
  def initialize(destination); end
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::FilePathMode < ProcessExecuter::Destinations::DestinationBase
  def close; end
  def file; end
  def initialize(destination); end
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::FilePathModePerms < ProcessExecuter::Destinations::DestinationBase
  def close; end
  def file; end
  def initialize(destination); end
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::IO < ProcessExecuter::Destinations::DestinationBase
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::MonitoredPipe < ProcessExecuter::Destinations::DestinationBase
  def close; end
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::Stderr < ProcessExecuter::Destinations::DestinationBase
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::Stdout < ProcessExecuter::Destinations::DestinationBase
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::Tee < ProcessExecuter::Destinations::DestinationBase
  def child_destinations; end
  def close; end
  def initialize(destination); end
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::Destinations::Writer < ProcessExecuter::Destinations::DestinationBase
  def self.handles?(destination); end
  def write(data); end
end
class ProcessExecuter::MonitoredPipe
  def assert_destination_is_compatible_with_monitored_pipe; end
  def chunk_size; end
  def close; end
  def close_pipe; end
  def condition_variable; end
  def destination; end
  def exception; end
  def fileno; end
  def initialize(redirection_destination, chunk_size: nil); end
  def monitor; end
  def monitor_pipe; end
  def mutex; end
  def pipe_reader; end
  def pipe_writer; end
  def start_monitoring_thread; end
  def state; end
  def thread; end
  def to_io; end
  def write(data); end
  def write_data(data); end
  extend TrackOpenInstances::ClassMethods
  include TrackOpenInstances
end
module ProcessExecuter::Options
end
class ProcessExecuter::Options::OptionDefinition
  def default; end
  def initialize(name, default: nil, validator: nil); end
  def name; end
  def validator; end
end
class ProcessExecuter::Options::Base
  def allowed_options; end
  def assert_no_unknown_options; end
  def define_accessor_methods; end
  def define_options; end
  def each_with_object(obj, &); end
  def errors; end
  def initialize(**options_hash); end
  def inspect; end
  def merge!(*other_options_hashes); end
  def merge(*other_options_hashes); end
  def options_hash; end
  def to_h; end
  def to_s; end
  def valid_option?(option); end
  def validate_options; end
end
class ProcessExecuter::Options::SpawnOptions < ProcessExecuter::Options::Base
  def define_options; end
  def include_spawn_option?(option_key, value); end
  def redirection?(option_key); end
  def spawn_options; end
  def std_redirection?(option_key, symbol, fileno); end
  def stderr_redirection?(option_key); end
  def stderr_redirection_destination; end
  def stderr_redirection_source; end
  def stdout_redirection?(option_key); end
  def stdout_redirection_destination; end
  def stdout_redirection_source; end
  def valid_option?(option_key); end
end
class ProcessExecuter::Options::SpawnWithTimeoutOptions < ProcessExecuter::Options::SpawnOptions
  def define_options; end
  def validate_timeout_after(_key, _value); end
end
class ProcessExecuter::Options::RunOptions < ProcessExecuter::Options::SpawnWithTimeoutOptions
  def define_options; end
  def validate_logger(_key, _value); end
  def validate_raise_errors(_key, _value); end
end
class ProcessExecuter::Options::RunWithCaptureOptions < ProcessExecuter::Options::RunOptions
  def define_options; end
  def effective_stderr_encoding; end
  def effective_stdout_encoding; end
  def valid_encoding_type?(key, value); end
  def validate_encoding_option(key, value); end
  def validate_encoding_string(key, value); end
  def validate_encoding_symbol(key, value); end
  def validate_merge_output(_key, _value); end
end
class ProcessExecuter::Result < SimpleDelegator
  def command; end
  def elapsed_time; end
  def initialize(status, command:, options:, timed_out:, elapsed_time:); end
  def options; end
  def success?; end
  def timed_out; end
  def timed_out?; end
  def to_s; end
end
class ProcessExecuter::ResultWithCapture < SimpleDelegator
  def initialize(result, stdout_buffer:, stderr_buffer:); end
  def stderr; end
  def stderr_buffer; end
  def stdout; end
  def stdout_buffer; end
end

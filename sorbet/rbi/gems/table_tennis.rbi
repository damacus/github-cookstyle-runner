# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/table_tennis/all/table_tennis.rbi
#
# table_tennis-0.0.7

module TableTennis
  def self.defaults; end
  def self.defaults=(arg0); end
  def self.new(*args, &block); end
end
module TableTennis::Util
end
module TableTennis::Util::Inspectable
  def inspect; end
end
class TableTennis::Util::MagicOptions
  def [](name); end
  def []=(name, value); end
  def initialize(schema, options = nil, &block); end
  def inspect; end
  def magic_add_attribute(name, type); end
  def magic_attributes; end
  def magic_attributes=(arg0); end
  def magic_get(name); end
  def magic_sanity(name, type); end
  def magic_set(name, value); end
  def magic_values; end
  def magic_values=(arg0); end
  def self.magic_coerce(value, type); end
  def self.magic_is_a?(value, klass); end
  def self.magic_pretty(klass); end
  def self.magic_resolve(type); end
  def self.magic_validate!(name, value, type); end
  def self.validate_any_of(value, possibilities); end
  def self.validate_array(value, array_type); end
  def self.validate_class(value, klass); end
  def self.validate_hash(value, hash_type); end
  def self.validate_range(value, range); end
  def self.validate_regexp(value, regexp); end
  def to_h; end
  def update!(hash); end
end
class TableTennis::Column
  def _memo_wise_original_type; end
  def alignment; end
  def c; end
  def config(*args, **, &block); end
  def data; end
  def each(&block); end
  def header; end
  def header=(arg0); end
  def initialize(data, name, c); end
  def map!(&block); end
  def measure; end
  def name; end
  def rows(*args, **, &block); end
  def self.allocate; end
  def self.instance_method(symbol); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def truncate(stop); end
  def type; end
  def width; end
  def width=(arg0); end
  extend Forwardable
  include Enumerable
  include TableTennis::Util::Inspectable
end
class TableTennis::Config < TableTennis::Util::MagicOptions
  def color_scale=(value); end
  def color_scales=(value); end
  def initialize(options = nil, &block); end
  def placeholder=(value); end
  def self.detect_color?; end
  def self.detect_theme; end
  def self.terminal_dark?; end
  def title=(value); end
end
class TableTennis::Row < Array
  def initialize(r, values); end
  def r; end
end
class TableTennis::TableData
  def _memo_wise_original_chrome_width; end
  def _memo_wise_original_column_names; end
  def _memo_wise_original_columns; end
  def _memo_wise_original_fat_rows; end
  def _memo_wise_original_rows; end
  def _memo_wise_original_theme; end
  def chrome_width; end
  def column_names; end
  def columns; end
  def config; end
  def config=(arg0); end
  def data_width; end
  def debug(str); end
  def debug_if_slow(str, &block); end
  def fat_rows; end
  def get_style(r: nil, c: nil); end
  def initialize(rows:, config: nil); end
  def input_rows; end
  def input_rows=(arg0); end
  def links; end
  def links=(arg0); end
  def rows; end
  def self.allocate; end
  def self.instance_method(symbol); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def set_style(style:, r: nil, c: nil); end
  def styles; end
  def styles=(arg0); end
  def symbolize(obj); end
  def table_width; end
  def theme; end
  include TableTennis::Util::Inspectable
end
class TableTennis::Table
  def column_names(*args, **, &block); end
  def columns(*args, **, &block); end
  def config(*args, **, &block); end
  def data; end
  def debug(*args, **, &block); end
  def debug_if_slow(*args, **, &block); end
  def initialize(rows, options = nil, &block); end
  def render(io = nil); end
  def rows(*args, **, &block); end
  def sanity!; end
  def save(path); end
  def to_s; end
  extend Forwardable
  include TableTennis::Util::Inspectable
end
class TableTennis::Theme
  def _memo_wise_original_codes(value); end
  def _memo_wise_original_paint(str, value); end
  def _memo_wise_original_term_program; end
  def codes(value); end
  def initialize(name); end
  def link(str, link); end
  def name; end
  def paint(str, value); end
  def self.allocate; end
  def self.info; end
  def self.instance_method(symbol); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def term_program; end
end
module TableTennis::Stage
end
class TableTennis::Stage::Base
  def column_names(*args, **, &block); end
  def columns(*args, **, &block); end
  def config(*args, **, &block); end
  def data; end
  def debug(*args, **, &block); end
  def debug_if_slow(*args, **, &block); end
  def initialize(data); end
  def input_rows(*args, **, &block); end
  def rows(*args, **, &block); end
  def self.allocate; end
  def self.instance_method(symbol); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def theme(*args, **, &block); end
  extend Forwardable
  include TableTennis::Util::Inspectable
end
class TableTennis::Stage::Format < TableTennis::Stage::Base
  def _memo_wise_original_fn_float(value); end
  def fmt_number(x, digits: nil); end
  def fn_default(value); end
  def fn_float(value); end
  def fn_int(value); end
  def fn_time(value); end
  def run; end
  def to_f(str); end
  def to_i(str); end
end
class TableTennis::Stage::Layout < TableTennis::Stage::Base
  def autolayout; end
  def chrome_width(*args, **, &block); end
  def data_width(*args, **, &block); end
  def run; end
end
class TableTennis::Stage::Painter < TableTennis::Stage::Base
  def mark_style(user_mark); end
  def paint_columns; end
  def paint_headers; end
  def paint_placeholders; end
  def paint_row_numbers; end
  def paint_rows; end
  def paint_title; end
  def run; end
  def scale(c, scale, rows, t); end
  def scale_non_numeric(c, scale); end
  def scale_numeric(c, scale); end
  def set_style(*args, **, &block); end
end
class TableTennis::Stage::Render < TableTennis::Stage::Base
  def _memo_wise_original_pipe; end
  def _memo_wise_original_search; end
  def paint(str, style); end
  def pipe; end
  def render_cell(value, r, c, default_cell_style); end
  def render_empty; end
  def render_row(r); end
  def render_separator(l, m, r); end
  def render_title; end
  def run(io); end
  def search; end
  def search_cell(value); end
end
module TableTennis::Util::Colors
  def ansi_color_to_hex(num); end
  def contrast(bg); end
  def dark?(color); end
  def get(color); end
  def luma(hex); end
  def self._memo_wise_original_contrast(bg); end
  def self.allocate; end
  def self.ansi_color_to_hex(num); end
  def self.contrast(bg); end
  def self.dark?(color); end
  def self.get(color); end
  def self.instance_method(symbol); end
  def self.luma(hex); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def self.spectrum; end
  def self.to_hex(rgb); end
  def self.to_rgb(hex); end
  def spectrum; end
  def to_hex(rgb); end
  def to_rgb(hex); end
end
module TableTennis::Util::Console
  def fileno(*args, **kwargs, &block); end
  def getbyte(*args, **kwargs, &block); end
  def raw(*args, **kwargs, &block); end
  def self.fileno(*args, **kwargs, &block); end
  def self.getbyte(*args, **kwargs, &block); end
  def self.raw(*args, **kwargs, &block); end
  def self.syswrite(*args, **kwargs, &block); end
  def self.winsize(*, **, &); end
  def syswrite(*args, **kwargs, &block); end
  def winsize(*, **, &); end
end
module TableTennis::Util::Identify
  def float?(str); end
  def identify(value); end
  def identify_column(values); end
  def int?(str); end
  def na?(str); end
  def number?(str); end
  def self.allocate; end
  def self.float?(str); end
  def self.identify(value); end
  def self.identify_column(values); end
  def self.instance_method(symbol); end
  def self.int?(str); end
  def self.memo_wise(method_name_or_hash); end
  def self.na?(str); end
  def self.number?(str); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def self.time?(value); end
  def time?(value); end
end
module TableTennis::Util::Scale
  def color_stops(name); end
  def interpolate(name, t); end
  def lerp(t, v0, v1); end
  def self._memo_wise_original_color_stops(name); end
  def self.allocate; end
  def self.color_stops(name); end
  def self.instance_method(symbol); end
  def self.interpolate(name, t); end
  def self.lerp(t, v0, v1); end
  def self.memo_wise(method_name_or_hash); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
end
module TableTennis::Util::Strings
  def center(str, width); end
  def hyperlink(str); end
  def painted?(str); end
  def self.allocate; end
  def self.center(str, width); end
  def self.hyperlink(str); end
  def self.instance_method(symbol); end
  def self.memo_wise(method_name_or_hash); end
  def self.painted?(str); end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
  def self.simple?(str); end
  def self.titleize(str); end
  def self.truncate(str, stop); end
  def self.truncate0(text, stop); end
  def self.unpaint(str); end
  def self.width(str); end
  def simple?(str); end
  def titleize(str); end
  def truncate(str, stop); end
  def truncate0(text, stop); end
  def unpaint(str); end
  def width(str); end
end
module TableTennis::Util::Termbg
  def bg; end
  def debug(s); end
  def decode_osc_response(response); end
  def env_colorfgbg(env = nil); end
  def fg; end
  def in_foreground?; end
  def info; end
  def load_ffi!; end
  def osc_query(attr); end
  def osc_supported?; end
  def read_term_response; end
  def self._memo_wise_original_bg; end
  def self._memo_wise_original_fg; end
  def self._memo_wise_original_in_foreground?; end
  def self._memo_wise_original_load_ffi!; end
  def self.allocate; end
  def self.bg; end
  def self.debug(s); end
  def self.decode_osc_response(response); end
  def self.env_colorfgbg(env = nil); end
  def self.fg; end
  def self.in_foreground?; end
  def self.info; end
  def self.instance_method(symbol); end
  def self.load_ffi!; end
  def self.memo_wise(method_name_or_hash); end
  def self.osc_query(attr); end
  def self.osc_supported?; end
  def self.preset_memo_wise(method_name, *args, **kwargs); end
  def self.read_term_response; end
  def self.reset_memo_wise(method_name = nil, *args, **kwargs); end
end

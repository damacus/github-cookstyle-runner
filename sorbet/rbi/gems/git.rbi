# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/git/all/git.rbi
#
# git-3.0.0

module Git
  def config(name = nil, value = nil); end
  def global_config(name = nil, value = nil); end
  def self.bare(git_dir, options = nil); end
  def self.binary_version(binary_path = nil); end
  def self.clone(repository_url, directory = nil, options = nil); end
  def self.config; end
  def self.configure; end
  def self.default_branch(repository, options = nil); end
  def self.export(repository, name, options = nil); end
  def self.global_config(name = nil, value = nil); end
  def self.init(directory = nil, options = nil); end
  def self.ls_remote(location = nil, options = nil); end
  def self.open(working_dir, options = nil); end
end
class Git::Author
  def date; end
  def date=(arg0); end
  def email; end
  def email=(arg0); end
  def initialize(author_string); end
  def name; end
  def name=(arg0); end
end
class Git::Base
  def add(paths = nil, **options); end
  def add_remote(name, url, opts = nil); end
  def add_tag(name, *options); end
  def apply(file); end
  def apply_mail(file); end
  def archive(treeish, file = nil, opts = nil); end
  def branch(branch_name = nil); end
  def branches; end
  def cat_file(objectish); end
  def chdir; end
  def checkout(*args, **options); end
  def checkout_file(version, file); end
  def checkout_index(opts = nil); end
  def clean(opts = nil); end
  def commit(message, opts = nil); end
  def commit_all(message, opts = nil); end
  def commit_tree(tree = nil, opts = nil); end
  def config(name = nil, value = nil, options = nil); end
  def current_branch; end
  def delete_tag(name); end
  def describe(committish = nil, opts = nil); end
  def diff(objectish = nil, obj2 = nil); end
  def dir; end
  def each_conflict(&block); end
  def fetch(remote = nil, opts = nil); end
  def gblob(objectish); end
  def gc; end
  def gcommit(objectish); end
  def grep(string, path_limiter = nil, opts = nil); end
  def gtree(objectish); end
  def ignored_files; end
  def index; end
  def initialize(options = nil); end
  def is_branch?(branch); end
  def is_local_branch?(branch); end
  def is_remote_branch?(branch); end
  def lib; end
  def log(count = nil); end
  def ls_files(location = nil); end
  def ls_tree(objectish, opts = nil); end
  def merge(branch, message = nil, opts = nil); end
  def merge_base(*args); end
  def object(objectish); end
  def pull(remote = nil, branch = nil, opts = nil); end
  def push(*args, **options); end
  def read_tree(treeish, opts = nil); end
  def remote(remote_name = nil); end
  def remotes; end
  def remove(path = nil, opts = nil); end
  def remove_remote(name); end
  def repack; end
  def repo; end
  def repo_size; end
  def reset(commitish = nil, opts = nil); end
  def reset_hard(commitish = nil, opts = nil); end
  def rev_parse(objectish); end
  def revert(commitish = nil, opts = nil); end
  def revparse(objectish); end
  def rm(path = nil, opts = nil); end
  def self.bare(git_dir, options = nil); end
  def self.binary_version(binary_path); end
  def self.clone(repository_url, directory, options = nil); end
  def self.config; end
  def self.init(directory = nil, options = nil); end
  def self.normalize_index(options); end
  def self.normalize_paths(options, default_working_directory: nil, default_repository: nil, bare: nil); end
  def self.normalize_repository(options, default:, bare: nil); end
  def self.normalize_working_directory(options, default:, bare: nil); end
  def self.open(working_dir, options = nil); end
  def self.repository_default_branch(repository, options = nil); end
  def self.root_of_worktree(working_dir); end
  def set_index(index_file, check = nil); end
  def set_remote_url(name, url); end
  def set_working(work_dir, check = nil); end
  def show(objectish = nil, path = nil); end
  def status; end
  def tag(tag_name); end
  def tags; end
  def update_ref(branch, commit); end
  def with_index(new_index); end
  def with_temp_index(&blk); end
  def with_temp_working(&blk); end
  def with_working(work_dir); end
  def worktree(dir, commitish = nil); end
  def worktrees; end
  def write_and_commit_tree(opts = nil); end
  def write_tree; end
end
class Git::Path
  def initialize(path, check_path = nil); end
  def path; end
  def path=(arg0); end
  def readable?; end
  def to_s; end
  def writable?; end
end
class Git::Branch < Git::Path
  def archive(file, opts = nil); end
  def check_if_create; end
  def checkout; end
  def contains?(commit); end
  def create; end
  def current; end
  def delete; end
  def determine_current; end
  def full; end
  def full=(arg0); end
  def gcommit; end
  def in_branch(message = nil); end
  def initialize(base, name); end
  def merge(branch = nil, message = nil); end
  def name; end
  def name=(arg0); end
  def parse_name(name); end
  def remote; end
  def remote=(arg0); end
  def stashes; end
  def to_a; end
  def to_s; end
  def update_ref(commit); end
end
class Git::Branches
  def [](branch_name); end
  def each(&block); end
  def initialize(base); end
  def local; end
  def remote; end
  def size; end
  def to_s; end
  include Enumerable
end
class Git::CommandLineResult
  def git_cmd; end
  def initialize(git_cmd, status, stdout, stderr); end
  def status; end
  def stderr; end
  def stdout; end
end
class Git::Error < StandardError
end
module Git::GitExecuteError
end
class Git::CommandLineError < Git::Error
  def error_message; end
  def initialize(result); end
  def result; end
end
class Git::FailedError < Git::CommandLineError
end
class Git::SignaledError < Git::CommandLineError
end
class Git::TimeoutError < Git::SignaledError
  def error_message; end
  def initialize(result, timeout_duration); end
  def timeout_duration; end
end
class Git::ProcessIOError < Git::Error
end
class Git::UnexpectedResultError < Git::Error
end
class Git::CommandLine
  def binary_path; end
  def build_git_cmd(args); end
  def env; end
  def global_opts; end
  def initialize(env, binary_path, global_opts, logger); end
  def logger; end
  def post_process(raw_output, normalize, chomp); end
  def post_process_all(raw_outputs, normalize, chomp); end
  def process_result(result, normalize, chomp, timeout); end
  def run(*args, normalize:, chomp:, merge:, out: nil, err: nil, chdir: nil, timeout: nil); end
end
class Git::Config
  def binary_path; end
  def binary_path=(arg0); end
  def git_ssh; end
  def git_ssh=(arg0); end
  def initialize; end
  def timeout; end
  def timeout=(arg0); end
end
class Git::Diff
  def [](key); end
  def cache_full; end
  def cache_name_status; end
  def cache_stats; end
  def deletions; end
  def each(&block); end
  def from; end
  def initialize(base, from = nil, to = nil); end
  def insertions; end
  def lines; end
  def name_status; end
  def patch(file = nil); end
  def path(path); end
  def process_full; end
  def process_full_diff; end
  def size; end
  def stats; end
  def to; end
  def to_s(file = nil); end
  include Enumerable
end
class Git::Diff::DiffFile
  def binary?; end
  def blob(type = nil); end
  def dst; end
  def dst=(arg0); end
  def initialize(base, hash); end
  def mode; end
  def mode=(arg0); end
  def patch; end
  def patch=(arg0); end
  def path; end
  def path=(arg0); end
  def src; end
  def src=(arg0); end
  def type; end
  def type=(arg0); end
end
module Git::EncodingUtils
  def self.best_guess_encoding; end
  def self.default_encoding; end
  def self.detected_encoding(str); end
  def self.encoding_options; end
  def self.normalize_encoding(str); end
end
class Git::EscapedPath
  def escaped_path_to_bytes(path); end
  def extract_escape(path, index); end
  def extract_octal(path, index); end
  def extract_single_char(path, index); end
  def initialize(path); end
  def next_byte(path, index); end
  def path; end
  def unescape; end
end
class Git::Index < Git::Path
end
class Git::Lib
  def add(paths = nil, options = nil); end
  def apply(patch_file); end
  def apply_mail(patch_file); end
  def archive(sha, file = nil, opts = nil); end
  def assert_args_are_not_options(arg_name, *args); end
  def branch_contains(commit, branch_name = nil); end
  def branch_current; end
  def branch_delete(branch); end
  def branch_new(branch); end
  def branches_all; end
  def cat_file_commit(object); end
  def cat_file_contents(object, &block); end
  def cat_file_size(object); end
  def cat_file_tag(object); end
  def cat_file_type(object); end
  def change_head_branch(branch_name); end
  def checkout(branch = nil, opts = nil); end
  def checkout_file(version, file); end
  def checkout_index(opts = nil); end
  def clean(opts = nil); end
  def clone(repository_url, directory, opts = nil); end
  def command(*args, out: nil, err: nil, normalize: nil, chomp: nil, merge: nil, chdir: nil, timeout: nil); end
  def command_line; end
  def command_lines(cmd, *opts, chdir: nil); end
  def commit(message, opts = nil); end
  def commit_data(object); end
  def commit_tree(tree, opts = nil); end
  def compare_version_to(*other_version); end
  def config_get(name); end
  def config_list; end
  def config_remote(name); end
  def config_set(name, value, options = nil); end
  def conflicts; end
  def current_branch_state; end
  def current_command_version; end
  def describe(commit_ish = nil, opts = nil); end
  def diff_as_hash(diff_command, opts = nil); end
  def diff_files; end
  def diff_full(obj1 = nil, obj2 = nil, opts = nil); end
  def diff_index(treeish); end
  def diff_name_status(reference1 = nil, reference2 = nil, opts = nil); end
  def diff_stats(obj1 = nil, obj2 = nil, opts = nil); end
  def each_cat_file_header(data); end
  def empty?; end
  def env_overrides; end
  def fetch(remote, opts); end
  def full_log_commits(opts = nil); end
  def full_tree(sha); end
  def gc; end
  def git_dir; end
  def git_index_file; end
  def git_work_dir; end
  def global_config_get(name); end
  def global_config_list; end
  def global_config_set(name, value); end
  def global_opts; end
  def grep(string, opts = nil); end
  def ignored_files; end
  def init(opts = nil); end
  def initialize(base = nil, logger = nil); end
  def list_files(ref_dir); end
  def log_commits(opts = nil); end
  def log_common_options(opts); end
  def log_path_options(opts); end
  def ls_files(location = nil); end
  def ls_remote(location = nil, opts = nil); end
  def ls_tree(sha, opts = nil); end
  def meets_required_version?; end
  def merge(branch, message = nil, opts = nil); end
  def merge_base(*args); end
  def mv(file1, file2); end
  def name_rev(commit_ish); end
  def namerev(commit_ish); end
  def object_contents(object, &block); end
  def object_size(object); end
  def object_type(object); end
  def parse_config(file); end
  def parse_config_list(lines); end
  def process_commit_data(data, sha); end
  def process_commit_log_data(data); end
  def process_tag_data(data, name); end
  def pull(remote = nil, branch = nil, opts = nil); end
  def push(remote = nil, branch = nil, opts = nil); end
  def read_tree(treeish, opts = nil); end
  def remote_add(name, url, opts = nil); end
  def remote_remove(name); end
  def remote_set_url(name, url); end
  def remotes; end
  def repack; end
  def repository_default_branch(repository); end
  def required_command_version; end
  def reset(commit, opts = nil); end
  def return_base_opts_from_clone(clone_dir, opts); end
  def rev_parse(revision); end
  def revert(commitish, opts = nil); end
  def revparse(revision); end
  def rm(path = nil, opts = nil); end
  def self.warn_if_old_command(lib); end
  def show(objectish = nil, path = nil); end
  def stash_apply(id = nil); end
  def stash_clear; end
  def stash_list; end
  def stash_save(message); end
  def stashes_all; end
  def tag(name, *opts); end
  def tag_data(object); end
  def tag_sha(tag_name); end
  def tags; end
  def tree_depth(sha); end
  def unescape_quoted_path(path); end
  def unexpected_branch_line_error(lines, line, index); end
  def unmerged; end
  def untracked_files; end
  def update_ref(ref, commit); end
  def worktree_add(dir, commitish = nil); end
  def worktree_prune; end
  def worktree_remove(dir); end
  def worktrees_all; end
  def write_tree; end
end
class Git::Lib::HeadState < Struct
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def state; end
  def state=(_); end
end
class Git::Log
  def [](index); end
  def all; end
  def author(regex); end
  def between(sha1, sha2 = nil); end
  def check_log; end
  def cherry; end
  def dirty_log; end
  def each(&block); end
  def first; end
  def grep(regex); end
  def initialize(base, max_count = nil); end
  def last; end
  def max_count(num_or_all); end
  def object(objectish); end
  def path(path); end
  def run_log; end
  def since(date); end
  def size; end
  def skip(num); end
  def to_s; end
  def until(date); end
  include Enumerable
end
class Git::Object
  def self.new(base, objectish, type = nil, is_tag = nil); end
end
class Git::Object::AbstractObject
  def archive(file = nil, opts = nil); end
  def blob?; end
  def commit?; end
  def contents(&block); end
  def contents_array; end
  def diff(objectish); end
  def grep(string, path_limiter = nil, opts = nil); end
  def initialize(base, objectish); end
  def log(count = nil); end
  def mode; end
  def mode=(arg0); end
  def objectish; end
  def objectish=(arg0); end
  def sha; end
  def size; end
  def size=(arg0); end
  def tag?; end
  def to_s; end
  def tree?; end
  def type; end
  def type=(arg0); end
end
class Git::Object::Blob < Git::Object::AbstractObject
  def blob?; end
  def initialize(base, sha, mode = nil); end
end
class Git::Object::Tree < Git::Object::AbstractObject
  def blobs; end
  def check_tree; end
  def children; end
  def depth; end
  def files; end
  def full_tree; end
  def initialize(base, sha, mode = nil); end
  def subdirectories; end
  def subtrees; end
  def tree?; end
  def trees; end
end
class Git::Object::Commit < Git::Object::AbstractObject
  def author; end
  def author_date; end
  def check_commit; end
  def commit?; end
  def committer; end
  def committer_date; end
  def date; end
  def diff_parent; end
  def gtree; end
  def initialize(base, sha, init = nil); end
  def message; end
  def name; end
  def parent; end
  def parents; end
  def set_commit(data); end
end
class Git::Object::Tag < Git::Object::AbstractObject
  def annotated?; end
  def check_tag; end
  def initialize(base, sha, name); end
  def message; end
  def name; end
  def name=(arg0); end
  def tag?; end
  def tagger; end
end
class Git::Remote < Git::Path
  def branch(branch = nil); end
  def fetch(opts = nil); end
  def fetch_opts; end
  def fetch_opts=(arg0); end
  def initialize(base, name); end
  def merge(branch = nil); end
  def name; end
  def name=(arg0); end
  def remove; end
  def to_s; end
  def url; end
  def url=(arg0); end
end
class Git::Repository < Git::Path
end
class Git::Status
  def [](file); end
  def added; end
  def added?(file); end
  def case_aware_include?(cased_hash, downcased_hash, file); end
  def changed; end
  def changed?(file); end
  def construct_status; end
  def deleted; end
  def deleted?(file); end
  def downcase_keys(hash); end
  def each(&block); end
  def fetch_added; end
  def fetch_modified; end
  def fetch_untracked; end
  def ignore_case?; end
  def initialize(base); end
  def lc_added; end
  def lc_changed; end
  def lc_deleted; end
  def lc_untracked; end
  def pretty; end
  def pretty_file(file); end
  def untracked; end
  def untracked?(file); end
  include Enumerable
end
class Git::Status::StatusFile
  def blob(type = nil); end
  def initialize(base, hash); end
  def mode_index; end
  def mode_index=(arg0); end
  def mode_repo; end
  def mode_repo=(arg0); end
  def path; end
  def path=(arg0); end
  def sha_index; end
  def sha_index=(arg0); end
  def sha_repo; end
  def sha_repo=(arg0); end
  def stage; end
  def stage=(arg0); end
  def type; end
  def type=(arg0); end
  def untracked; end
  def untracked=(arg0); end
end
class Git::Stash
  def initialize(base, message, existing = nil); end
  def message; end
  def save; end
  def saved?; end
  def to_s; end
end
class Git::Stashes
  def [](index); end
  def all; end
  def apply(index = nil); end
  def clear; end
  def each(&block); end
  def initialize(base); end
  def save(message); end
  def size; end
  include Enumerable
end
class Git::URL
  def self.clone_to(url, bare: nil, mirror: nil); end
  def self.parse(url); end
end
class Git::GitAltURI < Addressable::URI
  def initialize(user:, host:, path:); end
  def to_s; end
end
class Git::WorkingDirectory < Git::Path
end
class Git::Worktree < Git::Path
  def add; end
  def dir; end
  def dir=(arg0); end
  def full; end
  def full=(arg0); end
  def gcommit; end
  def gcommit=(arg0); end
  def initialize(base, dir, gcommit = nil); end
  def remove; end
  def to_a; end
  def to_s; end
end
class Git::Worktrees
  def [](worktree_name); end
  def each(&block); end
  def initialize(base); end
  def prune; end
  def size; end
  def to_s; end
  include Enumerable
end

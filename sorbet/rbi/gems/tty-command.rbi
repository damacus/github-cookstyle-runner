# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/tty-command/all/tty-command.rbi
#
# tty-command-0.10.1

module TTY
end
class TTY::Command
  def command(*args); end
  def dry_run?; end
  def execute_command(cmd, &block); end
  def find_printer_class(name); end
  def initialize(**options); end
  def printer; end
  def ruby(*args, &block); end
  def run!(*args, &block); end
  def run(*args, &block); end
  def select_runner(dry_run); end
  def self.record_separator; end
  def self.record_separator=(sep); end
  def self.windows?; end
  def test(*args); end
  def use_printer(class_or_name, options); end
  def wait(*args); end
end
class TTY::Command::Cmd
  def argv; end
  def chdir(value); end
  def command; end
  def environment; end
  def environment_string; end
  def evars(value, &block); end
  def group(value); end
  def initialize(env_or_cmd, *args); end
  def only_output_on_error; end
  def options; end
  def sanitize(value); end
  def to_command; end
  def to_hash; end
  def to_s; end
  def umask(value); end
  def update(options); end
  def user(value); end
  def uuid; end
  def with_clean_env; end
end
class TTY::Command::ExitError < RuntimeError
  def extract_output(value); end
  def info(cmd_name, result); end
  def initialize(cmd_name, result); end
end
class TTY::Command::Result
  def ==(other); end
  def complete?; end
  def each(separator = nil, &block); end
  def err; end
  def exit_status; end
  def exited?; end
  def exitstatus; end
  def failed?; end
  def failure?; end
  def initialize(status, out, err, runtime = nil); end
  def out; end
  def runtime; end
  def status; end
  def stderr; end
  def stdout; end
  def success?; end
  def to_ary; end
  def to_i; end
  def to_s; end
  include Enumerable
end
class TTY::Command::DryRunner
  def cmd; end
  def initialize(cmd, printer); end
  def run!(*); end
end
module TTY::Command::ChildProcess
  def close_fds(*fds); end
  def convert(spawn_key, spawn_value); end
  def convert_to_fd(object); end
  def fd?(object); end
  def fd_to_process_key(object); end
  def normalize_redirect_options(options); end
  def self.close_fds(*fds); end
  def self.convert(spawn_key, spawn_value); end
  def self.convert_to_fd(object); end
  def self.fd?(object); end
  def self.fd_to_process_key(object); end
  def self.normalize_redirect_options(options); end
  def self.spawn(cmd); end
  def self.try_loading_pty(verbose = nil); end
  def self.try_reading(object); end
  def spawn(cmd); end
  def try_loading_pty(verbose = nil); end
  def try_reading(object); end
end
class TTY::Command::Truncator
  def <<(content); end
  def append(value, dst); end
  def copy(value, dest); end
  def initialize(options = nil); end
  def read; end
  def to_s; end
  def write(content); end
end
class TTY::Command::ProcessRunner
  def cmd; end
  def handle_timeout(runtime); end
  def initialize(cmd, printer, &block); end
  def read_stream(stream, handler); end
  def read_streams(stdout, stderr); end
  def run!; end
  def terminate(pid); end
  def waitpid(pid); end
  def write_stream(stream, input); end
end
module TTY::Command::Printers
end
class TTY::Command::Printers::Abstract
  def decorate(*args, **, &block); end
  def err_data; end
  def err_data=(arg0); end
  def initialize(output, options = nil); end
  def options; end
  def out_data; end
  def out_data=(arg0); end
  def output; end
  def print_command_err_data(cmd, *args); end
  def print_command_exit(cmd, *args); end
  def print_command_out_data(cmd, *args); end
  def print_command_start(cmd, *args); end
  def write(cmd, message); end
  extend Forwardable
end
class TTY::Command::Printers::Null < TTY::Command::Printers::Abstract
  def write(*); end
end
class TTY::Command::Printers::Pretty < TTY::Command::Printers::Abstract
  def initialize(*); end
  def pluralize(count, word); end
  def print_command_err_data(cmd, *args); end
  def print_command_exit(cmd, status, runtime, *args); end
  def print_command_out_data(cmd, *args); end
  def print_command_start(cmd, *args); end
  def success_or_failure(status); end
  def write(cmd, message, data = nil); end
end
class TTY::Command::Printers::Progress < TTY::Command::Printers::Abstract
  def print_command_exit(cmd, status, runtime, *args); end
  def success_or_failure(status); end
  def write(*); end
end
class TTY::Command::Printers::Quiet < TTY::Command::Printers::Abstract
  def print_command_err_data(cmd, *args); end
  def print_command_exit(cmd, status, *args); end
  def print_command_out_data(cmd, *args); end
  def print_command_start(cmd); end
  def write(cmd, message, data = nil); end
end
class TTY::Command::ExecuteError < StandardError
end
class TTY::Command::TimeoutExceeded < StandardError
end

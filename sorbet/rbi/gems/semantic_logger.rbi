# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/semantic_logger/all/semantic_logger.rbi
#
# semantic_logger-4.17.0

class Thread
end
module SemanticLogger
  def self.[](klass); end
  def self.add_appender(**args, &block); end
  def self.add_signal_handler(log_level_signal = nil, thread_dump_signal = nil, gc_log_microseconds = nil); end
  def self.appenders; end
  def self.application; end
  def self.application=(application); end
  def self.backtrace_level; end
  def self.backtrace_level=(level); end
  def self.backtrace_level_index; end
  def self.clear_appenders!; end
  def self.close; end
  def self.default_level; end
  def self.default_level=(level); end
  def self.default_level_index; end
  def self.environment; end
  def self.environment=(environment); end
  def self.fast_tag(tag); end
  def self.flush; end
  def self.host; end
  def self.host=(host); end
  def self.lag_check_interval; end
  def self.lag_check_interval=(lag_check_interval); end
  def self.lag_threshold_s; end
  def self.named_tagged(hash); end
  def self.named_tags; end
  def self.on_log(object = nil, &block); end
  def self.pop_named_tags(quantity = nil); end
  def self.pop_tags(quantity = nil); end
  def self.push_named_tags(hash); end
  def self.push_tags(*tags); end
  def self.queue_size; end
  def self.remove_appender(appender); end
  def self.reopen; end
  def self.silence(new_level = nil); end
  def self.sync!; end
  def self.sync?; end
  def self.tagged(*tags, &block); end
  def self.tags; end
end
module SemanticLogger::Utils
  def self.camelize(term); end
  def self.constantize_symbol(symbol, namespace = nil); end
  def self.extract_backtrace(stack = nil); end
  def self.extract_path?(path); end
  def self.extract_paths; end
  def self.method_visibility(mod, method_name); end
  def self.strip_backtrace(stack = nil); end
  def self.strip_path?(path); end
  def self.strip_paths; end
end
module SemanticLogger::AnsiColors
end
module SemanticLogger::Levels
  def self.index(level); end
  def self.level(level_index); end
end
class SemanticLogger::Base
  def backtrace(thread: nil, level: nil, message: nil, payload: nil, metric: nil, metric_amount: nil); end
  def benchmark(level, message, params = nil, &block); end
  def benchmark_debug(message, params = nil, &block); end
  def benchmark_error(message, params = nil, &block); end
  def benchmark_fatal(message, params = nil, &block); end
  def benchmark_info(message, params = nil, &block); end
  def benchmark_trace(message, params = nil, &block); end
  def benchmark_warn(message, params = nil, &block); end
  def debug(message = nil, payload = nil, exception = nil, &block); end
  def debug?; end
  def error(message = nil, payload = nil, exception = nil, &block); end
  def error?; end
  def fast_tag(tag, &block); end
  def fatal(message = nil, payload = nil, exception = nil, &block); end
  def fatal?; end
  def filter; end
  def filter=(arg0); end
  def filtered?(log); end
  def info(message = nil, payload = nil, exception = nil, &block); end
  def info?; end
  def initialize(klass, level = nil, filter = nil); end
  def level; end
  def level=(level); end
  def level_index; end
  def log(_log_); end
  def log_internal(level, index, message = nil, payload = nil, exception = nil); end
  def measure(level, message, params = nil, &block); end
  def measure_debug(message, params = nil, &block); end
  def measure_error(message, params = nil, &block); end
  def measure_fatal(message, params = nil, &block); end
  def measure_info(message, params = nil, &block); end
  def measure_internal(level, index, message, params); end
  def measure_method(index:, level:, message:, min_duration:, metric:, log_exception:, on_exception_level:); end
  def measure_trace(message, params = nil, &block); end
  def measure_warn(message, params = nil, &block); end
  def meets_log_level?(log); end
  def name; end
  def name=(arg0); end
  def named_tags; end
  def pop_tags(quantity = nil); end
  def push_tags(*tags); end
  def should_log?(log); end
  def silence(new_level = nil, &block); end
  def tagged(*tags); end
  def tags; end
  def trace(message = nil, payload = nil, exception = nil, &block); end
  def trace?; end
  def warn(message = nil, payload = nil, exception = nil, &block); end
  def warn?; end
  def with_tags(*tags); end
end
module SemanticLogger::Formatters
  def self.factory(formatter); end
end
class SemanticLogger::Formatters::Base
  def format_time(time); end
  def initialize(time_format: nil, log_host: nil, log_application: nil, log_environment: nil, precision: nil); end
  def log; end
  def log=(arg0); end
  def log_application; end
  def log_application=(arg0); end
  def log_environment; end
  def log_environment=(arg0); end
  def log_host; end
  def log_host=(arg0); end
  def logger; end
  def logger=(arg0); end
  def pid; end
  def precision; end
  def precision=(arg0); end
  def self.build_time_format(precision = nil); end
  def time; end
  def time_format; end
  def time_format=(arg0); end
end
class SemanticLogger::Log
  def assign(message: nil, payload: nil, min_duration: nil, exception: nil, metric: nil, metric_amount: nil, duration: nil, backtrace: nil, log_exception: nil, on_exception_level: nil, dimensions: nil); end
  def assign_hash(hash); end
  def backtrace; end
  def backtrace=(arg0); end
  def backtrace_to_s; end
  def cleansed_message; end
  def context; end
  def context=(arg0); end
  def dimensions; end
  def dimensions=(arg0); end
  def duration; end
  def duration=(arg0); end
  def duration_human; end
  def duration_to_s; end
  def each_exception; end
  def exception; end
  def exception=(arg0); end
  def extract_arguments(payload, message = nil); end
  def extract_file_and_line(stack, short_name = nil); end
  def file_name_and_line(short_name = nil); end
  def initialize(name, level, index = nil); end
  def level; end
  def level=(arg0); end
  def level_index; end
  def level_index=(arg0); end
  def level_to_s; end
  def message; end
  def message=(arg0); end
  def metric; end
  def metric=(arg0); end
  def metric_amount; end
  def metric_amount=(arg0); end
  def metric_only?; end
  def name; end
  def name=(arg0); end
  def named_tags; end
  def named_tags=(arg0); end
  def payload; end
  def payload=(arg0); end
  def payload?; end
  def payload_to_s; end
  def process_info(thread_name_length = nil); end
  def set_context(key, value); end
  def tags; end
  def tags=(arg0); end
  def thread_name; end
  def thread_name=(arg0); end
  def time; end
  def time=(arg0); end
  def to_h(host = nil, application = nil, environment = nil); end
end
class SemanticLogger::Subscriber < SemanticLogger::Base
  def application; end
  def application=(arg0); end
  def close; end
  def console_output?; end
  def default_formatter; end
  def environment; end
  def environment=(arg0); end
  def flush; end
  def formatter; end
  def formatter=(formatter); end
  def host; end
  def host=(arg0); end
  def initialize(level: nil, formatter: nil, filter: nil, application: nil, environment: nil, host: nil, metrics: nil, &block); end
  def level; end
  def level_index; end
  def log(log); end
  def logger; end
  def logger=(arg0); end
  def metrics=(arg0); end
  def metrics?; end
  def should_log?(log); end
end
module SemanticLogger::Loggable
  def self.included(base); end
end
module SemanticLogger::Loggable::ClassMethods
  def logger_measure_method(method_name, min_duration: nil, metric: nil, log_exception: nil, on_exception_level: nil, message: nil, level: nil); end
  def logger_measure_module; end
end
module SemanticLogger::Concerns
end
module SemanticLogger::Concerns::Compatibility
  def add(severity, message = nil, progname = nil, &block); end
  def close; end
  def reopen(logdev = nil); end
  def self.included(base); end
end
module SemanticLogger::Appender
  def self.build(io: nil, file_name: nil, appender: nil, metric: nil, logger: nil, **args, &block); end
  def self.factory(async: nil, batch: nil, max_queue_size: nil, lag_check_interval: nil, lag_threshold_s: nil, batch_size: nil, batch_seconds: nil, **args, &block); end
end
class SemanticLogger::Appenders < Concurrent::Array
  def add(**args, &block); end
  def close; end
  def console_output?; end
  def flush; end
  def initialize(logger = nil); end
  def log(log); end
  def logger; end
  def logger=(arg0); end
  def reopen; end
end
class SemanticLogger::Appender::Async
  def active?; end
  def appender; end
  def application(*args, **, &block); end
  def capped?; end
  def check_lag(log); end
  def close; end
  def create_queue; end
  def environment(*args, **, &block); end
  def filter(*args, **, &block); end
  def flush; end
  def host(*args, **, &block); end
  def initialize(appender:, max_queue_size: nil, lag_check_interval: nil, lag_threshold_s: nil); end
  def lag_check_interval; end
  def lag_check_interval=(arg0); end
  def lag_threshold_s; end
  def lag_threshold_s=(arg0); end
  def level(*args, **, &block); end
  def level=(*args, **, &block); end
  def log(log); end
  def logger(*args, **, &block); end
  def logger=(*args, **, &block); end
  def max_queue_size; end
  def name(*args, **, &block); end
  def process; end
  def process_message(message); end
  def process_messages; end
  def queue; end
  def reopen; end
  def should_log?(*args, **, &block); end
  def submit_request(command); end
  def thread; end
  extend Forwardable
end
class SemanticLogger::Processor < SemanticLogger::Appender::Async
  def appenders; end
  def initialize(max_queue_size: nil); end
  def self.logger; end
  def self.logger=(arg0); end
  def start; end
end
class SemanticLogger::SyncProcessor
  def add(*, **, &); end
  def appenders; end
  def close; end
  def flush; end
  def initialize(appenders = nil); end
  def log(*, **, &); end
  def reopen(*args); end
  def self.logger; end
  def self.logger=(arg0); end
  def start; end
end
class SemanticLogger::Logger < SemanticLogger::Base
  def <<(message = nil, payload = nil, exception = nil, &block); end
  def datetime_format; end
  def datetime_format=(arg0); end
  def formatter; end
  def formatter=(arg0); end
  def initialize(klass, level = nil, filter = nil); end
  def log(log, message = nil, progname = nil, &block); end
  def progname; end
  def progname=(arg0); end
  def self.call_subscribers(log); end
  def self.processor; end
  def self.subscribe(object = nil, &block); end
  def self.subscribers; end
  def self.sync!; end
  def self.sync?; end
  def sev_threshold; end
  def sev_threshold=(level); end
  def silence_logger(new_level = nil, &block); end
  def unknown(message = nil, payload = nil, exception = nil, &block); end
  def unknown?; end
  include SemanticLogger::Concerns::Compatibility
end
class SemanticLogger::DebugAsTraceLogger < SemanticLogger::Logger
  def benchmark_debug(message, params = nil, &block); end
  def debug(message = nil, payload = nil, exception = nil, &block); end
  def debug?; end
  def measure_debug(message, params = nil, &block); end
end
module SemanticLogger::Metric
end
module SemanticLogger::Reporters
end
module SemanticLogger::Test
end
